<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Base V7 - 1v1 Split Screen</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@600;700&family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    <style>
        /* CHANGED: Patch 5A — CSS custom properties: fuente única de verdad para paleta, fuentes y espaciado.
           Cualquier cambio aquí se propaga a toda la UI sin editar regla por regla. */
        :root {
            --bo2-orange: #ff8000;
            --bo2-blue:   #00d1ff;
            --bo2-green:  #50c850;
            --bg-dark:    #050505;
            --bg-mid:     #1a1a1a;
            --ui-padding: 16px;
            --font-main:  'Orbitron', 'Rajdhani', sans-serif;
            --hud-bar-w:  clamp(120px, 20vw, 320px);
            --hud-bar-h:  clamp(8px, 1.2vh, 15px);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            /* Ensure UI is above Canvas */
        }

        /* SCREENS */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            /* Remove dark overlay */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 4rem;
            margin-bottom: 20px;
            text-transform: uppercase;
            text-shadow: 0 0 20px currentColor;
        }

        /* Wood Texture & Crosshair Style */
        #lobby h1 {
            font-size: 7rem;
            font-weight: 900;
            margin: 0;
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: -2px;

            -webkit-text-stroke: 4px #4e342e;
            color: transparent;

            background: repeating-linear-gradient(45deg,
                    #deb887,
                    #deb887 10px,
                    #cd853f 10px,
                    #cd853f 20px);
            -webkit-background-clip: text;
            background-clip: text;

            filter: drop-shadow(4px 4px 0px #4e342e) drop-shadow(6px 6px 0px #3e2723);

            font-family: 'Arial Black', 'Impact', sans-serif;
            transform: rotate(-3deg) scaleY(1.1);
            z-index: 10;
        }

        .crosshair-o {
            position: relative;
            display: inline-block;
            color: transparent;
            -webkit-text-stroke: 4px #4e342e;
        }

        .crosshair-o::after,
        .crosshair-o::before {
            content: '';
            position: absolute;
            background: #ff4500;
            z-index: 100;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .crosshair-o::before {
            width: 60%;
            height: 6px;
            top: 50%;
            left: 20%;
            transform: translateY(-50%);
        }

        .crosshair-o::after {
            width: 6px;
            height: 60%;
            left: 50%;
            top: 20%;
            transform: translateX(-50%);
        }

        #victory-screen h1 {
            color: #ffd700;
            text-shadow: 0 0 20px #ffd700;
            font-size: 5rem;
        }

        p {
            font-size: 1.5rem;
            color: #ccc;
            margin-bottom: 40px;
        }

        .btn-container {
            display: flex;
            gap: 20px;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            /* Let clicks pass to individual buttons */
        }

        #solo-btn {
            position: absolute;
            left: 22%;
            top: 25%;
            pointer-events: auto;
        }

        #pvp-btn {
            position: absolute;
            right: 22%;
            top: 25%;
            pointer-events: auto;
        }

        button {
            padding: 20px 50px;
            font-size: 1.5rem;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            text-transform: uppercase;
        }

        /* Removed specific button colors to use transparent style */
        /*
        #solo-btn {
            background: #00ff00;
            color: #000;
            box-shadow: 0 0 20px #00ff00;
        }

        #pvp-btn {
            background: #ff0055;
            color: #fff;
            box-shadow: 0 0 20px #ff0055;
        }

        #restart-btn {
            background: #ffd700;
            color: #000;
            box-shadow: 0 0 20px #ffd700;
        }
        */

        button:hover {
            transform: scale(1.1);
        }

        /* HUD */
        .hud-panel {
            position: absolute;
            width: 100%;
            height: 50%;
            pointer-events: none;
            display: none;
        }

        #hud-p1 {
            top: 0;
            border-bottom: 2px solid white;
        }

        #hud-p2 {
            bottom: 0;
            border-top: 2px solid white;
        }

        #hud-solo {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 2px solid black;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        /* CHANGED: Patch 5B — flexbox layout responsivo para el grupo de stats del HUD */
        .stats-group {
            position: absolute;
            bottom: clamp(8px, 2vh, 20px);
            right:  clamp(8px, 2vw, 20px);
            display: flex;
            flex-direction: row;
            gap: clamp(8px, 1.5vw, 20px);
            align-items: center;
        }

        .main-stats {
            display: flex;
            gap: clamp(8px, 1.5vw, 20px);
        }

        /* CHANGED: Patch 5C — long-bar usa var(--hud-bar-h) y clamp() para tablets/móviles */
        .long-bar {
            width: clamp(160px, 50vw, 800px);
            max-width: 800px;
            height: var(--hud-bar-h);
            border: 1px solid rgba(255, 255, 255, 0.5);
            margin-bottom: 0;
            background: rgba(0, 0, 0, 0.2);
        }

        .stat-box {
            background: transparent;
            padding: 10px 20px;
            border-radius: 10px;
            color: white;
            text-align: right;
        }

        /* Stamina Box specific style (First child) */
        .stats-bar .stat-box:first-child {
            background: transparent;
            padding-left: 0;
            padding-right: 0;
        }

        .difficulty-btn {
            padding: 20px 30px;
            font-size: 1.2rem;
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 200px;
            font-family: inherit;
            text-transform: uppercase;
            font-weight: bold;
        }

        .difficulty-btn:hover, .difficulty-btn.gp-hover {
            transform: scale(1.05);
        }

        /* EASY - GREEN */
        .diff-easy {
            color: #00ff00;
            border-color: rgba(0, 255, 0, 0.3);
            background: rgba(0, 255, 0, 0.05);
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .diff-easy:hover {
            background: rgba(0, 255, 0, 0.15);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        /* MEDIUM - YELLOW */
        .diff-medium {
            color: #ffd700;
            border-color: rgba(255, 215, 0, 0.3);
            background: rgba(255, 215, 0, 0.05);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .diff-medium:hover {
            background: rgba(255, 215, 0, 0.15);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        /* HARD - RED */
        .diff-hard {
            color: #ff4500;
            border-color: rgba(255, 69, 0, 0.3);
            background: rgba(255, 69, 0, 0.05);
            text-shadow: 0 0 10px rgba(255, 69, 0, 0.5);
        }

        .diff-hard:hover {
            background: rgba(255, 69, 0, 0.15);
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.3);
        }

        /* CHANGED: Patch 5C — font-size escalado con clamp: legible en móvil y pantalla grande */
        .stat-value {
            font-size: clamp(1.1rem, 2.5vw, 2rem);
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #aaa;
        }

        /* CHANGED: Patch 5C — bar-container usa var(--hud-bar-w/h) en lugar de valores fijos */
        .bar-container {
            width: var(--hud-bar-w);
            height: var(--hud-bar-h);
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.7);
            margin-bottom: 5px;
        }

        .bar-fill {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear;
        }

        .stamina-fill {
            background-color: #ffff00;
            box-shadow: 0 0 8px #ffff00;
        }

        .health-val {
            color: #ff3333;
        }

        .ammo-val {
            color: #ffff33;
        }

        .player-label {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 5px;
        }

        /* Message Overlay */
        #msg-overlay {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            font-size: 2rem;
            color: yellow;
            text-shadow: 2px 2px 0 #000;
            display: none;
        }

        /* WEAPON SELECT */
        #weapon-select {
            margin-top: 20px;
        }

        .weapon-btn {
            background: #333;
            color: #fff;
            border: 2px solid #555;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: inherit;
        }

        .weapon-btn:hover {
            background: #555;
        }

        .weapon-btn.selected {
            background: #00ff00;
            color: #000;
            border-color: #00ff00;
            box-shadow: 0 0 15px #00ff00;
        }

        .weapon-btn-solo {
            background: #333;
            color: #fff;
            border: 2px solid #555;
            padding: 15px 30px;
            font-size: 1.2rem;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
        }

        .weapon-btn-solo:hover, .weapon-btn-solo.gp-hover {
            background: #555;
        }

        /* GENERIC BUTTONS (Transparent Style) */
        button {
            font-family: inherit;
            border: none;
            outline: none;
            user-select: none;
        }

        .btn-transparent {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: #fff;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-weight: bold;
            text-transform: uppercase;
            border-radius: 12px;
            cursor: pointer;
            backdrop-filter: blur(4px);
            transition: transform 0.1s, background 0.2s, border-color 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn-transparent:hover, .btn-transparent.gp-hover {
            background: rgba(255, 255, 255, 0.35);
            transform: scale(1.05);
            border-color: #fff;
        }

        .btn-transparent:active {
            transform: scale(0.95);
        }

        /* WEAPON BUTTONS */
        .weapon-btn-solo {
            width: 140px;
            height: 140px;
            background: rgba(255, 255, 255, 0.15);
            /* Matches btn-transparent */
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: #fff;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            border-radius: 15px;
            transition: all 0.2s;
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .weapon-btn-solo:hover, .weapon-btn-solo.gp-hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-5px);
        }

        /* SELECTED STATES (Color-coded by weapon projectile) */
        .weapon-btn-solo.selected[data-weapon="sniper"] {
            background: rgba(0, 255, 0, 0.25);
            border-color: #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.4);
        }

        .weapon-btn-solo.selected[data-weapon="ar"] {
            background: rgba(255, 255, 0, 0.25);
            border-color: #ffff00;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.4);
        }

        .weapon-btn-solo.selected[data-weapon="smg"] {
            background: rgba(0, 255, 255, 0.25);
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }

        .weapon-btn-solo.selected[data-weapon="pistol"] {
            background: rgba(255, 0, 0, 0.25);
            border-color: #ff0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.4);
        }

        .weapon-btn-solo.selected[data-weapon="shotgun"] {
            background: rgba(255, 136, 0, 0.25);
            border-color: #ff8800;
            box-shadow: 0 0 15px rgba(255, 136, 0, 0.4);
        }

        .weapon-btn-solo.selected {
            color: #fff;
            backdrop-filter: blur(6px);
        }

        .weapon-btn-solo.p1:hover, .weapon-btn-solo.p1.gp-hover {
            border-color: #00ccff;
        }

        .weapon-btn-solo.p2:hover, .weapon-btn-solo.p2.gp-hover {
            border-color: #ff00ff;
        }

        /* IN-GAME MENU BTN (Kept as requested, but ensuring z-index) */
        #ingame-menu-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.15);
            /* Transparent */
            color: #fff;
            border: 2px solid rgba(255, 255, 255, 0.5);
            /* Semi-transparent border */
            font-size: 1rem;
            cursor: pointer;
            z-index: 100000;
            pointer-events: auto;
            font-weight: bold;
            user-select: none;
            backdrop-filter: blur(4px);
            border-radius: 8px;
            transition: all 0.2s;
        }

        #ingame-menu-btn:hover, #ingame-menu-btn.gp-hover {
            background: #fff;
            color: #000;
        }

        /* MENU BACKGROUND LAYER */
        #menu-background-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            /* Behind UI */
            background: transparent;
            overflow: hidden;
        }

        /* ── COD2-STYLE KILLCAM ── */
        #killcam-colorgrade {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            /* COD2: warm sepia tone */
            background: rgba(80, 50, 10, 0.22);
            mix-blend-mode: multiply;
        }

        #killcam-impact-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            background: rgba(255, 255, 255, 0.35);
            transition: opacity 0.08s;
        }

        /* ── KILLCAM OVERLAY ── */
        #killcam-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 60;
            display: none;
        }

        /* COD2 uses thin black bars, not huge ones */
        #killcam-bar-top,
        #killcam-bar-bottom {
            position: absolute;
            left: 0;
            width: 100%;
            background: #000;
            transition: height 0.18s ease-out;
        }

        #killcam-bar-top {
            top: 0;
            height: 0;
        }

        #killcam-bar-bottom {
            bottom: 0;
            height: 0;
        }

        /* COD2: "KILLCAM" sits inside the bottom bar, left-aligned */
        #killcam-label {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 52px;
            display: flex;
            align-items: center;
            padding-left: 28px;
            box-sizing: border-box;
            color: #fff;
            font-size: 0.78rem;
            letter-spacing: 5px;
            text-transform: uppercase;
            font-family: 'Arial Narrow', 'Arial', sans-serif;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.25s;
        }

        /* Timer bar fills the bottom bar */
        #killcam-timer-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 52px;
            background: transparent;
            overflow: hidden;
            opacity: 1;
        }

        #killcam-timer-fill {
            height: 100%;
            width: 100%;
            background: rgba(255, 255, 255, 0.07);
            transform-origin: left center;
            transition: transform 0.1s linear;
        }

        /* COD2 vignette: harder edges */
        #killcam-vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 45%, rgba(0, 0, 0, 0.6) 100%);
        }

        /* Hide slow-mo label (not COD2 style) */
        #killcam-slowmo-label {
            display: none !important;
        }

        /* CAPTURA DE LA ÚLTIMA JUGADA */
        #last-play-frame {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background-position: center;
            background-size: cover;
            background-repeat: no-repeat;
            pointer-events: none;
        }

        /* SCREENS (Make transparent) */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            /* No background color, let layer show through */
            z-index: 10;
        }

        /* LOBBY BACKGROUND CSS - OVERRIDDEN */
        /* Background handled by #menu-background-layer */

        .lobby-scene {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
            display: none;
            /* Hide CSS elements for 3D lobby */
        }

        /* NEW RELAXED LANDSCAPE CSS */
        .lobby-sun {
            position: absolute;
            bottom: 30%;
            /* Lower sun */
            left: 50%;
            width: 400px;
            /* Bigger sun */
            height: 400px;
            background: #FFFACD;
            /* LemonChiffon (Softer sun) */
            border-radius: 50%;
            transform: translate(-50%, 50%);
            box-shadow: 0 0 100px rgba(255, 250, 205, 0.8);
            z-index: 1;
        }

        .hill {
            position: absolute;
            border-radius: 50%;
            background: #90EE90;
            /* Lighter Green */
            box-shadow: inset -20px -20px 40px rgba(0, 0, 0, 0.05);
            /* Softer shadow */
        }

        .hill-back-1 {
            width: 150%;
            height: 60%;
            left: -25%;
            bottom: -20%;
            background: #7CCD7C;
            /* Lighter Back Green */
            z-index: 2;
        }

        .hill-back-2 {
            width: 120%;
            height: 50%;
            right: -10%;
            bottom: -15%;
            background: #66CDAA;
            /* Medium Aquamarine */
            z-index: 2;
        }

        .hill-front {
            width: 140%;
            height: 50%;
            left: -20%;
            bottom: -25%;
            background: #98FB98;
            /* PaleGreen (Front) */
            z-index: 3;
        }

        /* PATH */
        .path {
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 200px;
            height: 50%;
            background: #DEB887;
            /* Burlywood */
            transform: translateX(-50%) perspective(500px) rotateX(60deg);
            clip-path: polygon(20% 0, 80% 0, 100% 100%, 0% 100%);
            z-index: 3;
            opacity: 0.8;
            border-radius: 20px 20px 0 0;
        }

        /* RECENT ADDITIONS: CONTROLS SCREEN */
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 80px;
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 20px;
            max-width: 900px;
            /* Increased to allow more horizontal space */
        }

        .sens-section {
            display: flex;
            gap: 40px;
            margin-bottom: 20px;
            max-width: 900px;
            width: 100%;
        }

        .sens-panel {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px 30px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .sens-panel h3 {
            margin: 0 0 15px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 10px;
            font-size: 1rem;
        }

        .sens-row {
            display: flex;
            align-items: center;
            gap: 14px;
            margin: 12px 0;
            color: #eee;
            font-size: 1rem;
        }

        .sens-row label {
            width: 60px;
            flex-shrink: 0;
        }

        .sens-row input[type=range] {
            flex: 1;
            accent-color: #ffd700;
            cursor: pointer;
        }

        .sens-row input[type=range].gp-hover {
            outline: 2px solid #ffd700;
            border-radius: 4px;
        }

        .sens-val {
            width: 32px;
            text-align: right;
            font-weight: bold;
            color: #ffd700;
            font-size: 0.95rem;
        }

        .controls-column h3 {
            color: #ffd700;
            margin-top: 0;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            font-size: 1.1rem;
            color: #eee;
            gap: 40px;
            /* Force minimum horizontal separation */
        }

        .control-key {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
            color: #fff;
        }

        #controls-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem;
            padding: 0;
            line-height: 0;
            z-index: 200;
        }

        /* WEAPONS MENU */
        .weapons-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 16px;
            max-width: 1200px;
            width: 90%;
            padding: 0 20px;
        }

        .weapon-card {
            background: rgba(255, 255, 255, 0.07);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 16px;
            padding: 18px 16px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .weapon-card-title {
            margin: 0 0 8px 0;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 8px;
        }

        .wstat-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.78rem;
            color: #ccc;
        }

        .wstat-row > span:first-child {
            width: 58px;
            flex-shrink: 0;
            font-size: 0.72rem;
            text-transform: uppercase;
            color: rgba(255,255,255,0.6);
        }

        .wstat-bar-wrap {
            flex: 1;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.15);
        }

        .wstat-bar {
            height: 100%;
            border-radius: 3px;
            transition: width 0.4s ease;
        }

        .wstat-val {
            width: 50px;
            text-align: right;
            font-size: 0.72rem;
            font-weight: bold;
            color: rgba(255,255,255,0.8);
            flex-shrink: 0;
        }

        #weapons-menu-btn {
            position: absolute;
            top: 100px;
            left: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem;
            padding: 0;
            line-height: 0;
            z-index: 200;
        }

        .btn-back {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            z-index: 1000;
        }

        .btn-back::before {
            content: '';
            width: 30px;
            height: 30px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M19 12H5M12 19l-7-7 7-7'/%3E%3C/svg%3E");
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        /* ROUND TREES (Replacing Pines) */
        .round-tree {
            position: absolute;
            z-index: 4;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .tree-trunk {
            width: 20px;
            height: 60px;
            background: #8B4513;
            /* SaddleBrown */
            border-radius: 5px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
        }

        .tree-foliage {
            width: 100px;
            height: 100px;
            background: #32CD32;
            /* LimeGreen */
            border-radius: 50%;
            margin-bottom: -20px;
            /* Overlap trunk */
            box-shadow: inset -10px -10px 20px rgba(0, 0, 0, 0.1), 5px 5px 10px rgba(255, 255, 255, 0.2);
            /* Lighter highlights */
            position: relative;
        }

        /* Multiple foliage blobs */
        .tree-foliage::before {
            content: '';
            position: absolute;
            top: -20px;
            left: -20px;
            width: 80px;
            height: 80px;
            background: #4CC417;
            /* Apple Green */
            border-radius: 50%;
            z-index: -1;
        }

        .tree-foliage::after {
            content: '';
            position: absolute;
            top: -10px;
            right: -20px;
            width: 80px;
            height: 80px;
            background: #52D017;
            /* YellowGreen */
            border-radius: 50%;
            z-index: -1;
        }

        /* Tree Positions */
        .t1 {
            left: 10%;
            bottom: 25%;
            transform: scale(1.2);
        }

        .t2 {
            left: 85%;
            bottom: 20%;
            transform: scale(1.3);
        }

        .t3 {
            left: 5%;
            bottom: 15%;
            transform: scale(1.5);
            z-index: 5;
        }

        .t4 {
            left: 75%;
            bottom: 30%;
            transform: scale(0.8);
            z-index: 2;
        }

        .t5 {
            left: 25%;
            bottom: 32%;
            transform: scale(0.7);
            z-index: 2;
        }

        /* CLOUDS */
        .cloud {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.05);
            animation: floatCloud 60s linear infinite;
        }

        .cloud::after,
        .cloud::before {
            content: '';
            position: absolute;
            background: inherit;
            border-radius: 50%;
        }

        .c1 {
            top: 10%;
            left: 10%;
            width: 60px;
            height: 40px;
            animation-duration: 80s;
            opacity: 0.9;
        }

        .c1::after {
            width: 50px;
            height: 50px;
            top: -25px;
            left: 20px;
        }

        .c1::before {
            width: 40px;
            height: 40px;
            top: -15px;
            right: 20px;
        }

        .c2 {
            top: 15%;
            right: 20%;
            width: 100px;
            height: 35px;
            animation-duration: 60s;
            opacity: 0.8;
        }

        .c2::after {
            width: 40px;
            height: 40px;
            top: -20px;
            left: 15px;
        }

        @keyframes floatCloud {
            from { transform: translateX(-100px); }
            to { transform: translateX(100vw); }
        }

        /* ══════════════════════════════════════════════
           BO2 TACTICAL LOBBY — BLACK OPS II AUTHENTIC
        ══════════════════════════════════════════════ */

        /* Scanline vignette overlay — more pronounced like BO2 */
        #lobby-vignette {
            position: fixed; inset: 0; pointer-events: none; z-index: 5;
            background: radial-gradient(ellipse at center, transparent 35%, rgba(0,0,0,0.88) 100%);
        }
        #lobby-scanlines {
            position: fixed; inset: 0; pointer-events: none; z-index: 6;
            background: repeating-linear-gradient(
                to bottom,
                transparent 0px, transparent 2px,
                rgba(0,0,0,0.10) 2px, rgba(0,0,0,0.10) 3px
            );
            opacity: 0.8;
        }
        /* BO2-style background grid lines */
        #lobby-scanlines::after {
            content: '';
            position: absolute; inset: 0;
            background: repeating-linear-gradient(
                90deg,
                transparent 0px, transparent 79px,
                rgba(255,128,0,0.03) 79px, rgba(255,128,0,0.03) 80px
            );
        }

        /* Main tactical wrapper */
        .lobby-tactical {
            position: absolute; inset: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 5vw;
            font-family: 'Rajdhani', 'Arial', sans-serif;
            pointer-events: auto;
        }

        /* BO2-style horizontal accent lines */
        .lobby-tactical::before {
            content: '';
            position: absolute;
            top: 90px; left: 0; right: 0;
            height: 1px;
            background: linear-gradient(to right, transparent 0%, rgba(255,128,0,0.35) 20%, rgba(255,128,0,0.35) 80%, transparent 100%);
            pointer-events: none;
            z-index: 0;
        }
        .lobby-tactical::after {
            content: '';
            position: absolute;
            bottom: 40px; left: 0; right: 0;
            height: 1px;
            background: linear-gradient(to right, transparent 0%, rgba(255,255,255,0.08) 30%, rgba(255,255,255,0.08) 70%, transparent 100%);
            pointer-events: none;
            z-index: 0;
        }

        /* Title — BO2 style with logo treatment */
        .tac-title {
            position: absolute;
            top: 22px;
            left: 5vw;
            line-height: 1;
        }
        .tac-title-cod {
            display: block;
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(0.45rem, 1vw, 0.7rem);
            font-weight: 700;
            letter-spacing: 8px;
            color: rgba(255,255,255,0.45);
            text-transform: uppercase;
            margin-bottom: 2px;
        }
        .tac-title-main {
            display: block;
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1.4rem, 3.5vw, 2.8rem);
            font-weight: 900;
            color: #fff;
            letter-spacing: 2px;
            text-transform: uppercase;
            text-shadow: 0 0 40px rgba(255,255,255,0.2), 2px 2px 0px rgba(0,0,0,0.8);
            line-height: 0.9;
        }
        .tac-title-main em {
            font-style: normal;
            color: #ff8000;
            text-shadow: 0 0 20px rgba(255,128,0,0.7);
        }
        .tac-title-sub {
            display: block;
            font-family: 'Rajdhani', sans-serif;
            font-size: clamp(0.5rem, 1.1vw, 0.75rem);
            font-weight: 600;
            letter-spacing: 6px;
            color: rgba(255,128,0,0.8);
            text-transform: uppercase;
            margin-top: 5px;
        }

        /* Left tactical menu — BO2 authentic look */
        .tac-menu {
            display: flex;
            flex-direction: column;
            gap: 2px;
            margin-top: 100px;
            pointer-events: auto;
            z-index: 20;
            position: relative;
        }

        .tac-item {
            position: relative;
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 12px 50px 12px 18px;
            background: rgba(0,0,0,0.65);
            color: rgba(255,255,255,0.65);
            font-family: 'Rajdhani', sans-serif;
            font-size: clamp(0.95rem, 1.8vw, 1.3rem);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 3px;
            clip-path: polygon(0 0, 100% 0, 95% 100%, 0% 100%);
            cursor: pointer;
            border: none;
            border-left: 3px solid transparent;
            outline: none;
            transition: background 0.12s ease, color 0.12s ease, border-color 0.12s ease, transform 0.12s ease;
            min-width: 240px;
            user-select: none;
            z-index: 10;
            pointer-events: auto;
        }
        /* BO2-style hover: slide slightly + orange border + brighter text */
        .tac-item:hover, .tac-item.gp-hover {
            background: rgba(255,128,0,0.12);
            color: #fff;
            border-left-color: #ff8000;
            transform: translateX(6px);
        }
        .tac-item.active {
            background: rgba(255,128,0,0.18);
            color: #fff;
            border-left-color: #ff8000;
        }

        .tac-item-num {
            font-size: 0.6em;
            color: rgba(255,128,0,0.55);
            font-family: 'Orbitron', sans-serif;
            min-width: 18px;
        }

        .tac-divider {
            width: 240px;
            height: 1px;
            background: linear-gradient(to right, rgba(255,128,0,0.3), transparent);
            margin: 6px 0;
        }

        /* Right side — player cards */
        .tac-players {
            display: flex;
            flex-direction: column;
            gap: 16px;
            z-index: 20;
            margin-top: 80px;
        }

        .tac-player-card {
            position: relative;
            width: clamp(240px, 25vw, 340px);
            padding: 18px 22px;
            background: rgba(0,0,0,0.75);
            border: 1px solid rgba(255,255,255,0.08);
            clip-path: polygon(0 0, 100% 0, 96% 100%, 0 100%);
            transition: box-shadow 0.2s, transform 0.2s;
            overflow: hidden;
        }
        .tac-player-card::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 1px;
            background: linear-gradient(to right, #ff8000, transparent);
        }
        .tac-player-card.p1-card::after { background: linear-gradient(to right, #00aaff, transparent); }
        .tac-player-card.p1-card { border-top-color: rgba(0,170,255,0.3); }

        .tac-player-card.pulse {
            animation: cardPulse 0.4s ease-out;
        }
        @keyframes cardPulse {
            0%   { transform: scale(1.02); box-shadow: 0 0 20px rgba(255,128,0,0.4); }
            100% { transform: scale(1); box-shadow: none; }
        }
        .tac-player-card.p1-card.pulse {
            animation: cardPulseBlue 0.4s ease-out;
        }
        @keyframes cardPulseBlue {
            0%   { transform: scale(1.02); box-shadow: 0 0 20px rgba(0,170,255,0.5); }
            100% { transform: scale(1); box-shadow: none; }
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }
        .card-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.75rem;
            font-weight: 700;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: #ff8000;
        }
        .p1-card .card-name { color: #00aaff; }

        .card-status {
            font-size: 0.7rem;
            font-weight: 700;
            letter-spacing: 2px;
            padding: 3px 8px;
            border: 1px solid;
            text-transform: uppercase;
        }
        .status-ready { color: #00ff88; border-color: rgba(0,255,136,0.4); background: rgba(0,255,136,0.08); }
        .status-waiting { color: #ff8000; border-color: rgba(255,128,0,0.4); background: rgba(255,128,0,0.08); }
        .status-connected { color: #00aaff; border-color: rgba(0,170,255,0.4); background: rgba(0,170,255,0.08); }

        .card-tag {
            font-size: 1.1rem;
            font-weight: 700;
            letter-spacing: 2px;
            color: #fff;
            margin-bottom: 8px;
        }
        .card-info {
            font-size: 0.78rem;
            color: rgba(255,255,255,0.4);
            letter-spacing: 1px;
            display: flex;
            gap: 16px;
        }
        .card-info span { color: rgba(255,255,255,0.65); }

        /* Status bar at bottom */
        .card-bar {
            margin-top: 12px;
            height: 2px;
            background: rgba(255,255,255,0.08);
            overflow: hidden;
        }
        .card-bar-fill {
            height: 100%;
            background: linear-gradient(to right, #ff8000, #ffcc00);
            width: 100%;
            animation: barPulse 2s ease-in-out infinite;
        }
        .p1-card .card-bar-fill { background: linear-gradient(to right, #00aaff, #0066ff); }
        @keyframes barPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Match info bar at top */
        .tac-match-info {
            position: absolute;
            top: 32px;
            right: 5vw;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            letter-spacing: 3px;
            color: rgba(255,255,255,0.3);
            text-transform: uppercase;
            text-align: right;
            z-index: 20;
        }
        .tac-match-info .mode-label {
            font-size: 0.85rem;
            color: rgba(255,128,0,0.7);
            display: block;
            margin-bottom: 4px;
        }

        /* Bottom bar — status strip */
        .tac-bottom-bar {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            height: 36px;
            background: rgba(0,0,0,0.85);
            border-top: 1px solid rgba(255,128,0,0.2);
            display: flex;
            align-items: center;
            padding: 0 5vw;
            gap: 32px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.72rem;
            color: rgba(255,255,255,0.35);
            letter-spacing: 2px;
            text-transform: uppercase;
            z-index: 20;
            pointer-events: none;
        }
        .tac-bottom-bar .indicator { display: flex; align-items: center; gap: 8px; }
        .tac-bottom-bar .dot {
            width: 6px; height: 6px; border-radius: 50%;
            background: #00ff88;
            box-shadow: 0 0 6px #00ff88;
            animation: dotBlink 2.5s ease-in-out infinite;
        }
        .tac-bottom-bar .dot.orange { background: #ff8000; box-shadow: 0 0 6px #ff8000; }
        @keyframes dotBlink {
            0%,100% { opacity: 1; } 50% { opacity: 0.2; }
        }

        /* Lobby intro animation */
        @keyframes slideInLeft {
            from { opacity: 0; transform: translateX(-40px); }
            to   { opacity: 1; transform: translateX(0); }
        }
        .tac-menu .tac-item { animation: slideInLeft 0.4s ease both; }
        .tac-menu .tac-item:nth-child(1) { animation-delay: 0.05s; }
        .tac-menu .tac-item:nth-child(2) { animation-delay: 0.10s; }
        .tac-menu .tac-item:nth-child(3) { animation-delay: 0.15s; }
        .tac-menu .tac-item:nth-child(4) { animation-delay: 0.20s; }
        .tac-menu .tac-item:nth-child(5) { animation-delay: 0.25s; }
        .tac-menu .tac-item:nth-child(6) { animation-delay: 0.30s; }
        .tac-menu .tac-item:nth-child(7) { animation-delay: 0.35s; }

        @keyframes slideInRight {
            from { opacity: 0; transform: translateX(40px); }
            to   { opacity: 1; transform: translateX(0); }
        }
        .tac-players .tac-player-card { animation: slideInRight 0.4s ease both; }
        .tac-players .tac-player-card:nth-child(1) { animation-delay: 0.15s; }
        .tac-players .tac-player-card:nth-child(2) { animation-delay: 0.25s; }

        .tac-title { animation: slideInLeft 0.5s ease 0s both; }

        /* ══════════════════════════════════════════════
           COD-STYLE PLAYER LIST
        ══════════════════════════════════════════════ */
        .cod-player-list {
            display: flex;
            flex-direction: column;
            gap: 0;
            z-index: 20;
            margin-top: 70px;
            min-width: clamp(240px, 26vw, 340px);
        }

        .cod-list-header {
            display: flex;
            flex-direction: column;
            padding: 8px 12px 10px;
            border-bottom: 1px solid rgba(255,128,0,0.35);
            margin-bottom: 4px;
            background: rgba(0,0,0,0.55);
        }

        .cod-list-title {
            font-family: 'Rajdhani', sans-serif;
            font-size: clamp(0.62rem, 1.1vw, 0.78rem);
            font-weight: 700;
            letter-spacing: 3px;
            color: rgba(255,255,255,0.85);
            text-transform: uppercase;
        }

        .cod-list-count {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(0.52rem, 0.9vw, 0.65rem);
            letter-spacing: 2px;
            color: rgba(255,128,0,0.75);
            margin-top: 3px;
            text-transform: uppercase;
        }

        .cod-player-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px 10px;
            background: rgba(0,0,0,0.45);
            border-bottom: 1px solid rgba(255,255,255,0.04);
            transition: background 0.1s;
            position: relative;
        }

        .cod-player-row:nth-child(even) {
            background: rgba(0,0,0,0.35);
        }

        .cod-host {
            background: rgba(255,128,0,0.08) !important;
            border-left: 2px solid #ff8000;
        }

        .cod-slot-num {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.6rem;
            color: rgba(255,255,255,0.3);
            width: 16px;
            text-align: right;
            flex-shrink: 0;
        }

        .cod-player-icon {
            font-size: 0.7rem;
            color: #ff8000;
            width: 14px;
            text-align: center;
            flex-shrink: 0;
        }

        .cod-icon-search {
            color: rgba(255,255,255,0.18);
            animation: searchPulse 2.5s ease-in-out infinite;
        }

        @keyframes searchPulse {
            0%, 100% { opacity: 0.18; }
            50%       { opacity: 0.5; }
        }

        .cod-player-name {
            font-family: 'Rajdhani', sans-serif;
            font-size: clamp(0.72rem, 1.3vw, 0.88rem);
            font-weight: 600;
            color: #fff;
            letter-spacing: 1px;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .cod-searching-text {
            color: rgba(255,255,255,0.32);
            font-style: italic;
            font-size: clamp(0.62rem, 1.1vw, 0.76rem);
        }

        .cod-player-nat {
            font-size: 0.55rem;
            color: #00ff88;
            flex-shrink: 0;
        }

        .cod-player-signal {
            font-size: 0.55rem;
            color: rgba(255,255,255,0.18);
            flex-shrink: 0;
        }

        .cod-dots::after {
            content: '';
            animation: dotsAnim 1.6s steps(4, end) infinite;
        }

        @keyframes dotsAnim {
            0%  { content: ''; }
            25% { content: '.'; }
            50% { content: '..'; }
            75% { content: '...'; }
        }

        /* Stagger searching pulse per row */
        .cod-player-row:nth-child(3)  .cod-icon-search { animation-delay: 0.2s; }
        .cod-player-row:nth-child(4)  .cod-icon-search { animation-delay: 0.4s; }
        .cod-player-row:nth-child(5)  .cod-icon-search { animation-delay: 0.6s; }
        .cod-player-row:nth-child(6)  .cod-icon-search { animation-delay: 0.8s; }
        .cod-player-row:nth-child(7)  .cod-icon-search { animation-delay: 1.0s; }
        .cod-player-row:nth-child(8)  .cod-icon-search { animation-delay: 1.2s; }
        .cod-player-row:nth-child(9)  .cod-icon-search { animation-delay: 1.4s; }
        .cod-player-row:nth-child(10) .cod-icon-search { animation-delay: 1.6s; }
        .cod-player-row:nth-child(11) .cod-icon-search { animation-delay: 0.3s; }
        .cod-player-row:nth-child(12) .cod-icon-search { animation-delay: 0.9s; }
        .cod-player-row:nth-child(13) .cod-icon-search { animation-delay: 0.7s; }

        /* ── Enhanced vignette for darker, more dramatic lobby ── */
        #lobby-vignette {
            background: radial-gradient(ellipse at center, transparent 60%, rgba(0,0,0,0.55) 100%) !important;
        }

        /* Camera fly-in overlay */
        #cam-flash {
            position: fixed; inset: 0; z-index: 9000;
            background: #fff; pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }

        /* ══════════════════════════════════════════════
           MATCH SETUP — BO2 BRIEFING ROOM
        ══════════════════════════════════════════════ */
        #match-setup {
            position: absolute; inset: 0;
            background: rgba(5,8,13,0.82);
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: flex-start;
            z-index: 200;
            pointer-events: auto;
            font-family: 'Rajdhani', 'Arial', sans-serif;
            overflow: hidden;
        }
        /* Scanlines on briefing room */
        #match-setup::before {
            content: '';
            position: absolute; inset: 0; z-index: 0; pointer-events: none;
            background: repeating-linear-gradient(
                to bottom,
                transparent 0px, transparent 3px,
                rgba(0,0,0,0.06) 3px, rgba(0,0,0,0.06) 4px
            );
        }
        /* Edge vignette */
        #match-setup::after {
            content: '';
            position: absolute; inset: 0; z-index: 0; pointer-events: none;
            background: radial-gradient(ellipse at 50% 50%, transparent 50%, rgba(0,0,0,0.5) 100%);
        }

        /* Glitch entrance */
        @keyframes msGlitch {
            0%   { opacity: 0; clip-path: inset(40% 0 40% 0); transform: scaleX(1.04); }
            15%  { opacity: 1; clip-path: inset(0% 0 0% 0);   transform: scaleX(1); }
            17%  { clip-path: inset(55% 0 10% 0); transform: translateX(-3px); }
            19%  { clip-path: inset(0% 0 0% 0);  transform: translateX(0); }
            100% { opacity: 1; clip-path: inset(0% 0 0% 0); transform: none; }
        }
        #match-setup.entering { animation: msGlitch 0.32s ease both; }

        /* ── Header bar ── */
        .ms-header {
            position: relative; z-index: 2;
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 3vw;
            height: 52px;
            background: rgba(0,0,0,0.7);
            border-bottom: 1px solid rgba(255,128,0,0.25);
        }
        .ms-header-left {
            display: flex; align-items: center; gap: 16px;
        }
        .ms-back-btn {
            display: flex; align-items: center; gap: 8px;
            background: none; border: 1px solid rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.5); font-family: 'Rajdhani', sans-serif;
            font-size: 0.78rem; font-weight: 700; letter-spacing: 2px;
            text-transform: uppercase; padding: 6px 14px;
            cursor: pointer; transition: all 0.15s;
            clip-path: polygon(0 0, 100% 0, 94% 100%, 0 100%);
        }
        .ms-back-btn:hover, .ms-back-btn.gp-hover { color: #ff8000; border-color: rgba(255,128,0,0.5); background: rgba(255,128,0,0.06); }
        .ms-title-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem; font-weight: 900;
            letter-spacing: 5px; color: #fff;
            text-transform: uppercase;
        }
        .ms-title-label span {
            color: #ff8000; font-size: 0.7rem; margin-left: 10px;
            letter-spacing: 3px; font-family: 'Rajdhani', sans-serif; font-weight: 600;
        }
        .ms-mode-badge {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem; font-weight: 700; letter-spacing: 3px;
            color: #ff8000; padding: 4px 12px;
            border: 1px solid rgba(255,128,0,0.35);
            background: rgba(255,128,0,0.08);
            text-transform: uppercase;
        }

        /* ── Main grid ── */
        .ms-grid {
            position: relative; z-index: 2;
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 280px 1fr;
            gap: 0;
            padding: 24px 2vw 0;
            min-height: 0;
        }

        /* ── Player slot panels ── */
        .ms-player {
            display: flex; flex-direction: column;
            padding: 0 20px;
            gap: 12px;
        }

        .ms-player-header {
            display: flex; align-items: center; justify-content: space-between;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
            margin-bottom: 4px;
        }
        .ms-player-id {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem; font-weight: 900; letter-spacing: 4px;
        }
        .ms-p1 .ms-player-id { color: #00aaff; text-shadow: 0 0 12px rgba(0,170,255,0.4); }
        .ms-p2 .ms-player-id { color: #ff8000; text-shadow: 0 0 12px rgba(255,128,0,0.4); }
        .ms-p2.ai .ms-player-id { color: rgba(255,255,255,0.35); text-shadow: none; }

        .ms-player-status {
            font-size: 0.68rem; font-weight: 700; letter-spacing: 2px;
            padding: 3px 8px; border: 1px solid; text-transform: uppercase;
        }
        .ms-status-active { color: #00ff88; border-color: rgba(0,255,136,0.35); background: rgba(0,255,136,0.06); }
        .ms-status-ai     { color: rgba(255,255,255,0.3); border-color: rgba(255,255,255,0.1); background: transparent; }

        .ms-selected-weapon {
            font-size: 1.6rem; font-weight: 700; letter-spacing: 3px;
            color: #fff; text-transform: uppercase;
            line-height: 1;
            min-height: 2.2rem;
        }
        .ms-p2.ai .ms-selected-weapon { color: rgba(255,255,255,0.25); }

        .ms-weapon-subtitle {
            font-size: 0.72rem; letter-spacing: 2px;
            color: rgba(255,255,255,0.3);
            text-transform: uppercase;
            margin-top: -6px;
        }
        .ms-p2.ai .ms-weapon-subtitle { color: rgba(255,255,255,0.15); }

        /* ── Weapon grid buttons ── */
        .ms-weapon-grid {
            display: flex; flex-direction: column; gap: 4px;
            margin-top: 8px;
        }
        .ms-weapon-btn {
            position: relative;
            display: flex; align-items: center; gap: 12px;
            padding: 10px 16px 10px 12px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.07);
            color: rgba(255,255,255,0.55);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem; font-weight: 700;
            letter-spacing: 2px; text-transform: uppercase;
            cursor: pointer;
            clip-path: polygon(0 0, 100% 0, 96% 100%, 0 100%);
            transition: background 0.12s, color 0.12s, border-color 0.12s;
            overflow: hidden;
        }
        .ms-weapon-btn:hover, .ms-weapon-btn.gp-hover {
            background: rgba(255,128,0,0.08);
            border-color: rgba(255,128,0,0.3);
            color: #ff8000;
        }
        .ms-weapon-btn.selected {
            background: rgba(255,128,0,0.12);
            border-color: #ff8000;
            color: #ff8000;
        }
        .ms-p1 .ms-weapon-btn:hover,
        .ms-p1 .ms-weapon-btn.gp-hover,
        .ms-p1 .ms-weapon-btn.selected {
            background: rgba(0,170,255,0.1);
            border-color: #00aaff;
            color: #00aaff;
        }
        .ms-weapon-btn .wb-dot {
            width: 6px; height: 6px; border-radius: 50%;
            flex-shrink: 0; opacity: 0.5;
            transition: opacity 0.12s, box-shadow 0.12s;
        }
        .ms-weapon-btn.selected .wb-dot { opacity: 1; box-shadow: 0 0 8px currentColor; }
        .ms-weapon-btn .wb-label { flex: 1; }
        .ms-weapon-btn .wb-ammo {
            font-size: 0.72rem; color: rgba(255,255,255,0.25);
            letter-spacing: 1px;
        }
        .ms-weapon-btn.selected .wb-ammo { color: rgba(255,255,255,0.5); }

        /* Disabled state — P2 AI slot */
        .ms-p2.ai .ms-weapon-grid { opacity: 0.25; pointer-events: none; }

        /* ── Center column ── */
        .ms-center {
            display: flex; flex-direction: column; gap: 16px;
            padding: 0 16px;
            border-left: 1px solid rgba(255,255,255,0.05);
            border-right: 1px solid rgba(255,255,255,0.05);
        }

        .ms-section-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.58rem; font-weight: 700; letter-spacing: 4px;
            color: rgba(255,128,0,0.6); text-transform: uppercase;
            border-bottom: 1px solid rgba(255,128,0,0.15);
            padding-bottom: 6px; margin-bottom: 2px;
        }

        .ms-map-thumb {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            padding: 20px 16px;
            text-align: center;
            clip-path: polygon(0 0, 100% 0, 100% 88%, 94% 100%, 0 100%);
        }
        .ms-map-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem; font-weight: 900; letter-spacing: 4px;
            color: #fff; text-transform: uppercase; margin-bottom: 4px;
        }
        .ms-map-sub {
            font-size: 0.68rem; color: rgba(255,255,255,0.3); letter-spacing: 2px;
        }
        /* Fake terrain lines */
        .ms-map-visual {
            margin: 10px 0 6px;
            height: 40px; position: relative; overflow: hidden;
        }
        .ms-map-visual svg { width: 100%; height: 100%; }

        /* ── Map Selector — 4 cards stacked ── */
        .ms-map-selector {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 8px;
        }
        .map-select-btn {
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.07);
            padding: 7px 12px 4px;
            text-align: left;
            cursor: pointer;
            transition: border-color 0.18s, background 0.18s;
            font-family: inherit;
            color: #fff;
            width: 100%;
            clip-path: polygon(0 0, 100% 0, 100% 88%, 97% 100%, 0 100%);
        }
        .map-select-btn:hover, .map-select-btn.gp-hover {
            background: rgba(255,255,255,0.06);
        }
        /* Per-map accent colors on selected */
        .map-select-btn.selected[data-map="valley"] {
            background: rgba(80,200,80,0.07);
            border-color: rgba(80,200,80,0.55);
            box-shadow: 0 0 10px rgba(80,200,80,0.12);
        }
        .map-select-btn.selected[data-map="raid"] {
            border-color: rgba(200,160,90,0.8);
            background: rgba(200,160,90,0.08);
        }
        
        
        
        .map-select-btn .ms-map-name  { margin-bottom: 1px; }
        .map-select-btn .ms-map-sub   { font-size: 0.6rem; color: rgba(255,255,255,0.25); letter-spacing: 1.5px; }
        .map-select-btn .ms-map-visual { margin: 3px 0 0; height: 32px; }

        /* Difficulty selector */
        .ms-diff-grid {
            display: flex; flex-direction: column; gap: 4px;
        }
        .ms-diff-btn {
            display: flex; align-items: center; gap: 10px;
            padding: 10px 14px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.07);
            color: rgba(255,255,255,0.45);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.88rem; font-weight: 700;
            letter-spacing: 2px; text-transform: uppercase;
            cursor: pointer;
            clip-path: polygon(0 0, 100% 0, 96% 100%, 0 100%);
            transition: all 0.12s;
        }
        .ms-diff-btn:hover, .ms-diff-btn.gp-hover { background: rgba(255,255,255,0.07); color: #fff; border-color: rgba(255,255,255,0.2); }
        .ms-diff-btn.selected { background: rgba(255,128,0,0.12); border-color: #ff8000; color: #ff8000; }
        .ms-diff-btn .db-pips { display: flex; gap: 3px; margin-left: auto; }
        .ms-diff-btn .db-pip {
            width: 5px; height: 10px;
            background: rgba(255,255,255,0.15);
            transition: background 0.12s;
        }
        .ms-diff-btn.selected .db-pip.on { background: #ff8000; }

        /* Bot count badge */
        .ms-diff-btn .db-count {
            font-size: 0.65rem; color: rgba(255,255,255,0.3); margin-left: 4px;
        }
        .ms-diff-btn.selected .db-count { color: rgba(255,128,0,0.7); }

        /* Center stats panel */
        .ms-stat-row {
            display: flex; justify-content: space-between; align-items: center;
            font-size: 0.75rem; padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.04);
            color: rgba(255,255,255,0.35);
            letter-spacing: 1px;
        }
        .ms-stat-row span:last-child { color: rgba(255,255,255,0.7); font-weight: 700; }

        /* ── Bottom action bar ── */
        .ms-footer {
            position: relative; z-index: 2;
            height: 70px;
            background: rgba(0,0,0,0.75);
            border-top: 1px solid rgba(255,128,0,0.2);
            display: flex; align-items: center; justify-content: center;
            gap: 40px;
            padding: 0 3vw;
        }
        .ms-footer-info {
            font-size: 0.7rem; letter-spacing: 2px;
            color: rgba(255,255,255,0.25); text-transform: uppercase;
        }
        .ms-footer-info span { color: rgba(255,255,255,0.55); }

        /* DEPLOY button */
        .ms-deploy-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.05rem; font-weight: 900; letter-spacing: 5px;
            text-transform: uppercase;
            color: #000;
            background: #ff8000;
            border: none; outline: none; cursor: pointer;
            padding: 14px 60px;
            clip-path: polygon(0 0, 100% 0, 94% 100%, 6% 100%);
            transition: background 0.15s, transform 0.1s, box-shadow 0.15s;
            box-shadow: 0 0 20px rgba(255,128,0,0.3), 0 0 60px rgba(255,128,0,0.1);
            position: relative;
        }
        .ms-deploy-btn:hover:not(:disabled), .ms-deploy-btn.gp-hover:not(:disabled) {
            background: #ffa040;
            box-shadow: 0 0 30px rgba(255,128,0,0.6), 0 0 80px rgba(255,128,0,0.2);
            transform: scaleX(1.02);
        }
        .ms-deploy-btn:active:not(:disabled) { transform: scale(0.97); }
        .ms-deploy-btn:disabled {
            background: rgba(255,255,255,0.08);
            color: rgba(255,255,255,0.2);
            box-shadow: none; cursor: not-allowed;
        }
        /* Deploy pulse when ready */
        @keyframes deployPulse {
            0%,100% { box-shadow: 0 0 20px rgba(255,128,0,0.3), 0 0 60px rgba(255,128,0,0.1); }
            50%      { box-shadow: 0 0 35px rgba(255,128,0,0.7), 0 0 90px rgba(255,128,0,0.25); }
        }
        .ms-deploy-btn.ready { animation: deployPulse 1.8s ease-in-out infinite; }

        /* ── Corner accent decorations ── */
        .ms-corner {
            position: absolute; z-index: 1; pointer-events: none;
        }
        .ms-corner-tl { top: 52px; left: 0; border-top: 2px solid rgba(255,128,0,0.25); border-left: 2px solid rgba(255,128,0,0.25); width: 40px; height: 40px; }
        .ms-corner-tr { top: 52px; right: 0; border-top: 2px solid rgba(255,128,0,0.25); border-right: 2px solid rgba(255,128,0,0.25); width: 40px; height: 40px; }
        .ms-corner-bl { bottom: 70px; left: 0; border-bottom: 2px solid rgba(0,170,255,0.2); border-left: 2px solid rgba(0,170,255,0.2); width: 40px; height: 40px; }
        .ms-corner-br { bottom: 70px; right: 0; border-bottom: 2px solid rgba(0,170,255,0.2); border-right: 2px solid rgba(0,170,255,0.2); width: 40px; height: 40px; }

        /* Divider line in center column */
        .ms-divider {
            height: 1px; background: linear-gradient(to right, transparent, rgba(255,128,0,0.2), transparent);
            margin: 2px 0;
        }

    </style>
    <script type="importmap"> {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }

        </script>
</head>

<body>
    <!-- CHANGED: Patch 6A — Overlay obligatorio antes de entrar al juego.
         Garantiza unlock del AudioContext en TODOS los navegadores (Chrome, Safari, Firefox),
         ya que requiere un gesto de usuario directo. Se oculta al hacer click/tecla. -->
    <div id="click-to-start" style="
        position: fixed; inset: 0;
        display: flex; flex-direction: column;
        align-items: center; justify-content: center;
        background: #000;
        z-index: 99999;
        font-family: var(--font-main, 'Orbitron', sans-serif);
    ">
        <!-- BO2-style scanlines on splash -->
        <div style="position:absolute;inset:0;background:repeating-linear-gradient(to bottom,transparent 0px,transparent 2px,rgba(0,0,0,0.25) 2px,rgba(0,0,0,0.25) 3px);pointer-events:none;z-index:1;"></div>
        <!-- BO2-style vignette -->
        <div style="position:absolute;inset:0;background:radial-gradient(ellipse at center,transparent 40%,rgba(0,0,0,0.9) 100%);pointer-events:none;z-index:2;"></div>
        <div style="position:relative;z-index:3;text-align:center;">
            <div style="color:rgba(255,255,255,0.35);font-size:clamp(0.5rem,1.5vw,0.65rem);letter-spacing:10px;margin-bottom:16px;font-family:'Orbitron',sans-serif;">
                COMBAT
            </div>
            <div style="color:#fff;font-size:clamp(2rem,8vw,5.5rem);font-weight:900;letter-spacing:4px;line-height:0.85;font-family:'Orbitron',sans-serif;text-shadow:0 0 60px rgba(255,128,0,0.3);">
                SOLO<span style="color:#ff8000;text-shadow:0 0 30px rgba(255,128,0,0.9);">SHOT</span>
            </div>
            <div style="width:100%;height:1px;background:linear-gradient(to right,transparent,rgba(255,128,0,0.6),transparent);margin:20px 0;"></div>
            <div style="color:rgba(255,255,255,0.5);font-size:clamp(0.6rem,1.8vw,0.75rem);letter-spacing:5px;animation:blink 1.4s ease-in-out infinite;">
                PRESS ANY KEY TO START
            </div>
        </div>
        <style>@keyframes blink{0%,100%{opacity:1}50%{opacity:0.25}}</style>
    </div>
    <div id="game-container"></div>
    <!-- BO2 Atmosphere overlays -->
    <div id="lobby-vignette"></div>
    <div id="lobby-scanlines"></div>
    <div id="cam-flash"></div>
    <div id="ui-layer">
        <!-- CURSOR VIRTUAL GAMEPAD -->
        <div id="gp-cursor" style="
            position: fixed;
            width: 24px;
            height: 24px;
            pointer-events: none;
            z-index: 999999;
            display: none;
            left: 0; top: 0;
        ">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                <polygon points="4,2 4,20 8,15 11,22 13.5,21 10.5,14 18,14" fill="white" stroke="black" stroke-width="1.5" stroke-linejoin="round"/>
            </svg>
        </div>
        <!-- KILLCAM OVERLAY -->
        <div id="killcam-overlay">
            <div id="killcam-bar-top"></div>
            <div id="killcam-bar-bottom"></div>
            <div id="killcam-vignette"></div>
            <div id="killcam-colorgrade"></div>
            <div id="killcam-impact-flash"></div>
            <div id="killcam-label">KILLCAM</div>
            <div id="killcam-slowmo-label">● SLOW MOTION</div>
            <div id="killcam-timer-bar">
                <div id="killcam-timer-fill"></div>
            </div>
        </div>

        <button id="ingame-menu-btn" class="hidden">MENU</button>
        <button id="ingame-controls-btn" class="btn-transparent hidden" tabindex="-1" style="
            position: absolute;
            top: 20px;
            left: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem;
            padding: 0;
            line-height: 0;
            z-index: 100000;
            pointer-events: auto;
        ">⚙</button>

        <!-- SHARED BACKGROUND LAYER -->
        <div id="menu-background-layer">
            <div class="lobby-scene">
                <div class="lobby-sun"></div>
                <!-- Hills -->
                <div class="hill hill-back-1"></div>
                <div class="hill hill-back-2"></div>
                <!-- Path -->
                <div class="path"></div>
                <!-- Front Hill -->
                <div class="hill hill-front"></div>

                <!-- Clouds -->
                <div class="cloud c1"></div>
                <div class="cloud c2"></div>

                <!-- Round Trees -->
                <div class="round-tree t1">
                    <div class="tree-foliage"></div>
                    <div class="tree-trunk"></div>
                </div>
                <div class="round-tree t2">
                    <div class="tree-foliage"></div>
                    <div class="tree-trunk"></div>
                </div>
                <div class="round-tree t3">
                    <div class="tree-foliage"></div>
                    <div class="tree-trunk"></div>
                </div>
                <div class="round-tree t4">
                    <div class="tree-foliage"></div>
                    <div class="tree-trunk"></div>
                </div>
                <div class="round-tree t5">
                    <div class="tree-foliage"></div>
                    <div class="tree-trunk"></div>
                </div>
            </div>
        </div>

        <!-- CAPA CONGELADA DE LA ÚLTIMA JUGADA -->
        <div id="last-play-frame" class="hidden"></div>

        <!-- LOBBY -->
        <div id="lobby" class="screen">
            <!-- BO2 tactical UI -->
            <div class="lobby-tactical">
                <!-- Top left title -->
                <div class="tac-title">
                    <span class="tac-title-main">SOLO<em>SHOT</em></span>
                    
                </div>



                <!-- Left: Tactical Menu -->
                <nav class="tac-menu">
                    <button class="tac-item" id="tac-play-solo" onclick="unlockAudio();lobbyHover();showMatchSetup('solo')">
                        <span class="tac-item-num">01</span> SOLO VS AI
                    </button>
                    <button class="tac-item" id="tac-pvp" onclick="unlockAudio();lobbyHover();showMatchSetup('pvp')">
                        <span class="tac-item-num">02</span> 1v1 SPLIT SCREEN
                    </button>
                    <div class="tac-divider"></div>
                    <button class="tac-item" onclick="unlockAudio();lobbyHover();document.getElementById('weapons-menu-btn').click()">
                        <span class="tac-item-num">03</span> LOADOUT
                    </button>
                    <button class="tac-item" onclick="unlockAudio();lobbyHover();document.getElementById('controls-btn').click()">
                        <span class="tac-item-num">04</span> SETTINGS
                    </button>
                </nav>

                <!-- Right: CoD-style Player List -->
                <div class="tac-players cod-player-list">
                    <div class="cod-list-header">
                        <span class="cod-list-title">MAIN / HOT ZONE</span>
                        <span class="cod-list-count">1 player (6 max.)</span>
                    </div>
                    <!-- Host player slot -->
                    <div class="cod-player-row cod-host" id="p1-lobby-card">
                        <span class="cod-slot-num">1</span>
                        <span class="cod-player-icon">▲</span>
                        <span class="cod-player-name">Player 1</span>
                        <span class="cod-player-nat">■</span>
                    </div>
                    <!-- Searching slots -->
                    <div class="cod-player-row cod-searching" id="p2-lobby-card">
                        <span class="cod-slot-num">2</span>
                        <span class="cod-player-icon cod-icon-search">◈</span>
                        <span class="cod-player-name cod-searching-text">Searching for player<span class="cod-dots"></span></span>
                        <span class="cod-player-signal">〜</span>
                    </div>
                    <div class="cod-player-row cod-searching">
                        <span class="cod-slot-num">3</span>
                        <span class="cod-player-icon cod-icon-search">◈</span>
                        <span class="cod-player-name cod-searching-text">Searching for player<span class="cod-dots"></span></span>
                        <span class="cod-player-signal">〜</span>
                    </div>
                    <div class="cod-player-row cod-searching">
                        <span class="cod-slot-num">4</span>
                        <span class="cod-player-icon cod-icon-search">◈</span>
                        <span class="cod-player-name cod-searching-text">Searching for player<span class="cod-dots"></span></span>
                        <span class="cod-player-signal">〜</span>
                    </div>
                    <div class="cod-player-row cod-searching">
                        <span class="cod-slot-num">5</span>
                        <span class="cod-player-icon cod-icon-search">◈</span>
                        <span class="cod-player-name cod-searching-text">Searching for player<span class="cod-dots"></span></span>
                        <span class="cod-player-signal">〜</span>
                    </div>
                    <div class="cod-player-row cod-searching">
                        <span class="cod-slot-num">6</span>
                        <span class="cod-player-icon cod-icon-search">◈</span>
                        <span class="cod-player-name cod-searching-text">Searching for player<span class="cod-dots"></span></span>
                        <span class="cod-player-signal">〜</span>
                    </div>
                </div>
            </div>



            <!-- Hidden original buttons for wiring -->
            <button id="solo-btn" style="display:none"></button>
            <button id="pvp-btn" style="display:none"></button>
            <button id="solo-btn-hidden" style="display:none" onclick="document.getElementById('solo-btn').click()"></button>
            <button id="pvp-btn-hidden" style="display:none" onclick="document.getElementById('pvp-btn').click()"></button>
            <button id="controls-btn" style="display:none"></button>
            <button id="weapons-menu-btn" style="display:none"></button>
        </div>

        <!-- ══════════════════════════════════════════
             MATCH SETUP — BRIEFING ROOM
        ══════════════════════════════════════════ -->
        <div id="match-setup" class="hidden">

            <!-- Corner accents -->
            <div class="ms-corner ms-corner-tl"></div>
            <div class="ms-corner ms-corner-tr"></div>
            <div class="ms-corner ms-corner-bl"></div>
            <div class="ms-corner ms-corner-br"></div>

            <!-- Header -->
            <div class="ms-header">
                <div class="ms-header-left">
                    <button class="ms-back-btn" id="ms-back-btn">◀ BACK</button>
                    <div class="ms-title-label">
                        MISSION SETUP
                        <span id="ms-mode-label">// SOLO</span>
                    </div>
                </div>
                <div class="ms-mode-badge" id="ms-mode-badge">SOLO VS AI</div>
            </div>

            <!-- Main 3-column grid -->
            <div class="ms-grid">

                <!-- LEFT — Player 1 -->
                <div class="ms-player ms-p1" id="ms-p1-slot">
                    <div class="ms-player-header">
                        <div class="ms-player-id">PLAYER 1</div>
                        <div class="ms-player-status ms-status-active">ACTIVE</div>
                    </div>
                    <div class="ms-selected-weapon" id="ms-p1-weapon-name">ASSAULT RIFLE</div>
                    <div class="ms-weapon-subtitle">SELECTED LOADOUT</div>
                    <div class="ms-weapon-grid" id="ms-p1-weapon-grid">
                        <!-- filled by JS -->
                    </div>
                </div>

                <!-- CENTER — Map & Settings -->
                <div class="ms-center">
                    <div class="ms-section-label">THEATER OF OPERATIONS</div>
                    <!-- Map selector — 3 playable maps -->
                    <div class="ms-map-selector">

                        <button class="map-select-btn selected" data-map="valley"
                                onclick="previewMap('valley')">
                            <div class="ms-map-name">THE VALLEY</div>
                            <div class="ms-map-sub">OPEN TERRAIN — LONG RANGE</div>
                            <div class="ms-map-visual">
                                <svg viewBox="0 0 240 42" preserveAspectRatio="none">
                                    <polyline points="0,36 20,28 45,32 70,18 90,22 115,8 140,14 165,24 190,12 220,20 240,16"
                                        fill="none" stroke="rgba(80,200,80,0.5)" stroke-width="1.5"/>
                                    <polyline points="0,42 20,34 45,38 70,26 90,30 115,16 140,22 165,32 190,20 220,28 240,24"
                                        fill="rgba(80,200,80,0.06)" stroke="none"/>
                                </svg>
                            </div>
                        </button>

                        <button class="map-select-btn" data-map="raid"
                                onclick="previewMap('raid')">
                            <div class="ms-map-name">RAID</div>
                            <div class="ms-map-sub">LUXURY ESTATE — INDOOR / OUTDOOR</div>
                            <div class="ms-map-visual">
                                <svg viewBox="0 0 240 42" preserveAspectRatio="none">
                                    <!-- Outdoor left side — open terrain -->
                                    <polyline points="0,38 20,36 35,38 50,34 65,36"
                                        fill="rgba(80,160,80,0.08)" stroke="rgba(80,160,80,0.45)" stroke-width="1.2"/>
                                    <!-- House/structure center -->
                                    <polyline points="65,36 65,18 85,18 85,10 155,10 155,18 175,18 175,36"
                                        fill="rgba(180,140,80,0.12)" stroke="rgba(200,160,90,0.6)" stroke-width="1.4"/>
                                    <!-- Roof line -->
                                    <polyline points="85,10 120,2 155,10"
                                        fill="none" stroke="rgba(220,180,100,0.5)" stroke-width="1"/>
                                    <!-- Pool outdoor right -->
                                    <rect x="185" y="28" width="40" height="10" fill="rgba(40,120,200,0.15)" stroke="rgba(60,160,220,0.45)" stroke-width="0.8"/>
                                    <polyline points="175,36 185,36 225,36 240,36 240,38 0,38"
                                        fill="none" stroke="rgba(180,160,100,0.3)" stroke-width="0.8"/>
                                </svg>
                            </div>
                        </button>

                    </div>

                    <div class="ms-divider"></div>
                    <div class="ms-section-label">MATCH PARAMETERS</div>

                    <div class="ms-stat-row"><span>MODE</span><span id="ms-stat-mode">SOLO</span></div>
                    <div class="ms-stat-row"><span>MAP</span><span>THE VALLEY</span></div>
                    <div class="ms-stat-row"><span>ENEMIES</span><span id="ms-stat-enemies">3</span></div>

                    <!-- Difficulty — shown only in solo mode -->
                    <div id="ms-difficulty-area">
                        <div class="ms-divider" style="margin-top:4px;"></div>
                        <div class="ms-section-label" style="margin-top:8px;">DIFFICULTY</div>
                        <div class="ms-diff-grid">
                            <button class="ms-diff-btn selected" data-count="3" onclick="msSetDifficulty(this,3)">
                                EASY
                                <span class="db-count">3 BOTS</span>
                                <div class="db-pips">
                                    <div class="db-pip on"></div>
                                    <div class="db-pip"></div>
                                    <div class="db-pip"></div>
                                </div>
                            </button>
                            <button class="ms-diff-btn" data-count="5" onclick="msSetDifficulty(this,5)">
                                MEDIUM
                                <span class="db-count">5 BOTS</span>
                                <div class="db-pips">
                                    <div class="db-pip on"></div>
                                    <div class="db-pip on"></div>
                                    <div class="db-pip"></div>
                                </div>
                            </button>
                            <button class="ms-diff-btn" data-count="10" onclick="msSetDifficulty(this,10)">
                                HARD
                                <span class="db-count">10 BOTS</span>
                                <div class="db-pips">
                                    <div class="db-pip on"></div>
                                    <div class="db-pip on"></div>
                                    <div class="db-pip on"></div>
                                </div>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- RIGHT — Player 2 -->
                <div class="ms-player ms-p2" id="ms-p2-slot">
                    <div class="ms-player-header">
                        <div class="ms-player-id" id="ms-p2-id-label">ENEMY (AI)</div>
                        <div class="ms-player-status ms-status-ai" id="ms-p2-status">AI CONTROLLED</div>
                    </div>
                    <div class="ms-selected-weapon" id="ms-p2-weapon-name">ASSAULT RIFLE</div>
                    <div class="ms-weapon-subtitle" id="ms-p2-subtitle">AUTO-ASSIGNED</div>
                    <div class="ms-weapon-grid" id="ms-p2-weapon-grid">
                        <!-- filled by JS -->
                    </div>
                </div>

            </div>

            <!-- Footer / DEPLOY -->
            <div class="ms-footer">
                <div class="ms-footer-info">PLAYER 1 <span id="ms-footer-p1">AR</span></div>
                <button class="ms-deploy-btn" id="ms-deploy-btn" disabled>DEPLOY</button>
                <div class="ms-footer-info" id="ms-footer-p2-wrap">PLAYER 2 <span id="ms-footer-p2">AR</span></div>
            </div>

        </div>

        <!-- WEAPONS MENU SCREEN -->
        <div id="weapons-menu-screen" class="screen hidden">
            <h1 style="font-size: 3rem; margin-top: 0; color: rgba(255, 255, 255, 0.9); text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);">WEAPONS</h1>
            <button id="back-from-weapons" class="btn-transparent btn-back"></button>

            <div class="weapons-grid">

                <!-- SNIPER -->
                <div class="weapon-card" style="border-color: rgba(0,255,0,0.4);">
                    <h3 class="weapon-card-title" style="color:#00ff00; text-shadow: 0 0 10px rgba(0,255,0,0.5);">SNIPER</h3>
                    <div class="wstat-row"><span>Damage</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:70%; background:#00ff00; box-shadow:0 0 6px #00ff00;"></div></div><span class="wstat-val">35</span></div>
                    <div class="wstat-row"><span>Fire Rate</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:20%; background:#00ff00; box-shadow:0 0 6px #00ff00;"></div></div><span class="wstat-val">slow</span></div>
                    <div class="wstat-row"><span>Ammo</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:25%; background:#00ff00; box-shadow:0 0 6px #00ff00;"></div></div><span class="wstat-val">10</span></div>
                    <div class="wstat-row"><span>Range</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:100%; background:#00ff00; box-shadow:0 0 6px #00ff00;"></div></div><span class="wstat-val">400</span></div>
                    <div class="wstat-row"><span>Reload</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:20%; background:#00ff00; box-shadow:0 0 6px #00ff00;"></div></div><span class="wstat-val">3.0s</span></div>
                </div>

                <!-- AR -->
                <div class="weapon-card" style="border-color: rgba(255,255,0,0.4);">
                    <h3 class="weapon-card-title" style="color:#ffff00; text-shadow: 0 0 10px rgba(255,255,0,0.5);">ASSAULT RIFLE</h3>
                    <div class="wstat-row"><span>Damage</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:50%; background:#ffff00; box-shadow:0 0 6px #ffff00;"></div></div><span class="wstat-val">25</span></div>
                    <div class="wstat-row"><span>Fire Rate</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:87%; background:#ffff00; box-shadow:0 0 6px #ffff00;"></div></div><span class="wstat-val">fast</span></div>
                    <div class="wstat-row"><span>Ammo</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:75%; background:#ffff00; box-shadow:0 0 6px #ffff00;"></div></div><span class="wstat-val">30</span></div>
                    <div class="wstat-row"><span>Range</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:50%; background:#ffff00; box-shadow:0 0 6px #ffff00;"></div></div><span class="wstat-val">200</span></div>
                    <div class="wstat-row"><span>Reload</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:40%; background:#ffff00; box-shadow:0 0 6px #ffff00;"></div></div><span class="wstat-val">2.0s</span></div>
                </div>

                <!-- SMG -->
                <div class="weapon-card" style="border-color: rgba(0,255,255,0.4);">
                    <h3 class="weapon-card-title" style="color:#00ffff; text-shadow: 0 0 10px rgba(0,255,255,0.5);">SMG</h3>
                    <div class="wstat-row"><span>Damage</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:40%; background:#00ffff; box-shadow:0 0 6px #00ffff;"></div></div><span class="wstat-val">20</span></div>
                    <div class="wstat-row"><span>Fire Rate</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:93%; background:#00ffff; box-shadow:0 0 6px #00ffff;"></div></div><span class="wstat-val">very fast</span></div>
                    <div class="wstat-row"><span>Ammo</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:100%; background:#00ffff; box-shadow:0 0 6px #00ffff;"></div></div><span class="wstat-val">40</span></div>
                    <div class="wstat-row"><span>Range</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:25%; background:#00ffff; box-shadow:0 0 6px #00ffff;"></div></div><span class="wstat-val">100</span></div>
                    <div class="wstat-row"><span>Reload</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:40%; background:#00ffff; box-shadow:0 0 6px #00ffff;"></div></div><span class="wstat-val">2.0s</span></div>
                </div>

                <!-- PISTOL -->
                <div class="weapon-card" style="border-color: rgba(255,0,0,0.4);">
                    <h3 class="weapon-card-title" style="color:#ff4444; text-shadow: 0 0 10px rgba(255,0,0,0.5);">PISTOL</h3>
                    <div class="wstat-row"><span>Damage</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:50%; background:#ff4444; box-shadow:0 0 6px #ff4444;"></div></div><span class="wstat-val">25</span></div>
                    <div class="wstat-row"><span>Fire Rate</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:73%; background:#ff4444; box-shadow:0 0 6px #ff4444;"></div></div><span class="wstat-val">medium</span></div>
                    <div class="wstat-row"><span>Ammo</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:50%; background:#ff4444; box-shadow:0 0 6px #ff4444;"></div></div><span class="wstat-val">20</span></div>
                    <div class="wstat-row"><span>Range</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:37%; background:#ff4444; box-shadow:0 0 6px #ff4444;"></div></div><span class="wstat-val">150</span></div>
                    <div class="wstat-row"><span>Reload</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:90%; background:#ff4444; box-shadow:0 0 6px #ff4444;"></div></div><span class="wstat-val">1.0s</span></div>
                </div>

                <!-- SHOTGUN -->
                <div class="weapon-card" style="border-color: rgba(255,136,0,0.4);">
                    <h3 class="weapon-card-title" style="color:#ff8800; text-shadow: 0 0 10px rgba(255,136,0,0.5);">SHOTGUN</h3>
                    <div class="wstat-row"><span>Damage</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:100%; background:#ff8800; box-shadow:0 0 6px #ff8800;"></div></div><span class="wstat-val">50</span></div>
                    <div class="wstat-row"><span>Fire Rate</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:8%; background:#ff8800; box-shadow:0 0 6px #ff8800;"></div></div><span class="wstat-val">very slow</span></div>
                    <div class="wstat-row"><span>Ammo</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:20%; background:#ff8800; box-shadow:0 0 6px #ff8800;"></div></div><span class="wstat-val">8</span></div>
                    <div class="wstat-row"><span>Range</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:14%; background:#ff8800; box-shadow:0 0 6px #ff8800;"></div></div><span class="wstat-val">55</span></div>
                    <div class="wstat-row"><span>Reload</span><div class="wstat-bar-wrap"><div class="wstat-bar" style="width:20%; background:#ff8800; box-shadow:0 0 6px #ff8800;"></div></div><span class="wstat-val">3.0s</span></div>
                </div>

            </div>
        </div>

        <!-- CONTROLS SCREEN -->
        <div id="controls-screen" class="screen hidden">
            <h1
                style="font-size: 3rem; margin-top: 0; color: rgba(255, 255, 255, 0.9); text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);">
                CONTROLS</h1>
            <div class="controls-grid">
                <!-- Keyboard Column -->
                <div class="controls-column">
                    <h3>KEYBOARD</h3>
                    <div class="control-item"><span>Move</span> <span class="control-key">WASD</span></div>
                    <div class="control-item"><span>Jump</span> <span class="control-key">SPACE</span></div>
                    <div class="control-item"><span>Shoot</span> <span class="control-key">L-CLICK</span></div>
                    <div class="control-item"><span>Aim</span> <span class="control-key">R-CLICK</span></div>
                    <div class="control-item"><span>Reload</span> <span class="control-key">R</span></div>
                    <div class="control-item"><span>Sprint</span> <span class="control-key">SHIFT</span></div>
                    <div class="control-item"><span>Settings</span> <span class="control-key">Esc</span></div>
                </div>
                <!-- Gamepad Column -->
                <div class="controls-column">
                    <h3>GAMEPAD</h3>
                    <div class="control-item"><span>Move</span> <span class="control-key">L-STICK</span></div>
                    <div class="control-item"><span>Jump</span> <span class="control-key">×</span></div>
                    <div class="control-item"><span>Shoot</span> <span class="control-key">R2</span></div>
                    <div class="control-item"><span>Aim</span> <span class="control-key">L2</span></div>
                    <div class="control-item"><span>Reload</span> <span class="control-key">□</span></div>
                    <div class="control-item"><span>Sprint</span> <span class="control-key">L3</span></div>
                    <div class="control-item"><span>Settings</span> <span class="control-key">Options</span></div>
                </div>
            </div>
            <button id="back-from-controls" class="btn-transparent btn-back"></button>

            <!-- SENSITIVITY SLIDERS -->
            <div class="sens-section">
                <!-- PC -->
                <div class="sens-panel">
                    <h3 style="color:#00ccff;">PC — Sensitivity</h3>
                    <div class="sens-row">
                        <label>Normal</label>
                        <input type="range" id="p1-sens" min="1" max="100" step="1" value="3">
                        <span class="sens-val" id="p1-sens-val">3</span>
                    </div>
                    <div class="sens-row">
                        <label>Aiming</label>
                        <input type="range" id="p1-ads-sens" min="1" max="100" step="1" value="1">
                        <span class="sens-val" id="p1-ads-sens-val">1</span>
                    </div>
                </div>
                <!-- CONTROLLER -->
                <div class="sens-panel">
                    <h3 style="color:#ff00ff;">CONTROLLER — Sensitivity</h3>
                    <div class="sens-row">
                        <label>Normal</label>
                        <input type="range" id="p2-sens" min="1" max="100" step="1" value="50">
                        <span class="sens-val" id="p2-sens-val">50</span>
                    </div>
                    <div class="sens-row">
                        <label>Aiming</label>
                        <input type="range" id="p2-ads-sens" min="1" max="100" step="1" value="8">
                        <span class="sens-val" id="p2-ads-sens-val">8</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- DIFFICULTY SELECTION -->
        <div id="difficulty-select" class="screen hidden">
            <h1 style="color:#ffffff; text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);">SELECT DIFFICULTY</h1>
            <div class="difficulty-container" style="display:flex; gap:20px; margin-bottom: 40px;">
                <button class="difficulty-btn diff-easy" onclick="selectDifficulty(3)">EASY (3 BOTS)</button>
                <button class="difficulty-btn diff-medium" onclick="selectDifficulty(5)">MEDIUM (5 BOTS)</button>
                <button class="difficulty-btn diff-hard" onclick="selectDifficulty(10)">HARD (10 BOTS)</button>
            </div>
            <button onclick="backToLobby()" class="btn-transparent btn-back"></button>
        </div>

        <!-- SOLO WEAPON SELECT -->
        <div id="solo-weapon-select" class="screen hidden">
            <h1 style="color:#ffffff; text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);">SELECT WEAPON</h1>
            <div id="solo-weapon-options" style="display:flex; gap:20px; margin-bottom: 80px;">
                <button class="weapon-btn-solo" data-weapon="sniper"
                    onclick="selectSoloWeapon('sniper')">Sniper</button>
                <button class="weapon-btn-solo selected" data-weapon="ar" onclick="selectSoloWeapon('ar')">Assault
                    Rifle</button>
                <button class="weapon-btn-solo" data-weapon="smg" onclick="selectSoloWeapon('smg')">SMG</button>
                <button class="weapon-btn-solo" data-weapon="pistol"
                    onclick="selectSoloWeapon('pistol')">Pistol</button>
                <button class="weapon-btn-solo" data-weapon="shotgun"
                    onclick="selectSoloWeapon('shotgun')">Shotgun</button>
            </div>
            <div style="display:flex; flex-direction:column; gap:40px; align-items:center;">
                <button onclick="backToDifficulty()" class="btn-transparent btn-back"></button>
                <button id="start-solo-match-btn" class="btn-transparent" style="padding: 15px 60px;">START
                    MISSION</button>
            </div>
        </div>
        <!-- PVP WEAPON SELECT -->
        <div id="pvp-weapon-select" class="screen hidden" style="position:relative;">
            <button onclick="backToLobby()" class="btn-transparent btn-back"></button>
            <!-- P1 PANEL (TOP) -->
            <div class="split-panel top"
                style="position:absolute; top:30px; left:0; width:100%; display:flex; flex-direction:column; align-items:center;">
                <h2
                    style="color:#00ccff; text-shadow: 0 0 20px #00ccff; margin-bottom: 20px; font-size: 3rem; margin-top: 0;">
                    PLAYER 1</h2>
                <div style="display:flex; gap:20px;">
                    <button class="weapon-btn-solo p1" data-player="1" data-weapon="sniper"
                        onclick="selectPvPWeapon(1, 'sniper')">Sniper</button>
                    <button class="weapon-btn-solo p1 selected" data-player="1" data-weapon="ar"
                        onclick="selectPvPWeapon(1, 'ar')">Assault Rifle</button>
                    <button class="weapon-btn-solo p1" data-player="1" data-weapon="smg"
                        onclick="selectPvPWeapon(1, 'smg')">SMG</button>
                    <button class="weapon-btn-solo p1" data-player="1" data-weapon="pistol"
                        onclick="selectPvPWeapon(1, 'pistol')">Pistol</button>
                    <button class="weapon-btn-solo p1" data-player="1" data-weapon="shotgun"
                        onclick="selectPvPWeapon(1, 'shotgun')">Shotgun</button>
                </div>
            </div>
            <!-- P2 PANEL (BOTTOM) -->
            <div class="split-panel bottom"
                style="position:absolute; bottom:30px; left:0; width:100%; display:flex; flex-direction:column; align-items:center;">
                <h2 style="color:#ff00ff; text-shadow: 0 0 20px #ff00ff; margin-bottom: 20px; font-size: 3rem;">
                    PLAYER 2 </h2>
                <div style="display:flex; gap:20px;">
                    <button class="weapon-btn-solo p2" data-player="2" data-weapon="sniper"
                        onclick="selectPvPWeapon(2, 'sniper')">Sniper</button>
                    <button class="weapon-btn-solo p2 selected" data-player="2" data-weapon="ar"
                        onclick="selectPvPWeapon(2, 'ar')">Assault Rifle</button>
                    <button class="weapon-btn-solo p2" data-player="2" data-weapon="smg"
                        onclick="selectPvPWeapon(2, 'smg')">SMG</button>
                    <button class="weapon-btn-solo p2" data-player="2" data-weapon="pistol"
                        onclick="selectPvPWeapon(2, 'pistol')">Pistol</button>
                    <button class="weapon-btn-solo p2" data-player="2" data-weapon="shotgun"
                        onclick="selectPvPWeapon(2, 'shotgun')">Shotgun</button>
                </div>
            </div>
            <button id="start-pvp-match-btn" class="btn-transparent"
                style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index: 200;">START
                MATCH</button>
        </div>

        <!-- VICTORY SCREEN -->
        <div id="victory-screen" class="screen hidden">
            <h1 id="win-text">VICTORY</h1><button id="restart-btn" class="btn-transparent">MAIN MENU</button>
        </div>

        <!-- HUD: SOLO -->
        <div id="hud-solo">
            <div class="crosshair"></div>
            <div class="player-label" style="display:none">SOLO</div>
            <!-- Hidden -->
            <div class="stats-group">
                <div class="stamina-row">
                    <div class="bar-container long-bar">
                        <div class="bar-fill stamina-fill" id="solo-stamina-bar" style="width: 100%;"></div>
                    </div>
                </div>
                <div class="main-stats">
                    <div class="stat-box">
                        <div class="stat-value health-val" id="solo-hp">100</div>
                        <div class="stat-label">HEALTH</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value ammo-val" id="solo-ammo">30</div>
                        <div class="stat-label">AMMO</div>
                    </div>
                </div>
            </div>
            <div style="position:absolute; top:20px; left:50%; transform:translateX(-50%); color:red; font-size:2rem; font-weight:bold"
                id="solo-enemies">ENEMIES: 10</div>
            <!-- MINIMAP -->
            <canvas id="minimap" width="160" height="160" style="
                position: absolute;
                bottom: 20px;
                left: 20px;
                border-radius: 50%;
                border: 2px solid rgba(255,255,255,0.4);
                background: rgba(0,0,0,0.45);
                pointer-events: none;
            "></canvas>
        </div>

        <!-- HUD: P1 (Top) -->
        <div id="hud-p1" class="hud-panel">
            <div class="crosshair"></div>
            <div class="player-label" style="color:#00ccff;">P1</div>
            <div class="stats-group">
                <div class="stamina-row">
                    <div class="bar-container long-bar">
                        <div class="bar-fill stamina-fill" id="p1-stamina-bar" style="width: 100%;">
                        </div>
                    </div>
                </div>
                <div class="main-stats">
                    <div class="stat-box">
                        <div class="stat-value health-val" id="p1-hp">100</div>
                        <div class="stat-label">HEALTH</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value ammo-val" id="p1-ammo">30</div>
                        <div class="stat-label">AMMO</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- HUD: P2 (Bottom) -->
        <div id="hud-p2" class="hud-panel">
            <div class="crosshair"></div>
            <div class="player-label" style="color:#ff00ff;">P2</div>
            <div class="stats-group">
                <div class="stamina-row">
                    <div class="bar-container long-bar">
                        <div class="bar-fill stamina-fill" id="p2-stamina-bar" style="width: 100%;"></div>
                    </div>
                </div>
                <div class="main-stats">
                    <div class="stat-box">
                        <div class="stat-value health-val" id="p2-hp">100</div>
                        <div class="stat-label">HEALTH</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value ammo-val" id="p2-ammo">30</div>
                        <div class="stat-label">AMMO</div>
                    </div>
                </div>
            </div>
        </div>
        <script type="module">import * as THREE from 'three';

            // ══════════════════════════════════════════════════════════════
            // SOUND ENGINE v5  –  AAA Cinematic / Procedural
            //
            // Arquitectura por capa (disparos e impactos):
            //   TRANSIENT → BODY (saturado) → TAIL
            //   cada uno → [dry] → compressor → out
            //              [wet] → reverb    → comp → out
            //
            // Mejoras sobre v4:
            //   • Compresor cinematográfico (ratio 10, threshold -24 dB)
            //   • jitter() ±3–6%: ningún sonido se repite igual
            //   • _transient(): crack mecánico 10–15ms en disparos e impactos
            //   • gunshot() con 4 capas + saturación analógica en body
            //   • Oclusión real por distancia: lowpass dinámico (no solo volumen)
            //   • footstep() silenciosa y diferenciada de impactos de bala
            //   • metalClang() con jitter por parcial y volumen reducido
            //   • buttonClick() orgánico (triangle + lowpass, sin sine puro)
            // ══════════════════════════════════════════════════════════════
            let _ac = null;
            let _comp = null;        // DynamicsCompressor maestro
            let _reverb = null;      // ConvolverNode (sala exterior)
            let _rvSend = null;      // Gain de envío al reverb
            let _audioReady = false;

            function ac() {
                if (!_ac) {
                    _ac = new (window.AudioContext || window.webkitAudioContext)();
                    _buildMaster();
                }
                return _ac;
            }

            // CHANGED: Patch 3A — Buffer de ruido compartido: se genera UNA SOLA VEZ en _buildMaster()
            // y se reutiliza en todos los disparos/impactos. Elimina la creación de AudioBuffer por frame.
            let SHARED_NOISE_BUFFER = null;
            // CHANGED: Patch 3C — Saturador global: mismo nodo reutilizado en toda la cadena de audio.
            // Evita crear WaveShaperNode (CPU) en cada disparo.
            let GLOBAL_SATURATOR = null;

            function _buildMaster() {
                const ctx = _ac;

                // ── Compresor cinematográfico ─────────────────────────────
                // Ratio alto + attack rápido = transientes apretados, sonido "glue"
                _comp = ctx.createDynamicsCompressor();
                _comp.threshold.value = -12;   // menos agresivo → más punch en impactos
                _comp.knee.value      =  10;
                _comp.ratio.value     =   5;   // menos aplastamiento
                _comp.attack.value    = 0.003;
                _comp.release.value   = 0.15;
                _comp.connect(ctx.destination);

                // ── Reverb de exterior (sala abierta, pre-delay 12ms) ─────
                _reverb = ctx.createConvolver();
                const irSec = 2.2;   // más cola para sensación de espacio
                const irN   = Math.floor(ctx.sampleRate * irSec);
                const irBuf = ctx.createBuffer(2, irN, ctx.sampleRate);
                for (let ch = 0; ch < 2; ch++) {
                    const d = irBuf.getChannelData(ch);
                    for (let i = 0; i < irN; i++) {
                        const pre = Math.floor(ctx.sampleRate * 0.012); // 12ms pre-delay
                        d[i] = i < pre ? 0 :
                               (Math.random() * 2 - 1) *
                               Math.pow(1 - (i - pre) / (irN - pre), 3.2); // decaimiento más rápido al inicio
                    }
                }
                _reverb.buffer = irBuf;

                _rvSend = ctx.createGain();
                _rvSend.gain.value = 0.22;   // wet más contenido para disparos secos
                _reverb.connect(_rvSend);
                _rvSend.connect(_comp);

                // CHANGED: Patch 3A — Pre-generar buffer de ruido blanco (1 segundo) una sola vez
                SHARED_NOISE_BUFFER = ctx.createBuffer(1, Math.ceil(ctx.sampleRate * 1.0), ctx.sampleRate);
                const noiseData = SHARED_NOISE_BUFFER.getChannelData(0);
                for (let i = 0; i < noiseData.length; i++) noiseData[i] = Math.random() * 2 - 1;

                // CHANGED: Patch 3C — Pre-crear saturador global con curva arctan (no se recrea por disparo)
                GLOBAL_SATURATOR = ctx.createWaveShaper();
                const satN = 512;
                const satCurve = new Float32Array(satN);
                const satAmt = 40;
                for (let i = 0; i < satN; i++) {
                    const x = (i * 2) / satN - 1;
                    satCurve[i] = ((Math.PI + satAmt) * x) / (Math.PI + satAmt * Math.abs(x));
                }
                GLOBAL_SATURATOR.curve = satCurve;
                GLOBAL_SATURATOR.oversample = '4x';
                // Conectar saturador global al compresor
                GLOBAL_SATURATOR.connect(_comp);

                _audioReady = true;
            }

            // CHANGED: Patch 6A — click-to-start: ocultar overlay y desbloquear audio
            // Este listener se dispara una sola vez, garantizando el user-gesture requerido por los navegadores.
            let _audioUnlocked = false;
            function _dismissStartOverlay() {
                unlockAudio();
                _audioUnlocked = true;
                const el = document.getElementById('click-to-start');
                if (el) el.style.display = 'none';
            }
            const _startOverlay = document.getElementById('click-to-start');
            if (_startOverlay) {
                document.addEventListener('click',   _dismissStartOverlay, { once: true });
                document.addEventListener('keydown', _dismissStartOverlay, { once: true });
                document.addEventListener('touchend', _dismissStartOverlay, { once: true });
            } else {
                // Si el overlay no existe (HTML externo), desbloquear igual en primer gesto
                _audioUnlocked = true;
            }

            // Unlock on first gesture (mantener para compatibilidad con resto del código)
            function unlockAudio() {
                const ctx = ac();
                if (ctx.state !== 'running') ctx.resume();
            }
            document.addEventListener('click', unlockAudio);
            document.addEventListener('keydown', unlockAudio);

            // ── JITTER: micro-variación orgánica ─────────────────────────
            // Aplica ±pct de variación aleatoria a cualquier valor.
            // Úsalo en freq, vol, cutoff, dur → sonido nunca idéntico.
            // "Si suena perfecto, está mal."
            function jitter(val, pct = 0.03) {
                return val * (1 + (Math.random() * 2 - 1) * pct);
            }

            // ── SATURADOR ANALÓGICO ───────────────────────────────────────
            // WaveShaperNode con curva suave arctan.
            // CHANGED: Patch 3C — Devuelve GLOBAL_SATURATOR (pre-calculado) en lugar de crear
            // un nuevo WaveShaperNode por disparo. Si aún no está listo, crea uno efímero.
            function _makeSaturator(amount = 40) {
                if (GLOBAL_SATURATOR) return GLOBAL_SATURATOR;
                // Fallback (solo durante init)
                const ctx = ac();
                const ws  = ctx.createWaveShaper();
                const n   = 512;
                const curve = new Float32Array(n);
                for (let i = 0; i < n; i++) {
                    const x = (i * 2) / n - 1;
                    curve[i] = ((Math.PI + amount) * x) / (Math.PI + amount * Math.abs(x));
                }
                ws.curve      = curve;
                ws.oversample = '4x';
                return ws;
            }

            // ── PRIMITIVA: ruido blanco ───────────────────────────────────
            // CHANGED: Patch 3B — Reutiliza SHARED_NOISE_BUFFER cuando está disponible.
            // playbackRate ajusta la duración sin crear un nuevo AudioBuffer por llamada.
            // Si el buffer compartido no está listo aún (primer frame), crea uno efímero.
            function _noiseSource(dur) {
                const ctx = ac();
                if (SHARED_NOISE_BUFFER) {
                    const src = ctx.createBufferSource();
                    src.buffer = SHARED_NOISE_BUFFER;
                    // Ajustar playbackRate para cubrir la duración solicitada sin crear buffer nuevo
                    const sharedSec = SHARED_NOISE_BUFFER.length / SHARED_NOISE_BUFFER.sampleRate;
                    src.playbackRate.value = Math.max(0.25, sharedSec / Math.max(dur, 0.01));
                    src.loop = true; // por si dur > sharedSec
                    return src;
                }
                // Fallback: buffer efímero (solo durante init, antes de que _buildMaster corra)
                const n   = Math.ceil(ctx.sampleRate * (dur + 0.08));
                const buf = ctx.createBuffer(1, n, ctx.sampleRate);
                const d   = buf.getChannelData(0);
                for (let i = 0; i < n; i++) d[i] = Math.random() * 2 - 1;
                const src = ctx.createBufferSource();
                src.buffer = buf;
                return src;
            }

            // ── TRANSIENTE MECÁNICO (10–15 ms) ───────────────────────────
            // Capa 1 de todo impacto/disparo: el "crack" del contacto físico.
            // Ruido blanco → highpass agresivo → ataque 0 ms → decay ultrabreve.
            // 100% dry (sin reverb) = máxima definición y pegada.
            // CHANGED: Patch 3D — hpFreq default bajado de 5500 a 2800Hz (más orgánico, menos metálico).
            // La Q también se reduce ligeramente para evitar resonancias estridentes.
            function _transient(vol = 1.0, hpFreq = 2800, dur = 0.014, delay = 0) {
                try {
                    const ctx = ac();
                    const t   = ctx.currentTime + delay;
                    const src = _noiseSource(dur + 0.01);

                    // CHANGED: Patch 3D — frecuencia HP en rango 2500–3000Hz en lugar de 5500Hz fijo.
                    // Baja la "metalicidad" perceptual sin perder el punch del transiente.
                    const hp = ctx.createBiquadFilter();
                    hp.type = 'highpass';
                    hp.frequency.value = Math.min(hpFreq, 2500 + Math.random() * 500);
                    hp.Q.value = 0.4; // Q reducida (era 0.5) → resonancia más suave

                    const g = ctx.createGain();
                    g.gain.setValueAtTime(vol, t);           // ataque instantáneo
                    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

                    src.connect(hp); hp.connect(g); g.connect(_comp); // dry only
                    src.start(t); src.stop(t + dur + 0.01);
                } catch(e) {}
            }

            // ── BURST DE RUIDO (filtrado + envolvente ADSR) ───────────────
            // wet: 0 = seco, 1 = todo al reverb
            function noise({ dur=0.2, vol=1, attack=0.002, release=null,
                              filtType='lowpass', freq=500, freqEnd=null, Q=1,
                              delay=0, wet=0.5 }) {
                try {
                    const ctx = ac();
                    const t   = ctx.currentTime + delay;
                    const rel = release ?? dur;
                    const src = _noiseSource(dur);

                    const filt = ctx.createBiquadFilter();
                    filt.type  = filtType;
                    filt.frequency.setValueAtTime(freq, t);
                    if (freqEnd != null)
                        filt.frequency.exponentialRampToValueAtTime(Math.max(freqEnd, 20), t + dur);
                    filt.Q.value = Q;

                    const g = ctx.createGain();
                    g.gain.setValueAtTime(0.0001, t);
                    g.gain.linearRampToValueAtTime(vol, t + attack);
                    g.gain.exponentialRampToValueAtTime(0.0001, t + rel);

                    src.connect(filt); filt.connect(g);

                    const dryG = ctx.createGain(); dryG.gain.value = 1 - wet;
                    g.connect(dryG); dryG.connect(_comp);

                    if (wet > 0) {
                        const wetG = ctx.createGain(); wetG.gain.value = wet;
                        g.connect(wetG); wetG.connect(_reverb);
                    }

                    src.start(t); src.stop(t + dur + 0.08);
                } catch(e) {}
            }

            // ── OSCILADOR CON ENVOLVENTE Y DRY/WET ───────────────────────
            function tone({ freq=440, dur=0.3, vol=0.5, type='sine',
                             freqEnd=null, attack=0.003, delay=0, wet=0.4 }) {
                try {
                    const ctx = ac();
                    const t   = ctx.currentTime + delay;
                    const osc = ctx.createOscillator();
                    osc.type  = type;
                    osc.frequency.setValueAtTime(freq, t);
                    if (freqEnd != null)
                        osc.frequency.exponentialRampToValueAtTime(Math.max(freqEnd, 20), t + dur);

                    const g = ctx.createGain();
                    g.gain.setValueAtTime(0.0001, t);
                    g.gain.linearRampToValueAtTime(vol, t + attack);
                    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

                    osc.connect(g);

                    const dryG = ctx.createGain(); dryG.gain.value = 1 - wet;
                    g.connect(dryG); dryG.connect(_comp);

                    if (wet > 0) {
                        const wetG = ctx.createGain(); wetG.gain.value = wet;
                        g.connect(wetG); wetG.connect(_reverb);
                    }

                    osc.start(t); osc.stop(t + dur);
                } catch(e) {}
            }

            // ══════════════════════════════════════════════════════════════
            // DISPARO – 4 capas cinematográficas
            // ══════════════════════════════════════════════════════════════
            function gunshot({ sub=80, bodyFreq=600, bodyFreqEnd=90, bodyDur=0.32,
                                crackDur=0.07, vol=1, delay=0, subVol=0.9,
                                tailDelay=0, tailVol=0 }) {
                const d = delay;

                // ── CAPA 1: TRANSIENT – el "crack" mecánico (10–14 ms) ───
                // Ruido blanco → highpass > 6 kHz → ataque 0 ms.
                // Sin reverb (dry) = máxima pegada al oído.
                // jitter ±7% en freq = variación orgánica del disparo.
                // CHANGED: Patch 3D — 6200 → 2800Hz: transiente gunshot más orgánico
                _transient(jitter(vol * 1.05, 0.05), jitter(2800, 0.07), 0.013, d);

                // ── CAPA 2: BODY – sub + cuerpo saturado ─────────────────
                // Sub LFE (30–60 Hz): el jugador SIENTE el disparo, no solo lo oye.
                tone({ freq: jitter(sub, 0.04), dur: jitter(bodyDur * 0.55, 0.03),
                       vol: jitter(vol * subVol * 1.15, 0.03),
                       type: 'sine', freqEnd: sub * 0.28, attack: 0.001, delay: d, wet: 0.08 });

                // Cuerpo principal: ruido lowpass → saturador analógico → decay rápido.
                // El filtro baja de bodyFreq → bodyFreqEnd en bodyDur ms:
                // simula el cañón sellando y el gas escapando.
                try {
                    const ctx = ac(); const t = ctx.currentTime + d;
                    const src = _noiseSource(bodyDur + 0.1);

                    const filt = ctx.createBiquadFilter();
                    filt.type = 'lowpass';
                    filt.frequency.setValueAtTime(jitter(bodyFreq, 0.04), t);
                    filt.frequency.exponentialRampToValueAtTime(Math.max(jitter(bodyFreqEnd, 0.05), 20), t + bodyDur);
                    filt.Q.value = jitter(0.8, 0.1);

                    // Saturador analógico: armoniza el ruido → sonido "potente y cálido"
                    const sat = _makeSaturator(jitter(70, 0.1));

                    const g = ctx.createGain();
                    g.gain.setValueAtTime(0.0001, t);
                    g.gain.linearRampToValueAtTime(jitter(vol * 1.5, 0.03), t + 0.001);
                    g.gain.exponentialRampToValueAtTime(0.0001, t + bodyDur);

                    src.connect(filt); filt.connect(sat); sat.connect(g);
                    const dryG = ctx.createGain(); dryG.gain.value = 0.62;
                    const wetG = ctx.createGain(); wetG.gain.value = 0.38;
                    g.connect(dryG); dryG.connect(_comp);
                    g.connect(wetG); wetG.connect(_reverb);
                    src.start(t); src.stop(t + bodyDur + 0.1);
                } catch(e) {}

                // Mid-body: textura de la acción del arma (resonancia de cámara)
                noise({ dur: jitter(crackDur * 1.8, 0.05), vol: jitter(vol * 0.32, 0.05),
                        attack: 0.001, filtType: 'bandpass',
                        freq: jitter(1900, 0.06), freqEnd: jitter(580, 0.05),
                        Q: jitter(1.5, 0.08), delay: d + 0.003, wet: 0.28 });

                // ── CAPA 3: CRACK agudo – gas saliendo del cañón ─────────
                // Highpass > 3 kHz, ultracorto. Da el "pang" brillante del disparo.
                noise({ dur: jitter(crackDur, 0.05), vol: jitter(vol * 0.88, 0.04),
                        attack: 0.0004, filtType: 'highpass',
                        freq: jitter(3400, 0.05), Q: 0.5, delay: d, wet: 0.22 });

                // ── CAPA 4: TAIL – cola del entorno (eco y respiración) ───
                // Ruido lowpass que se cierra lentamente → simula reflexiones del espacio.
                // Más wet = suena a campo abierto, a distancia.
                if (tailVol > 0 && tailDelay > 0) {
                    noise({ dur: bodyDur * 0.9, vol: jitter(vol * tailVol, 0.05),
                            attack: 0.012, filtType: 'lowpass',
                            freq: jitter(bodyFreq * 1.4, 0.04), freqEnd: 55,
                            Q: 0.4, delay: d + tailDelay, wet: 0.72 });
                }
            }

            // ══════════════════════════════════════════════════════════════
            // IMPACTO METAL (bots) – parciales inarmónicos + transiente
            // ══════════════════════════════════════════════════════════════
            // Sonido de bala perforando/deformando metal.
            // Parciales de acero real con jitter ±4% → cada hit único.
            // Volumen contenido: el disparo protagoniza, el clang es detalle.
            function metalClang(vol = 1) {
                try {
                    const ctx = ac();
                    const now = ctx.currentTime;

                    // TRANSIENT: chip metálico inicial (más corto y agudo que bala en tierra)
                    // CHANGED: Patch 3D — 7500 → 3000Hz: menos estridente en impacto metálico
                    _transient(jitter(vol * 0.7, 0.06), jitter(3000, 0.08), 0.011, 0);

                    // Parciales inarmónicos de placa de acero calibrados.
                    // jitter ±4% en f y vib → suena vivo, nunca robótico.
                    const rings = [
                        { f: 820,  v: 0.90, d: 0.95, vib: 3.2  },
                        { f: 1530, v: 0.75, d: 0.72, vib: 4.8  },
                        { f: 2270, v: 0.58, d: 0.52, vib: 6.1  },
                        { f: 3680, v: 0.40, d: 0.36, vib: 7.4  },
                        { f: 5100, v: 0.25, d: 0.24, vib: 9.0  },
                        { f: 7400, v: 0.14, d: 0.16, vib: 11.0 },
                    ];

                    rings.forEach(({ f, v, d, vib }) => {
                        const osc  = ctx.createOscillator();
                        const lfo  = ctx.createOscillator(); // vibrato leve → inestabilidad orgánica
                        const lfog = ctx.createGain();
                        osc.type  = 'sine';
                        osc.frequency.value = jitter(f, 0.04);
                        lfo.frequency.value = jitter(vib, 0.05);
                        lfog.gain.value     = f * jitter(0.005, 0.08);
                        lfo.connect(lfog); lfog.connect(osc.frequency);

                        const g = ctx.createGain();
                        g.gain.setValueAtTime(vol * v, now);
                        g.gain.exponentialRampToValueAtTime(0.0001, now + d);

                        osc.connect(g);
                        const dryG = ctx.createGain(); dryG.gain.value = 0.55;
                        const wetG = ctx.createGain(); wetG.gain.value = 0.45;
                        g.connect(dryG); dryG.connect(_comp);
                        g.connect(wetG); wetG.connect(_reverb);

                        osc.start(now); lfo.start(now);
                        osc.stop(now + d + 0.05); lfo.stop(now + d + 0.05);
                    });

                    // Raspado metálico post-impacto (bala deformando chapa)
                    noise({ dur: jitter(0.10, 0.05), vol: jitter(vol * 0.38, 0.05),
                            attack: 0.002, filtType: 'bandpass',
                            freq: jitter(2000, 0.06), freqEnd: jitter(700, 0.05),
                            Q: jitter(2.2, 0.08), delay: 0.006, wet: 0.38 });

                } catch(e) {}
            }

            // ══════════════════════════════════════════════════════════════
            // PISADA – suela + suelo con desfase temporal (5–8 ms)
            // ══════════════════════════════════════════════════════════════
            // Volumen bajo: las pisadas son textura, no protagonistas.
            // Dos capas desfasadas = suela chocando LUEGO tierra absorbiendo.
            // Crujido de material 50% probabilístico → variedad natural.
            function footstep(vol = 0.28) {
                // Thud de suela: frecuencia media-baja (110 Hz, no 68 Hz → diferente al impacto de bala)
                tone({ freq: jitter(110, 0.05), dur: jitter(0.09, 0.05),
                       vol: jitter(vol * 0.50, 0.04), type: 'sine',
                       freqEnd: jitter(50, 0.05), attack: 0.003, wet: 0.05 });

                // Textura de suelo: bandpass que baja (hierba/tierra)
                // Desfase +6ms → suela primero, tierra después
                noise({ dur: jitter(0.07, 0.06), vol: jitter(vol * 0.26, 0.05),
                        attack: 0.004, filtType: 'bandpass',
                        freq: jitter(290, 0.05), freqEnd: jitter(85, 0.05),
                        Q: jitter(1.2, 0.07), delay: 0.006, wet: 0.07 });

                // Crujido orgánico (50% de las pisadas) → evita monotonía
                if (Math.random() > 0.5) {
                    noise({ dur: jitter(0.04, 0.1), vol: jitter(vol * 0.09, 0.07),
                            attack: 0.001, filtType: 'highpass',
                            freq: jitter(2000, 0.08), Q: 0.7, delay: 0.008, wet: 0.05 });
                }
            }

            // ══════════════════════════════════════════════════════════════
            // SFX API – interfaz pública del motor de sonido
            // ══════════════════════════════════════════════════════════════
            const SFX = {
                _s1: 0, _s2: 0,

                tickFootstep(wc, moving) {
                    if (!moving) { this._s1 = 0; return; }
                    const s = Math.sin(wc);
                    if (s > 0.85 && this._s1 <= 0.85) footstep(0.5);
                    this._s1 = s;
                },

                tickFootstep2(wc, moving) {
                    if (!moving) { this._s2 = 0; return; }
                    const s = Math.sin(wc);
                    if (s > 0.85 && this._s2 <= 0.85) footstep(0.5);
                    this._s2 = s;
                },

                // ── DISPAROS: jitter por arma → cada tiro único ───────────
                shoot(key, vm = 1) {
                    if (key === 'pistol') {
                        // Pistola: seca, rápida, crack agudo dominante
                        gunshot({ sub: jitter(95, 0.04), bodyFreq: jitter(820, 0.04),
                                  bodyFreqEnd: jitter(105, 0.05), bodyDur: jitter(0.25, 0.04),
                                  crackDur: jitter(0.08, 0.05), vol: jitter(1.05 * vm, 0.03),
                                  subVol: 0.92 });
                    } else if (key === 'ar') {
                        // AR: balanceada, cuerpo medio, contundente
                        gunshot({ sub: jitter(80, 0.04), bodyFreq: jitter(660, 0.04),
                                  bodyFreqEnd: jitter(88, 0.05), bodyDur: jitter(0.22, 0.04),
                                  crackDur: jitter(0.06, 0.05), vol: jitter(0.98 * vm, 0.03),
                                  subVol: 0.88 });
                    } else if (key === 'smg') {
                        // SMG: más ligera, rápida, menos sub
                        gunshot({ sub: jitter(70, 0.04), bodyFreq: jitter(560, 0.05),
                                  bodyFreqEnd: jitter(98, 0.05), bodyDur: jitter(0.16, 0.04),
                                  crackDur: jitter(0.05, 0.05), vol: jitter(0.82 * vm, 0.03),
                                  subVol: 0.72 });
                    } else if (key === 'sniper') {
                        // Sniper: sub profundo, cola larga, eco de campo
                        gunshot({ sub: jitter(55, 0.03), bodyFreq: jitter(420, 0.04),
                                  bodyFreqEnd: jitter(45, 0.05), bodyDur: jitter(0.65, 0.03),
                                  crackDur: jitter(0.11, 0.04), vol: jitter(1.35 * vm, 0.02),
                                  subVol: 1.05, tailDelay: 0.18, tailVol: 0.30 });
                    } else if (key === 'shotgun') {
                        // Shotgun: el más gordo. Dos disparos desfasados simulan dispersión.
                        gunshot({ sub: jitter(72, 0.04), bodyFreq: jitter(700, 0.05),
                                  bodyFreqEnd: jitter(78, 0.05), bodyDur: jitter(0.42, 0.03),
                                  crackDur: jitter(0.10, 0.05), vol: jitter(1.2 * vm, 0.03),
                                  subVol: 1.0 });
                        // Onda de perdigones (desfase 16–25 ms → dispersión realista)
                        noise({ dur: jitter(0.18, 0.06), vol: jitter(0.40 * vm, 0.05),
                                attack: 0.002, filtType: 'bandpass',
                                freq: jitter(3100, 0.06), freqEnd: jitter(1100, 0.05),
                                Q: jitter(1.0, 0.08), delay: jitter(0.020, 0.12), wet: 0.38 });
                    }
                },

                // ── IMPACTOS por superficie ───────────────────────────────
                // occlude(baseFreq, vm): escala el cutoff según distancia.
                // A menor vm (más distancia) → cutoff más bajo → sonido "sordo".
                // Esto es oclusión real, no solo bajar volumen.
                impact(surface, vm = 1) {
                    const occlude = (f) => f * (0.25 + 0.75 * Math.min(vm, 1));

                    if (surface === 'grass') {
                        // TIERRA: el más grave de todos. Sub puro, sin agudos.
                        // "Puf" de tierra compacta. Sin transiente agudo (eso es de roca/metal).

                        // Sub dominante: 48 Hz que cae a 16 Hz → boom de tierra
                        tone({ freq: jitter(48, 0.04), dur: jitter(0.18, 0.04),
                               vol: jitter(0.68 * vm, 0.04), type: 'sine',
                               freqEnd: jitter(16, 0.05), attack: 0.001, wet: 0.06 });

                        // Cuerpo sub-sónico (cutoff ≤ 55 Hz, Q mínimo → sin pico agudo)
                        noise({ dur: jitter(0.12, 0.06), vol: jitter(0.28 * vm, 0.05),
                                attack: 0.003, filtType: 'lowpass',
                                freq: jitter(occlude(55), 0.05), freqEnd: jitter(28, 0.05),
                                Q: 0.1, delay: jitter(0.02, 0.1), wet: 0.05 });

                    } else if (surface === 'tree') {
                        // MADERA: transiente de crack + resonancia hueca + fibras
                        _transient(jitter(vm * 0.75, 0.06), jitter(occlude(4200), 0.08), 0.012, 0);

                        // Cuerpo de madera (lowpass que baja → sonido de tronco)
                        noise({ dur: jitter(0.22, 0.04), vol: jitter(0.50 * vm, 0.04),
                                attack: 0.001, filtType: 'lowpass',
                                freq: jitter(occlude(480), 0.05), freqEnd: jitter(155, 0.05),
                                Q: jitter(1.4, 0.08), wet: 0.44 });

                        // Resonancia hueca (tono triangle de caja de madera)
                        tone({ freq: jitter(occlude(220), 0.05), dur: jitter(0.20, 0.04),
                               vol: jitter(0.20 * vm, 0.05), type: 'triangle',
                               freqEnd: jitter(155, 0.04), attack: 0.001, wet: 0.52 });

                        // Crujido de fibras (desfase +5ms → primero el golpe, luego el crack)
                        noise({ dur: jitter(0.06, 0.08), vol: jitter(0.16 * vm, 0.06),
                                attack: 0.001, filtType: 'highpass',
                                freq: jitter(occlude(3800), 0.08), Q: 0.8,
                                delay: 0.005, wet: 0.28 });

                    } else if (surface === 'rock') {
                        // ROCA: el más agudo de todos. Chip mineral + cuerpo duro + polvo.
                        // CHANGED: Patch 3D — 6200 → 2700Hz: impacto de bala menos metálico
                        _transient(jitter(vm * 0.95, 0.05), jitter(occlude(2700), 0.07), 0.011, 0);

                        // Chip mineral (highpass agresivo → "tink" de piedra)
                        noise({ dur: jitter(0.06, 0.06), vol: jitter(0.60 * vm, 0.04),
                                attack: 0.0005, filtType: 'highpass',
                                freq: jitter(occlude(5200), 0.06), Q: 0.5, wet: 0.24 });

                        // Cuerpo mineral (bandpass resonante → cuerpo de la roca)
                        noise({ dur: jitter(0.22, 0.04), vol: jitter(0.46 * vm, 0.04),
                                attack: 0.002, filtType: 'bandpass',
                                freq: jitter(occlude(880), 0.05), freqEnd: jitter(270, 0.05),
                                Q: jitter(2.0, 0.08), wet: 0.48 });

                        // Sub de masa de roca (tiene peso físico)
                        tone({ freq: jitter(occlude(135), 0.05), dur: jitter(0.14, 0.04),
                               vol: jitter(0.28 * vm, 0.05), type: 'sine',
                               freqEnd: jitter(62, 0.04), attack: 0.001, wet: 0.28 });

                        // Polvo y cascajo (desfase +40ms → post-impacto)
                        noise({ dur: jitter(0.18, 0.05), vol: jitter(0.14 * vm, 0.05),
                                attack: 0.012, filtType: 'bandpass',
                                freq: jitter(occlude(1700), 0.06), freqEnd: jitter(580, 0.05),
                                Q: jitter(1.5, 0.08), delay: 0.040, wet: 0.58 });

                    } else if (surface === 'bot') {
                        // IMPACTO CHALECO — nodos directos, sin reverb, máximo punch
                        try {
                            const ctx2 = ac(); const t2 = ctx2.currentTime;

                            // Thud principal (lowpass, seco al 100%)
                            const ns1 = _noiseSource(0.08);
                            const f1  = ctx2.createBiquadFilter();
                            f1.type = 'lowpass';
                            f1.frequency.setValueAtTime(380, t2);
                            f1.frequency.exponentialRampToValueAtTime(75, t2 + 0.07);
                            f1.Q.value = 0.5;
                            const g1 = ctx2.createGain();
                            g1.gain.setValueAtTime(3.0 * vm, t2);
                            g1.gain.exponentialRampToValueAtTime(0.0001, t2 + 0.07);
                            ns1.connect(f1); f1.connect(g1); g1.connect(_comp);
                            ns1.start(t2); ns1.stop(t2 + 0.09);

                            // Toque metálico de placa (highpass breve)
                            const ns2 = _noiseSource(0.022);
                            const f2  = ctx2.createBiquadFilter();
                            f2.type = 'highpass';
                            f2.frequency.value = jitter(1900, 0.1);
                            f2.Q.value = 0.5;
                            const g2 = ctx2.createGain();
                            g2.gain.setValueAtTime(2.0 * vm, t2);
                            g2.gain.exponentialRampToValueAtTime(0.0001, t2 + 0.020);
                            ns2.connect(f2); f2.connect(g2); g2.connect(_comp);
                            ns2.start(t2); ns2.stop(t2 + 0.03);

                            // Sub de cuerpo (sine 70Hz)
                            const os1 = ctx2.createOscillator();
                            os1.type = 'sine';
                            os1.frequency.setValueAtTime(70, t2);
                            os1.frequency.exponentialRampToValueAtTime(28, t2 + 0.09);
                            const g3 = ctx2.createGain();
                            g3.gain.setValueAtTime(1.6 * vm, t2);
                            g3.gain.exponentialRampToValueAtTime(0.0001, t2 + 0.09);
                            os1.connect(g3); g3.connect(_comp);
                            os1.start(t2); os1.stop(t2 + 0.10);
                        } catch(e) {}
                    }
                },

                _bushTimer: null,
                triggerBushRustle() {
                    if (this._bushTimer) return;
                    noise({ dur: jitter(0.50, 0.05), vol: 0.28, attack: 0.03,
                            filtType: 'bandpass', freq: jitter(680, 0.05),
                            freqEnd: jitter(340, 0.05), Q: 2.8, wet: 0.50 });
                    noise({ dur: jitter(0.60, 0.05), vol: 0.14, attack: 0.05,
                            filtType: 'highpass', freq: jitter(1900, 0.05), Q: 1.0, wet: 0.54 });
                    this._bushTimer = setTimeout(() => { this._bushTimer = null; }, 700);
                },

                // ── CLICK DE UI – botón físico, no beep digital ───────────
                // triangle + lowpass = tecla mecánica.
                // Sin sine puro: demasiado "computadora".
                buttonClick() {
                    try {
                        const ctx = ac(); const t = ctx.currentTime;
                        const osc = ctx.createOscillator();
                        osc.type = 'triangle'; // armónicos más ricos que sine
                        osc.frequency.setValueAtTime(jitter(880, 0.07), t);
                        osc.frequency.exponentialRampToValueAtTime(jitter(380, 0.06), t + 0.042);

                        // Lowpass agresivo elimina tono sintético, deja el "click"
                        const lp = ctx.createBiquadFilter();
                        lp.type = 'lowpass'; lp.frequency.value = 1600; lp.Q.value = 0.5;

                        const g = ctx.createGain();
                        g.gain.setValueAtTime(0.16, t);
                        g.gain.exponentialRampToValueAtTime(0.0001, t + 0.045);

                        osc.connect(lp); lp.connect(g);
                        const dryG = ctx.createGain(); dryG.gain.value = 0.78;
                        const wetG = ctx.createGain(); wetG.gain.value = 0.22;
                        g.connect(dryG); dryG.connect(_comp);
                        g.connect(wetG); wetG.connect(_reverb);
                        osc.start(t); osc.stop(t + 0.048);
                    } catch(e) {}

                    // Ruido de contacto de tecla (bandpass breve)
                    noise({ dur: jitter(0.022, 0.09), vol: jitter(0.08, 0.07),
                            attack: 0.0004, filtType: 'bandpass',
                            freq: jitter(2400, 0.08), Q: 1.4, wet: 0.08 });
                }
            };

            /**
             * En modo SOLO: calcula multiplicador de volumen según distancia
             * entre una posición 3D y la cámara de p1. En PVP siempre devuelve 1.
             * minDist: dentro de esta distancia = vol máximo
             * maxDist: a partir de aquí = vol mínimo
             */
            function sfxDistVol(pos3d, minDist = 6, maxDist = 55) {
                if (gameMode !== MODE.SOLO) return 1;
                const listenerPos = p1 && p1.camera ? p1.camera.position : null;
                if (!listenerPos || !pos3d) return 1;
                const d = listenerPos.distanceTo(pos3d);
                if (d <= minDist) return 1;
                if (d >= maxDist) return 0.02;
                const t = (d - minDist) / (maxDist - minDist);
                // Curva cúbica: cae mucho más rápido que cuadrática
                return Math.max(0.02, 1 - t * t * t);
            }

            // ══════════════════════════════════════════════
            // LOBBY AUDIO — BO2 TACTICAL FEEL
            // ══════════════════════════════════════════════
            let _lobbyHumOsc = null;
            let _lobbyHumGain = null;

            function startLobbyHum() {
                try {
                    const ctx = ac();
                    if (_lobbyHumOsc) return;
                    // 40 Hz sine — maquinaria encendida, no consciente
                    _lobbyHumOsc = ctx.createOscillator();
                    _lobbyHumOsc.type = 'sine';
                    _lobbyHumOsc.frequency.value = 40;
                    _lobbyHumGain = ctx.createGain();
                    _lobbyHumGain.gain.value = 0;
                    _lobbyHumOsc.connect(_lobbyHumGain);
                    _lobbyHumGain.connect(_comp);
                    _lobbyHumOsc.start();
                    // Fade in gently
                    _lobbyHumGain.gain.linearRampToValueAtTime(0.018, ctx.currentTime + 1.5);
                } catch(e) {}
            }

            function stopLobbyHum() {
                try {
                    if (!_lobbyHumGain || !_lobbyHumOsc) return;
                    const ctx = ac();
                    _lobbyHumGain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5);
                    const osc = _lobbyHumOsc;
                    _lobbyHumOsc = null;
                    _lobbyHumGain = null;
                    setTimeout(() => { try { osc.stop(); } catch(e) {} }, 600);
                } catch(e) {}
            }

            function lobbyHover() {
                // Pink noise → bandpass 2000 Hz, 50ms — click táctico
                try {
                    const ctx = ac(); const t = ctx.currentTime;
                    const buf = ctx.createBuffer(1, Math.ceil(ctx.sampleRate * 0.06), ctx.sampleRate);
                    const d = buf.getChannelData(0);
                    // Pink-ish: accumulate noise
                    let b0=0,b1=0,b2=0;
                    for (let i = 0; i < d.length; i++) {
                        const w = Math.random() * 2 - 1;
                        b0 = 0.99886*b0 + w*0.0555179; b1 = 0.99332*b1 + w*0.0750759;
                        b2 = 0.96900*b2 + w*0.1538520;
                        d[i] = (b0+b1+b2+w*0.5362)*0.11;
                    }
                    const src = ctx.createBufferSource(); src.buffer = buf;
                    const bp = ctx.createBiquadFilter();
                    bp.type = 'bandpass'; bp.frequency.value = 2000; bp.Q.value = 2.5;
                    const g = ctx.createGain();
                    g.gain.setValueAtTime(0.28, t);
                    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.05);
                    src.connect(bp); bp.connect(g); g.connect(_comp);
                    src.start(t); src.stop(t + 0.06);
                } catch(e) {}
            }

            function lobbySelect() {
                // Capa 1: sine 100→60 Hz punch
                try {
                    const ctx = ac(); const t = ctx.currentTime;
                    const osc = ctx.createOscillator();
                    osc.type = 'sine'; osc.frequency.setValueAtTime(100, t);
                    osc.frequency.exponentialRampToValueAtTime(60, t + 0.12);
                    const g = ctx.createGain();
                    g.gain.setValueAtTime(0.6, t);
                    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.14);
                    osc.connect(g); g.connect(_comp);
                    osc.start(t); osc.stop(t + 0.15);
                } catch(e) {}
                // Capa 2: crack de ruido blanco filtrado
                noise({ dur: 0.03, vol: 0.4, attack: 0.001, filtType: 'highpass', freq: 3000, Q: 0.8, wet: 0.0 });
            }
            const MAP_SIZE = 400;
            const GRAVITY = -30;

            const MODE = {
                MENU: 0, SOLO: 1, PVP: 2, END: 3, PVP_SELECT: 4, SOLO_SELECT: 5, KILLCAM: 6, PAUSED: 7
            }

                ;

            // ══════════════════════════════════════════════════════════════
            // WEAPON_CONFIG — fuente única de verdad para balance de armas.
            // Modificar aquí afecta daño, cadencia, munición y rango en toda
            // la lógica del juego. No duplicar estos valores en HTML ni en UI.
            //
            // Campos:
            //   dmg      — daño por impacto
            //   speed    — velocidad del proyectil (unidades/s)
            //   reload   — tiempo de recarga (ms)
            //   cd       — cooldown entre disparos (ms)
            //   maxAmmo  — capacidad del cargador
            //   range    — distancia máxima del proyectil (unidades)
            //   recoil   — factor de retroceso de cámara (0.0–1.0 aprox.)
            //   color    — color hex del proyectil visual
            // ══════════════════════════════════════════════════════════════
            const WEAPON_CONFIG = {
                sniper:  { dmg: 35,  speed: 300, reload: 3000, cd: 1200, maxAmmo: 10, range: 400, recoil: 0.18, color: 0x00ff88 },
                ar:      { dmg: 25,  speed: 300, reload: 2000, cd: 200,  maxAmmo: 30, range: 200, recoil: 0.05, color: 0xffff00 },
                smg:     { dmg: 20,  speed: 300, reload: 2000, cd: 100,  maxAmmo: 40, range: 100, recoil: 0.03, color: 0x00ffff },
                pistol:  { dmg: 25,  speed: 300, reload: 1000, cd: 400,  maxAmmo: 20, range: 150, recoil: 0.08, color: 0xff4444 },
                shotgun: { dmg: 50,  speed: 300, reload: 3000, cd: 1500, maxAmmo:  8, range:  65, recoil: 0.22, color: 0xff8800 },
            };

            // WEAPONS — agrega el nombre display; stats provienen de WEAPON_CONFIG.
            // Nunca modificar stats aquí directamente; editar WEAPON_CONFIG arriba.
            const WEAPONS = Object.fromEntries(
                Object.entries(WEAPON_CONFIG).map(([key, cfg]) => [key, {
                    ...cfg,
                    name: { sniper: 'Sniper', ar: 'Assault Rifle', smg: 'SMG', pistol: 'Pistol', shotgun: 'Shotgun' }[key],
                }])
            )

                ;
            let selectedWeapon = 'ar';
            let p1SelectedWeapon = 'ar';
            let p2SelectedWeapon = 'ar';
            const lobbyBots = [];

            // Sensibilidad ajustable (escala: valor del slider / 1000)
            let p1SensBase = 0.003;   // mouse normal P1
            let p1SensAds  = 0.001;   // mouse apuntando P1
            let p2SensBase = 0.05;    // gamepad normal P2
            let p2SensAds  = 0.008;   // gamepad apuntando P2

            // Globals
            let gameMode = MODE.MENU;
            let prePauseMode = MODE.MENU; // guarda el modo antes de pausar
            let gameEnding = false;   // set to true the moment endGame fires; blocks all AI updates
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);
            scene.fog = new THREE.Fog(0x2c3e50, 20, 150);

            const renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            const clock = new THREE.Clock();

            // -- LIGHTS & ENV --
            const hemiLight = new THREE.HemisphereLight(0x607d8b, 0x2d5a1e, 0.4);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffd700, 0.5);
            dirLight.position.set(80, 180, 60);
            dirLight.castShadow = true;
            // Shadow camera configuration for better shadow quality
            dirLight.shadow.camera.left = -250;
            dirLight.shadow.camera.right = 250;
            dirLight.shadow.camera.top = 250;
            dirLight.shadow.camera.bottom = -250;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 700;
            dirLight.shadow.mapSize.width = 4096;
            dirLight.shadow.mapSize.height = 4096;
            dirLight.shadow.bias = -0.0003;
            dirLight.shadow.normalBias = 0.02;
            scene.add(dirLight);

            // ══════════════════════════════════════════════════════════
            // ══════════════════════════════════════════════════════════
            // ══════════════════════════════════════════════════════════
            // LOBBY — BURNING CITY AT NIGHT  (rebuilt from scratch)
            // ══════════════════════════════════════════════════════════
            const lobbyGroup = new THREE.Group();
            scene.add(lobbyGroup);
            const natureGroup = new THREE.Group();
            scene.add(natureGroup);

            // ── Renderer tone & background ────────────────────────────
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.95;

            // ── GROUND — cracked concrete/asphalt street ────────────
            // Flat plane — no displacement. Displacement caused "floating" black
            // patches and z-fighting. The material color does the work instead.
            const groundMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(500, 500),
                new THREE.MeshStandardMaterial({
                    color: 0x1c1a16,   // dark gray-brown concrete, NOT pure black
                    roughness: 0.92,
                    metalness: 0.06,   // slight wet-road sheen so fires reflect
                }));
            groundMesh.rotation.x = -Math.PI/2;
            groundMesh.receiveShadow = true;
            lobbyGroup.add(groundMesh);

            // Road asphalt strips — slightly lighter than concrete base
            for (let i = 0; i < 4; i++) {
                const road = new THREE.Mesh(
                    new THREE.PlaneGeometry(18, 300),
                    new THREE.MeshStandardMaterial({ color: 0x141210, roughness: 0.88, metalness: 0.08 }));
                road.rotation.x = -Math.PI/2;
                road.position.set(-45+i*30, 0.01, -40);
                lobbyGroup.add(road);
            }



            // ── SKY — pitch black with deep crimson fire-glow horizon ─
            // We use a half-sphere so the sky shows correctly behind buildings
            const skyGeo = new THREE.SphereGeometry(280, 32, 8, 0, Math.PI*2, 0, Math.PI/2);
            const skyMat = new THREE.ShaderMaterial({
                side: THREE.BackSide,
                uniforms: {
                    uTop:    { value: new THREE.Color(0x000000) },
                    uMid:    { value: new THREE.Color(0x080204) },
                    uHorizon:{ value: new THREE.Color(0x1a0600) },
                },
                vertexShader: `
                    varying float vY;
                    void main(){
                        vY = normalize(position).y;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                    }`,
                fragmentShader: `
                    uniform vec3 uTop, uMid, uHorizon;
                    varying float vY;
                    void main(){
                        vec3 c = mix(uHorizon, uMid, smoothstep(0.0, 0.18, vY));
                        c = mix(c, uTop, smoothstep(0.18, 0.7, vY));
                        gl_FragColor = vec4(c, 1.0);
                    }`
            });
            const skyMesh = new THREE.Mesh(skyGeo, skyMat);
            skyMesh.position.y = -2;
            lobbyGroup.add(skyMesh);

            // ── DISTANT CITY SILHOUETTE — 2D shape far back ───────────
            (function buildSkyline() {
                // Dense urban skyline, irregular heights
                const pts = [
                    -160,-3, -160,4, -148,4, -148,14, -140,14, -140,6,
                    -132,6, -132,20, -124,20, -124,10, -116,10, -116,28,
                    -107,28, -107,16, -98,16, -98,34, -90,34, -90,22,
                    -82,22, -82,38, -74,38, -74,24, -66,24, -66,42,
                    -58,42, -58,28, -50,28, -50,55, -42,55, -42,32,
                    -34,32, -34,46, -26,46, -26,30, -18,30, -18,48,
                    -10,48, -10,36, -2,36, -2,58,
                     6,58,  6,38, 14,38, 14,52, 22,52, 22,34,
                    30,34, 30,50, 38,50, 38,36, 46,36, 46,44,
                    54,44, 54,28, 62,28, 62,40, 70,40, 70,26,
                    78,26, 78,38, 86,38, 86,22, 94,22, 94,34,
                   102,34,102,18, 110,18, 110,28, 118,28, 118,12,
                   126,12, 126,22, 134,22, 134,8, 142,8, 142,16,
                   150,16, 150,5, 160,5, 160,-3
                ];
                const shape = new THREE.Shape();
                shape.moveTo(pts[0], pts[1]);
                for (let i=2; i<pts.length; i+=2) shape.lineTo(pts[i], pts[i+1]);
                shape.closePath();
                const sil = new THREE.Mesh(
                    new THREE.ShapeGeometry(shape),
                    new THREE.MeshBasicMaterial({ color: 0x050303 }));
                sil.position.set(0, 0, -130);
                lobbyGroup.add(sil);

                // Far background fire glow — vertical flame planes spread along the horizon
                const bgFlameMat = new THREE.ShaderMaterial({
                    transparent:true, depthWrite:false, side:THREE.DoubleSide,
                    uniforms: { uTime:{value:0} },
                    vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
                    fragmentShader:`
                        varying vec2 vUv;
                        void main(){
                            float cx = abs(vUv.x - 0.5)*2.0;
                            float taper = 1.0 - vUv.y;
                            float alpha = taper * (1.0 - cx*cx) * 0.55;
                            vec3 hot  = vec3(1.0, 0.65, 0.05);
                            vec3 mid  = vec3(0.9, 0.18, 0.0);
                            vec3 cool = vec3(0.3, 0.04, 0.0);
                            vec3 col  = mix(hot, mid, smoothstep(0.0, 0.3, vUv.y));
                            col = mix(col, cool, smoothstep(0.3, 1.0, vUv.y));
                            gl_FragColor = vec4(col, alpha);
                        }`
                });
                // Place 14 large vertical fire planes along z=-128 spread across the full width
                const bgFireXPositions = [-148,-128,-108,-88,-68,-48,-28,-8,12,32,52,72,92,112,132];
                const bgFireSizes     = [  10,  16,  10,  14,  8, 18,  6, 20, 8, 12, 7, 16, 9, 11, 10];
                const _bgGlowMat = new THREE.MeshBasicMaterial({ color: 0xff2200, transparent:true, opacity:0.25, depthWrite:false });
                bgFireXPositions.forEach((bfx, bfi) => {
                    const bfh = 12 + bgFireSizes[bfi] * 0.8;
                    for (let r=0; r<2; r++) {
                        const bfp = new THREE.Mesh(new THREE.PlaneGeometry(bgFireSizes[bfi], bfh), bgFlameMat.clone());
                        bfp.position.set(bfx, bfh/2 + 1, -128);
                        bfp.rotation.y = r * Math.PI/2;
                        lobbyGroup.add(bfp);
                    }
                    // Ground glow under each
                    const bgGlow = new THREE.Mesh(
                        new THREE.PlaneGeometry(bgFireSizes[bfi]*1.5, 5),
                        _bgGlowMat
                    );
                    bgGlow.rotation.x = -Math.PI/2;
                    bgGlow.position.set(bfx, 0.1, -128);
                    lobbyGroup.add(bgGlow);
                });
            })();

            // ── BUILDING SYSTEM ───────────────────────────────────────
            const _litWindows = [];

            // Shared building materials — created once, reused across all buildings
            const _facadeMat  = new THREE.MeshBasicMaterial({ color: 0x3a3028, transparent: true, opacity: 0.85 });
            const _interiorMat = new THREE.MeshBasicMaterial({ color: 0x060402, side: THREE.DoubleSide });
            const _sillMat    = new THREE.MeshBasicMaterial({ color: 0x100d09 });
            const _roofMat    = new THREE.MeshBasicMaterial({ color: 0x080604, side: THREE.DoubleSide });

            // Concrete material palette — all very dark, warm gray
            const CMATS = [
                new THREE.MeshStandardMaterial({ color:0x4a4438, roughness:0.95, metalness:0.02, emissive:0x2a1a08, emissiveIntensity:0.8 }),
                new THREE.MeshStandardMaterial({ color:0x3e3830, roughness:0.97, metalness:0.01, emissive:0x221408, emissiveIntensity:0.8 }),
                new THREE.MeshStandardMaterial({ color:0x504840, roughness:0.93, metalness:0.03, emissive:0x2e1a0a, emissiveIntensity:0.8 }),
                new THREE.MeshStandardMaterial({ color:0x382f28, roughness:0.98, metalness:0.01, emissive:0x1e1006, emissiveIntensity:0.8 }),
                new THREE.MeshStandardMaterial({ color:0x464038, roughness:0.96, metalness:0.02, emissive:0x281608, emissiveIntensity:0.8 }),
                new THREE.MeshStandardMaterial({ color:0x302820, roughness:0.99, metalness:0.00, emissive:0x1a0e05, emissiveIntensity:0.8 }),
            ];

            // ── FLAME SHADER HELPER — reused by ground fires AND building fires ──
            function makeFlameMat(seed) {
                return new THREE.ShaderMaterial({
                    transparent:true, depthWrite:false, side:THREE.DoubleSide,
                    uniforms: { uTime:{value:0}, uSeed:{value: seed % 10} },
                    vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
                    fragmentShader:`
                        varying vec2 vUv;
                        uniform float uSeed;
                        void main(){
                            float cx = abs(vUv.x - 0.5)*2.0;
                            float taper = 1.0 - vUv.y;
                            float alpha = taper * (1.0 - cx*cx) * 0.78;
                            vec3 hot  = vec3(1.0, 0.85, 0.1);
                            vec3 mid  = vec3(1.0, 0.28, 0.01);
                            vec3 cool = vec3(0.35, 0.04, 0.0);
                            vec3 col  = mix(hot, mid, smoothstep(0.0, 0.35, vUv.y));
                            col = mix(col, cool, smoothstep(0.35, 1.0, vUv.y));
                            gl_FragColor = vec4(col, alpha);
                        }`
                });
            }
            let _flameSeedCounter = 0;

            function makeBuilding(x, z, w, h, d, opts) {
                const { broken=false, mat=0, fireFloor=-1, fireFloors=[] } = opts||{};
                const allFireFloors = [...fireFloors];
                if (fireFloor >= 0 && !allFireFloors.includes(fireFloor)) allFireFloors.push(fireFloor);
                const g = new THREE.Group();
                const m = CMATS[mat%CMATS.length];

                // Main body — no shadow casting (perf)
                const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), m);
                body.position.set(x, h/2, z);
                g.add(body);

                // Front facade — panelized with blast holes if broken
                const facadeMat = _facadeMat;
                const interiorMat = _interiorMat;

                if (!broken) {
                    // Solid facade
                    const facade = new THREE.Mesh(new THREE.PlaneGeometry(w, h), facadeMat);
                    facade.position.set(x, h/2, z - d/2 - 0.05);
                    g.add(facade);
                } else {
                    // Blast hole patterns — each entry: [colFrac, rowFrac, wFrac, hFrac]
                    // colFrac/rowFrac = center of hole as fraction of width/height
                    // wFrac/hFrac = size of hole as fraction of width/height
                    const _holePatterns = [
                        [[0.75, 0.35, 0.22, 0.28], [0.25, 0.65, 0.18, 0.22]],
                        [[0.2,  0.4,  0.20, 0.30], [0.65, 0.6,  0.25, 0.25], [0.45, 0.25, 0.15, 0.18]],
                        [[0.5,  0.5,  0.30, 0.35], [0.15, 0.3,  0.16, 0.20]],
                        [[0.3,  0.55, 0.22, 0.28], [0.72, 0.3,  0.20, 0.22], [0.55, 0.72, 0.18, 0.18]],
                        [[0.6,  0.4,  0.25, 0.32], [0.18, 0.65, 0.18, 0.20]],
                        [[0.4,  0.35, 0.28, 0.30], [0.75, 0.6,  0.18, 0.22], [0.25, 0.7,  0.16, 0.16]],
                    ];
                    const holes = _holePatterns[_flameSeedCounter % _holePatterns.length];

                    // Convert holes to world coords
                    const worldHoles = holes.map(([cf, rf, wf, hf]) => ({
                        cx: x - w/2 + cf * w,
                        cy: rf * h,
                        hw: wf * w,
                        hh: hf * h,
                    }));

                    // Tile facade as a grid of small panels, skipping hole areas
                    const cols = Math.max(4, Math.round(w / 2.5));
                    const rows = Math.max(3, Math.round(h / 3.5));
                    const pw = w / cols, ph = h / rows;

                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            const px = x - w/2 + pw * c + pw/2;
                            const py = ph * r + ph/2;
                            // Check if this panel is inside any hole
                            const inHole = worldHoles.some(hd =>
                                Math.abs(px - hd.cx) < hd.hw/2 * 1.05 &&
                                Math.abs(py - hd.cy) < hd.hh/2 * 1.05
                            );
                            if (inHole) continue;
                            const panel = new THREE.Mesh(new THREE.PlaneGeometry(pw + 0.04, ph + 0.04), facadeMat);
                            panel.position.set(px, py, z - d/2 - 0.05);
                            g.add(panel);
                        }
                    }

                    // For each hole: dark interior + cracked edges + fire
                    worldHoles.forEach((hd, hi) => {
                        // Dark interior depth
                        const interior = new THREE.Mesh(new THREE.PlaneGeometry(hd.hw, hd.hh), interiorMat);
                        interior.position.set(hd.cx, hd.cy, z - d/2 + 0.3);
                        g.add(interior);
                        // Dark side panels inside hole (top/bottom/left/right sills) for depth
                        const sillMat = _sillMat;
                        const sillT = new THREE.Mesh(new THREE.BoxGeometry(hd.hw, 0.25, 0.5), sillMat);
                        sillT.position.set(hd.cx, hd.cy + hd.hh/2 + 0.12, z - d/2 - 0.05);
                        g.add(sillT);
                        const sillB = new THREE.Mesh(new THREE.BoxGeometry(hd.hw, 0.25, 0.5), sillMat);
                        sillB.position.set(hd.cx, hd.cy - hd.hh/2 - 0.12, z - d/2 - 0.05);
                        g.add(sillB);
                        const sillL = new THREE.Mesh(new THREE.BoxGeometry(0.25, hd.hh + 0.25, 0.5), sillMat);
                        sillL.position.set(hd.cx - hd.hw/2 - 0.12, hd.cy, z - d/2 - 0.05);
                        g.add(sillL);
                        const sillR = new THREE.Mesh(new THREE.BoxGeometry(0.25, hd.hh + 0.25, 0.5), sillMat);
                        sillR.position.set(hd.cx + hd.hw/2 + 0.12, hd.cy, z - d/2 - 0.05);
                        g.add(sillR);
                        // Fire inside hole — 2 crossed planes filling the opening
                        const flameW = hd.hw * 0.85;
                        const flameH = hd.hh * 0.75;
                        for (let r = 0; r < 2; r++) {
                            const hf = new THREE.Mesh(new THREE.PlaneGeometry(flameW, flameH), makeFlameMat(_flameSeedCounter++));
                            hf.position.set(hd.cx, hd.cy, z - d/2 - 0.02);
                            hf.rotation.y = r * Math.PI/2;
                            hf.userData.isLitWindow = true;
                            hf.userData.phase = hi * 1.7;
                            g.add(hf); _litWindows.push(hf);
                        }
                        // Glow light from hole
                        if (hi === 0) {
                            const hLight = new THREE.PointLight(0xff4400, 4.0, 18);
                            hLight.position.set(hd.cx, hd.cy, z - d/2 + 1);
                            g.add(hLight);
                        }
                    });
                }



                // Damage — jagged broken wall silhouette
                // The building body is the base; we cap it with irregular wall segments
                // of different heights to simulate chunks blown away (like a bombed-out building).
                if (broken) {
                    // Remove solid top: body already placed, we cover its top with
                    // a dark plane so the "missing" segments look hollow/open.
                    const roofHole = new THREE.Mesh(
                        new THREE.PlaneGeometry(w, d),
                        _roofMat);
                    roofHole.rotation.x = Math.PI/2;
                    roofHole.position.set(x, h + 0.02, z);
                    g.add(roofHole);

                    // Deterministic jagged profile — 6 patterns, chosen by seed
                    // Each entry is an array of height-multipliers for wall segments.
                    // Values < 1 = crumbled below roof line, 0 = gap (missing section).
                    const _profiles = [
                        [1.0, 0.0, 0.82, 1.0, 0.55, 1.0, 0.0, 0.92, 1.0, 0.65, 0.0, 1.0],
                        [0.0, 1.0, 0.7,  1.0, 0.88, 0.0, 1.0, 0.6,  1.0, 0.0,  0.78,1.0],
                        [1.0, 0.75,0.0,  1.0, 0.62, 1.0, 0.88,0.0,  1.0, 0.5,  1.0, 0.8],
                        [0.6, 1.0, 0.85, 0.0, 1.0,  0.7, 0.0, 1.0,  0.9, 1.0,  0.55,0.0],
                        [1.0, 0.0, 1.0,  0.72,1.0,  0.0, 0.85,1.0,  0.6, 0.0,  1.0, 0.88],
                        [0.0, 0.9, 1.0,  0.0, 0.78, 1.0, 0.65,0.0,  1.0, 0.82, 0.0, 1.0],
                    ];
                    const profile = _profiles[_flameSeedCounter % _profiles.length];
                    const segCount = Math.max(5, Math.round(w / 2.2));
                    const segW = w / segCount;
                    // How tall the jagged crown is above the roof line
                    const crownH = Math.max(2.5, h * 0.13);

                    for (let i = 0; i < segCount; i++) {
                        const hMul = profile[i % profile.length];
                        if (hMul === 0) continue; // gap — nothing here
                        const segH = crownH * hMul;
                        const segX = x - w/2 + segW * i + segW * 0.5;
                        // Wall segment: full depth of building
                        const seg = new THREE.Mesh(new THREE.BoxGeometry(segW + 0.05, segH, d), m);
                        seg.position.set(segX, h + segH/2, z);
                        g.add(seg);
                        // Slight tilt on alternate segments for realism
                        if (i % 3 === 1) seg.rotation.z =  0.06;
                        if (i % 3 === 2) seg.rotation.z = -0.05;
                        // Small loose chunk at base of each standing segment
                        if (hMul > 0.5) {
                            const chipW = segW * 0.55;
                            const chipH = crownH * 0.22;
                            const chip = new THREE.Mesh(new THREE.BoxGeometry(chipW, chipH, d * 0.5), m);
                            chip.position.set(segX + (i%2===0 ? segW*0.3 : -segW*0.3), h + chipH/2 - 0.1, z);
                            chip.rotation.z = (i%2===0) ? 0.22 : -0.18;
                            g.add(chip);
                        }
                    }

                    // Flame on top of jagged segments
                    for (let i = 0; i < segCount; i++) {
                        const hMul = profile[i % profile.length];
                        if (hMul < 0.6) continue;
                        const segH = crownH * hMul;
                        const segX = x - w/2 + segW * i + segW * 0.5;
                        const flameH = 2.5 + (i%3)*0.8;
                        for (let r=0; r<2; r++) {
                            const fp = new THREE.Mesh(new THREE.PlaneGeometry(segW*1.1, flameH), makeFlameMat(_flameSeedCounter++));
                            fp.position.set(segX, h + segH + flameH/2 - 0.3, z);
                            fp.rotation.y = r * Math.PI/2;
                            fp.userData.isLitWindow = true;
                            fp.userData.phase = i * 1.1;
                            g.add(fp); _litWindows.push(fp);
                        }
                    }
                }

                // Fire floors — proper flame shader, two crossed planes per column
                const wCols = Math.max(1, Math.floor(w/3.2));
                allFireFloors.forEach(ff => {
                    if (ff < 0) return;
                    const fy = 2.4 + ff*4.2;
                    for (let c=0; c<wCols; c++) {
                        const fx2 = x-w/2+1.9+c*3.2;
                        for (let r=0; r<2; r++) {
                            const fw = new THREE.Mesh(new THREE.PlaneGeometry(2.2, 3.5), makeFlameMat(_flameSeedCounter++));
                            fw.position.set(fx2, fy + 1.0, z-d/2-0.08);
                            fw.rotation.y = r * Math.PI/2;
                            fw.userData.isLitWindow=true; fw.userData.phase=c*0.7+ff*0.4;
                            g.add(fw); _litWindows.push(fw);
                        }
                    }
                });

                lobbyGroup.add(g);
            }

            // ── CITY LAYOUT — 5 depth layers ─────────────────────────
            // Layer A: Foreground row
            [
                [-148,-38, 12, 18, 10, {broken:true, mat:1, fireFloors:[1,3]}],
                [-134,-44, 17, 48, 13, {broken:true, mat:3, fireFloors:[4,6,9]}],
                [-118,-38,  9, 10,  8, {broken:true, mat:0, fireFloors:[1,2]}],
                [-100,-38, 14, 12, 10, {broken:true, mat:0, fireFloors:[1,2]}],
                [ -82,-44, 18, 55, 13, {broken:true, mat:2, fireFloors:[3,7,10]}],
                [ -64,-40,  8,  8,  7, {broken:true, mat:1, fireFloors:[1]}],
                [ -46,-48, 17, 72, 14, {broken:true, mat:3, fireFloors:[5,9,13]}],
                [ -28,-40, 10, 18,  9, {broken:true, mat:0, fireFloors:[2,3]}],
                [ -10,-46, 12, 40, 11, {broken:true, mat:4, fireFloors:[3,5,8]}],
                [   8,-40,  6,  5,  5, {broken:true, mat:1, fireFloors:[1]}],
                [  24,-48, 18, 62, 13, {broken:true, mat:2, fireFloors:[4,8,11]}],
                [  42,-40,  9, 14,  8, {broken:true, mat:3, fireFloors:[1,2]}],
                [  58,-46, 16, 48, 12, {broken:true, mat:5, fireFloors:[3,6,9]}],
                [  76,-40, 12, 22, 10, {broken:true, mat:0, fireFloors:[2,4]}],
                [  94,-46,  7,  7,  6, {broken:true, mat:2, fireFloors:[1]}],
            ].forEach(([x,z,w,h,d,o]) => makeBuilding(x,z,w,h,d,o));

            // Layer B: Mid row
            [
                [-152,-58, 11, 22,  9, {broken:true, mat:4, fireFloors:[2,4]}],
                [-138,-66, 16, 72, 12, {broken:true, mat:2, fireFloors:[5,9,13]}],
                [-122,-58,  8,  8,  7, {broken:true, mat:5, fireFloors:[1]}],
                [-105,-58, 10, 10,  8, {broken:true, mat:1, fireFloors:[1,2]}],
                [ -88,-64, 15, 68, 12, {broken:true, mat:3, fireFloors:[4,9,13]}],
                [ -70,-58,  7,  7,  6, {broken:true, mat:0, fireFloors:[1]}],
                [ -52,-66, 14, 50, 11, {broken:true, mat:2, fireFloors:[3,6,9]}],
                [ -34,-58, 12, 22, 10, {broken:true, mat:4, fireFloors:[2,4]}],
                [ -16,-66,  6,  5,  5, {broken:true, mat:1, fireFloors:[1]}],
                [   2,-58, 16, 78, 13, {broken:true, mat:5, fireFloors:[4,7,10,14]}],
                [  20,-66,  8, 12,  7, {broken:true, mat:3, fireFloors:[1,2]}],
                [  38,-58, 17, 88, 14, {broken:true, mat:0, fireFloors:[5,8,11,16]}],
                [  56,-66,  9, 16,  8, {broken:true, mat:2, fireFloors:[1,3]}],
                [  74,-58, 14, 32, 10, {broken:true, mat:1, fireFloors:[3,6]}],
                [  92,-66, 11,  8,  9, {broken:true, mat:4, fireFloors:[1]}],
            ].forEach(([x,z,w,h,d,o]) => makeBuilding(x,z,w,h,d,o));

            // Layer C: Deep mid row
            [
                [-146,-76, 10, 30,  8, {broken:true, mat:0, fireFloors:[2,5]}],
                [-132,-82, 14, 62, 11, {broken:true, mat:5, fireFloors:[4,8,12]}],
                [-116,-76,  8, 12,  7, {broken:true, mat:2, fireFloors:[1,2]}],
                [-100,-76,  9, 38,  8, {broken:true, mat:2, fireFloors:[3,6]}],
                [ -82,-82, 13, 58, 10, {broken:true, mat:0, fireFloors:[4,7,10]}],
                [ -64,-76,  7,  8,  6, {broken:true, mat:3, fireFloors:[1]}],
                [ -46,-84, 11, 44,  9, {broken:true, mat:1, fireFloors:[3,5,8]}],
                [ -28,-76, 14, 75, 11, {broken:true, mat:5, fireFloors:[4,9,14]}],
                [ -10,-84,  6,  6,  5, {broken:true, mat:2, fireFloors:[1]}],
                [   8,-76, 12, 62, 12, {broken:true, mat:0, fireFloors:[4,8,12]}],
                [  26,-84,  8, 15,  7, {broken:true, mat:4, fireFloors:[1,3]}],
                [  44,-76, 15, 52, 11, {broken:true, mat:1, fireFloors:[3,6,9]}],
                [  62,-84,  7,  9,  7, {broken:true, mat:3, fireFloors:[1,2]}],
                [  80,-76, 14, 70, 12, {broken:true, mat:0, fireFloors:[5,9,14]}],
                [  98,-84, 10, 24,  8, {broken:true, mat:2, fireFloors:[2,4]}],
            ].forEach(([x,z,w,h,d,o]) => makeBuilding(x,z,w,h,d,o));

            // Layer D: Far row
            [
                [-138,-94, 12, 35,  9, {broken:true, mat:3, fireFloors:[3,6]}],
                [-120,-98,  9,  9,  7, {broken:true, mat:1, fireFloors:[1,2]}],
                [-106,-94, 10, 20,  8, {broken:true, mat:0, fireFloors:[2,4]}],
                [ -90,-94, 11, 28,  8, {broken:true, mat:2, fireFloors:[3,5]}],
                [ -68,-98, 13, 55,  9, {broken:true, mat:0, fireFloors:[4,7,10]}],
                [ -44,-94,  8, 10,  7, {broken:true, mat:3, fireFloors:[1,2]}],
                [ -20,-100,10, 42,  8, {broken:true, mat:1, fireFloors:[3,5,8]}],
                [   4,-94, 14, 80, 10, {broken:true, mat:5, fireFloors:[5,10,15]}],
                [  28,-100, 7,  8,  6, {broken:true, mat:2, fireFloors:[1,2]}],
                [  50,-94, 13, 48,  9, {broken:true, mat:4, fireFloors:[3,6,9]}],
                [  72,-100, 9, 18,  7, {broken:true, mat:0, fireFloors:[2,3]}],
                [  90,-94, 12, 35,  8, {broken:true, mat:1, fireFloors:[3,5,7]}],
            ].forEach(([x,z,w,h,d,o]) => makeBuilding(x,z,w,h,d,o));

            // Layer E: Landmark towers — extreme height contrast across the skyline
            [
                [-128,-52, 18,100, 14, {broken:true, mat:1, fireFloors:[6,10,14,18]}],
                [-110,-68, 13, 55, 11, {broken:true, mat:4, fireFloors:[4,7,10]}],
                [ -72,-52, 20,110, 16, {broken:true, mat:3, fireFloors:[5,9,15,20]}],
                [  -5,-55, 17, 95, 15, {broken:true, mat:0, fireFloors:[4,8,12,18]}],
                [  55,-60, 15, 45, 13, {broken:true, mat:2, fireFloors:[3,5,8]}],
                [ -38,-74, 22,120, 17, {broken:true, mat:1, fireFloors:[6,11,16,22]}],
                [  30,-50, 13, 28, 11, {broken:true, mat:4, fireFloors:[2,4,6]}],
                [ -90,-68, 12, 14, 10, {broken:true, mat:5, fireFloors:[1,3]}],
                [  85,-56, 16, 85, 12, {broken:true, mat:0, fireFloors:[5,9,14,17]}],
                [  18,-80, 19,105, 15, {broken:true, mat:3, fireFloors:[5,10,15,20]}],
                [ -58,-86, 14, 60, 12, {broken:true, mat:2, fireFloors:[4,7,11]}],
            ].forEach(([x,z,w,h,d,o]) => makeBuilding(x,z,w,h,d,o));

            // ── STREET DEBRIS & RUBBLE ────────────────────────────────
            // Fixed positions — deterministic layout, no random
            const debMat = CMATS[5];
            const _debrisData = [
                [25.1,-50.75,0.96,0.7012,0.0828],[31.81,27.3,0.509,1.3255,-0.1646],
                [-50.65,-7.52,0.364,0.6247,0.0525],[8.09,-33.16,1.714,2.5429,-0.1727],
                [55.05,9.83,1.117,0.4885,0.16],[-29.41,-44.65,0.532,2.6625,0.0363],
                [55.28,12.68,1.587,3.0571,-0.0425],[9.37,21.65,1.784,2.7071,0.0271],
                [36.82,-48.88,0.847,0.9091,-0.1471],[-48.1,-43.91,0.967,1.9971,-0.0473],
                [-23.37,-34.14,0.941,2.9426,0.0518],[19.64,-37.6,2.05,0.5133,-0.0422],
                [88.11,4.6,1.637,2.1508,0.12],[49.68,-32.39,0.377,0.991,-0.0813],
                [-52.02,31.86,2.403,0.9886,0.0544],[-18.79,29.31,1.401,0.8321,-0.0887],
                [11.05,-29.35,1.703,2.8206,-0.0352],[-50.52,36.78,1.523,0.2856,-0.1585],
                [-70.26,3.47,2.201,1.3263,-0.1528],[-21.31,36.65,1.57,3.0507,0.1263],
                [-87.93,11.86,1.936,1.6869,-0.0816],[25.37,-42.96,1.343,1.4254,0.1588],
                [67.65,-29.29,1.501,0.5613,0.1444],[66.69,-26.14,1.833,1.9131,-0.1215],
                [47.25,-4.46,2.169,1.6662,-0.1748],[-31.65,-51.25,2.53,2.7606,0.1161],
                [-34.65,-47.79,2.407,2.9749,-0.145],[-2.52,-46.77,2.125,2.4059,-0.1301],
                [-4.45,-3.52,0.936,2.7408,-0.0269],[-51.88,-4.46,2.052,0.6319,-0.0659],
                [89.13,5.49,1.351,1.626,-0.1326],[-49.55,-22.57,1.712,0.7229,-0.0979],
                [-77.22,3.8,0.849,2.8445,0.1259],[-77.25,-31.58,1.906,0.673,-0.1287],
                [78.39,-1.61,1.434,2.465,0.1076],[-55.73,-44.28,1.335,1.3307,-0.0115],
                [41.23,7.6,2.662,0.3092,-0.0341],[-28.93,24.55,0.897,0.5976,-0.018],
                [-14.06,-27.93,0.9,2.9005,-0.0199],[65.04,-3.47,0.421,3.1393,0.1176],
                [84.42,30.37,2.337,0.5225,-0.005],[-51.53,-16.91,0.441,1.1906,0.1699],
                [-42.26,17.57,1.392,1.3289,0.1601],[89.18,-2.98,2.024,0.4863,-0.0712],
                [84.37,-0.87,1.601,2.3498,-0.155],[15.15,-7.74,2.347,0.4946,0.1613],
                [-75.58,-36.28,1.728,2.1212,-0.0927],[-68.42,27.13,0.891,1.8677,0.0418],
                [-14.54,-0.47,1.555,2.9365,-0.1035],[38.91,-31.52,1.25,2.1102,-0.07],
                [-33.09,14.67,0.474,1.4397,0.1745],[89.3,-46.41,0.812,0.8332,0.1516],
                [68.56,26.13,1.187,0.4956,0.1168],[36.64,2.05,2.669,2.0545,-0.1723],
                [57.08,-26.06,1.892,2.9497,-0.128],[-69.22,-43.37,1.628,0.8556,0.0367],
                [39.17,-34.68,1.822,0.8293,-0.004],[72.96,23.15,0.522,1.3307,-0.0782],
                [-89.36,16.4,1.829,0.823,0.0844],[9.3,-14.51,0.323,0.2364,0.1341],
                [72.71,-3.9,2.303,1.83,-0.1232],[-67.06,-25.26,2.458,2.5011,0.1262],
                [71.81,-34.09,0.899,0.3229,0.098],[69.14,-16.43,1.79,0.4855,0.1505],
                [65.63,34.86,2.246,2.769,-0.1663],[42.58,-23.1,2.534,2.5203,0.1274],
                [55.93,-28.99,2.19,0.3396,0.1303],[64.55,-32.98,2.26,1.4461,-0.0682],
                [53.16,-32.52,0.357,0.6067,-0.0601],[65.58,34.02,0.97,2.0153,-0.0351],
            ];
            _debrisData.forEach(([dx,dz,ds,ry,rz]) => {
                const deb = new THREE.Mesh(new THREE.BoxGeometry(ds, ds*0.45, ds*0.85), debMat);
                deb.position.set(dx, ds*0.22, dz);
                deb.rotation.y = ry;
                deb.rotation.z = rz;
                lobbyGroup.add(deb);
            });
            // Large collapsed slabs — fixed positions
            const _slabData = [
                [76.98,-2.1,10.953,3.807,0.738,1,0.0484,0.0967],
                [-73.88,2.73,5.611,8.505,0.525,4,-0.2306,0.0799],
                [-49.59,-41.45,6.425,6.639,0.673,5,0.1317,0.0484],
                [27.3,-15.86,3.13,7.65,0.482,2,0.098,-0.0751],
                [64.01,-4.43,8.502,5.283,0.629,4,-0.2236,-0.0159],
                [70.46,9.19,10.625,7.309,0.47,4,0.2002,-0.0392],
                [-46.37,17.86,7.96,5.256,0.527,5,-0.1718,-0.0054],
                [64.19,18.68,4.027,3.594,0.556,5,0.0716,-0.0813],
                [72.32,-26.21,5.294,8.646,0.409,0,-0.1531,-0.005],
                [55.96,-39.17,6.23,7.408,0.428,5,-0.0696,-0.0201],
                [-56.39,10.01,10.534,9.023,0.704,3,-0.1687,0.0608],
                [31.35,-7.84,7.517,9.422,0.399,1,0.1808,0.0335],
                [78.06,2.64,11.05,9.24,0.595,5,0.2352,-0.0147],
                [65.1,-9.33,3.932,9.03,0.53,1,0.2039,-0.0445],
                [44.43,-6.23,4.653,6.079,0.635,1,-0.137,-0.0361],
                [6.42,-33.93,4.581,7.858,0.633,0,-0.0511,-0.0338],
                [-5.45,-40.02,9.996,5.726,0.658,5,-0.2883,0.0761],
                [12.11,-6.84,10.985,5.09,0.506,3,0.0229,0.0469],
            ];
            _slabData.forEach(([sx,sz,sw,sd,sh,mat,ry,rz]) => {
                const slab = new THREE.Mesh(
                    new THREE.BoxGeometry(sw, sh, sd),
                    CMATS[mat]);
                slab.position.set(sx, 0.2, sz);
                slab.rotation.y = ry;
                slab.rotation.z = rz;
                lobbyGroup.add(slab);
            });

            // ── GROUND FIRES — vertical flame planes + point lights, NO disc ──
            // Each entry: [x, z, sz (flame width), tall (flame height), lightRange]
            const _fireDef = [

                // ═══════════════════════════════════════════════
                // FLOOR CARPET — uniform coverage, whole width
                // ═══════════════════════════════════════════════

                // Strip z=+20 → +5 (literally behind camera)
                [-140,18, 2.0, 4.5, 24], [-115,14, 3.5, 8.0, 38], [ -90,18, 1.5, 3.5, 20],
                [ -65,12, 4.0, 9.0, 44], [ -40,18, 2.5, 5.5, 28], [ -15,14, 5.0,11.0, 52],
                [  10,18, 1.8, 4.0, 22], [  35,12, 3.2, 7.5, 36], [  60,18, 2.0, 4.8, 26],
                [  88,14, 4.5,10.0, 48], [ 110,18, 1.5, 3.5, 20], [-165,10, 2.8, 6.5, 32],
                [ 128,10, 2.2, 5.0, 26],

                // Strip z=+5 → -5 (right at camera feet)
                [-155, 2, 3.0, 7.0, 36], [-130,-1, 5.5,12.0, 58], [-102, 3, 2.0, 4.5, 26],
                [ -78,-2, 4.2, 9.5, 46], [ -55, 2, 6.5,14.0, 65], [ -32,-1, 2.5, 5.5, 30],
                [  -8, 3, 4.8,11.0, 52], [  18,-2, 3.0, 7.0, 36], [  45, 2, 5.2,11.5, 54],
                [  72,-1, 2.0, 4.5, 26], [  98, 3, 3.8, 8.5, 42], [ 122,-2, 2.5, 5.5, 30],
                [-108, 0, 1.8, 4.0, 22], [  -3, 0, 7.0,15.0, 70],

                // Strip z=-10 → -20
                [-145,-12, 2.5, 5.5, 30], [-118,-16, 4.0, 9.0, 44], [ -92,-12, 1.5, 3.5, 20],
                [ -68,-18, 5.5,12.0, 56], [ -44,-12, 2.2, 5.0, 28], [ -20,-16, 4.5,10.0, 48],
                [   5,-12, 6.0,13.0, 62], [  28,-18, 2.8, 6.5, 34], [  55,-12, 4.0, 9.0, 44],
                [  80,-18, 1.5, 3.5, 20], [ 105,-12, 3.5, 8.0, 38], [-130,-14, 3.0, 7.0, 36],

                // Strip z=-22 → -35
                [-150,-28, 3.5, 8.0, 40], [-125,-30, 1.8, 4.2, 24], [ -98,-25, 5.0,11.0, 52],
                [ -74,-30, 2.2, 5.0, 28], [ -50,-25, 1.0, 2.4, 16], [ -24,-30, 6.0,13.0, 62],
                [   2,-25, 1.6, 3.8, 22], [  26,-30, 4.5,10.0, 48], [  52,-25, 2.5, 5.8, 30],
                [  78,-30, 5.5,12.0, 56], [ 102,-25, 1.8, 4.2, 24], [-112,-30, 4.0, 9.0, 44],

                // ═══════════════════════════════════════════════
                // BUILDING BASE FIRES — each building gets fire
                // at its facade (z - d/2) and sides
                // ═══════════════════════════════════════════════

                // --- Layer A facade fires (z_facade ≈ z - d/2) ---
                [-148,-43, 3.5, 8.0, 40], [-155,-45, 2.0, 4.5, 24],  // bldg -148,-38
                [-134,-51, 5.0,11.0, 52], [-126,-49, 2.5, 6.0, 30],  // bldg -134,-44
                [-118,-42, 2.5, 5.5, 28],                              // bldg -118,-38
                [-100,-43, 3.0, 7.0, 34], [-107,-44, 1.8, 4.0, 22],  // bldg -100,-38
                [ -82,-51, 5.5,12.0, 56], [ -74,-49, 3.0, 7.0, 36],  // bldg -82,-44
                [ -64,-44, 2.0, 4.5, 24],                              // bldg -64,-40
                [ -46,-55, 5.0,11.5, 54], [ -38,-53, 2.8, 6.5, 32],  // bldg -46,-48
                [ -28,-45, 3.5, 8.0, 38],                              // bldg -28,-40
                [ -10,-52, 4.0, 9.5, 46], [  -3,-50, 2.0, 4.5, 24],  // bldg -10,-46
                [   8,-43, 2.0, 4.5, 24],                              // bldg 8,-40
                [  24,-55, 5.5,12.0, 56], [  16,-53, 2.5, 5.5, 28],  // bldg 24,-48
                [  42,-44, 3.0, 6.5, 34],                              // bldg 42,-40
                [  58,-52, 4.5,10.0, 48], [  50,-50, 2.0, 4.5, 24],  // bldg 58,-46
                [  76,-45, 3.5, 8.0, 38],                              // bldg 76,-40
                [  94,-49, 2.2, 5.0, 26],                              // bldg 94,-46

                // --- Layer B facade fires ---
                [-152,-63, 3.5, 7.5, 38],                              // bldg -152,-58
                [-138,-72, 5.0,11.5, 54], [-130,-70, 2.5, 5.5, 30],  // bldg -138,-66
                [-122,-62, 2.0, 4.5, 24],                              // bldg -122,-58
                [-105,-62, 3.0, 6.5, 34],                              // bldg -105,-58
                [ -88,-70, 5.5,12.0, 56], [ -96,-68, 2.8, 6.0, 32],  // bldg -88,-64
                [ -70,-61, 2.0, 4.5, 24],                              // bldg -70,-58
                [ -52,-72, 4.5,10.0, 48], [ -60,-70, 2.2, 5.0, 26],  // bldg -52,-66
                [ -34,-63, 3.5, 7.5, 38],                              // bldg -34,-58
                [ -16,-69, 2.0, 4.5, 24],                              // bldg -16,-66
                [   2,-65, 5.0,11.5, 54], [ -5,-63, 2.5, 5.5, 30],   // bldg 2,-58
                [  20,-70, 3.0, 6.5, 34],                              // bldg 20,-66
                [  38,-65, 5.5,12.0, 58], [  30,-63, 2.5, 5.5, 30],  // bldg 38,-58
                [  56,-70, 3.0, 6.5, 34],                              // bldg 56,-66
                [  74,-63, 4.5,10.0, 48], [  66,-61, 2.0, 4.5, 24],  // bldg 74,-58
                [  92,-70, 3.0, 6.5, 34],                              // bldg 92,-66

                // --- Layer C facade fires ---
                [-146,-80, 3.5, 8.0, 38],                              // bldg -146,-76
                [-132,-88, 4.5,10.5, 50], [-140,-86, 2.0, 4.5, 24],  // bldg -132,-82
                [-116,-80, 2.5, 5.5, 28],                              // bldg -116,-76
                [-100,-80, 3.5, 7.5, 38],                              // bldg -100,-76
                [ -82,-87, 5.0,11.0, 52], [ -90,-85, 2.2, 5.0, 26],  // bldg -82,-82
                [ -64,-79, 2.0, 4.5, 24],                              // bldg -64,-76
                [ -46,-89, 4.0, 9.0, 44], [ -54,-87, 2.5, 5.5, 28],  // bldg -46,-84
                [ -28,-82, 5.0,11.0, 52],                              // bldg -28,-76
                [ -10,-87, 2.0, 4.5, 24],                              // bldg -10,-84
                [   8,-82, 4.5,10.0, 48], [  0,-80, 2.0, 4.5, 24],   // bldg 8,-76
                [  26,-88, 3.0, 6.5, 34],                              // bldg 26,-84
                [  44,-82, 5.0,11.0, 52], [  36,-80, 2.2, 5.0, 26],  // bldg 44,-76
                [  62,-88, 2.5, 5.5, 28],                              // bldg 62,-84
                [  80,-82, 5.5,12.0, 56], [  72,-80, 2.5, 5.5, 28],  // bldg 80,-76
                [  98,-88, 3.5, 7.5, 38],                              // bldg 98,-84

                // --- Layer D facade fires ---
                [-138,-99, 4.0, 9.0, 44], [-146,-97, 2.0, 4.5, 24],  // bldg -138,-94
                [-120,-102,2.5, 5.5, 28],                              // bldg -120,-98
                [-106,-98, 3.0, 6.5, 34],                              // bldg -106,-94
                [ -90,-98, 3.5, 7.5, 38],                              // bldg -90,-94
                [ -68,-103,5.0,11.0, 52], [ -76,-101,2.2, 5.0, 26],  // bldg -68,-98
                [ -44,-98, 2.5, 5.5, 28],                              // bldg -44,-94
                [ -20,-104,4.5,10.0, 48], [ -28,-102,2.0, 4.5, 24],  // bldg -20,-100
                [   4,-99, 5.5,12.0, 56], [ -4,-97, 2.5, 5.5, 28],   // bldg 4,-94
                [  28,-103,2.5, 5.5, 28],                              // bldg 28,-100
                [  50,-99, 4.5,10.0, 48], [  42,-97, 2.2, 5.0, 26],  // bldg 50,-94
                [  72,-103,3.0, 6.5, 34],                              // bldg 72,-100
                [  90,-98, 4.0, 9.0, 44], [  82,-96, 2.0, 4.5, 24],  // bldg 90,-94

                // --- Layer E landmark tower base fires (bigger) ---
                [-128,-59, 6.0,14.0, 64], [-138,-57, 3.0, 7.0, 36],  // bldg -128,-52
                [-110,-74, 4.5,10.0, 50],                              // bldg -110,-68
                [ -72,-60, 7.0,15.0, 70], [ -84,-58, 3.5, 8.0, 40],  // bldg -72,-52
                [  -5,-63, 6.0,13.0, 62], [ -14,-61, 2.8, 6.5, 32],  // bldg -5,-55
                [  55,-67, 5.0,11.0, 52], [  63,-65, 2.5, 5.5, 28],  // bldg 55,-60
                [ -38,-83, 7.0,15.0, 72], [ -50,-81, 3.5, 8.0, 40],  // bldg -38,-74
                [  30,-56, 4.0, 9.0, 44],                              // bldg 30,-50
                [ -90,-73, 3.5, 8.0, 38],                              // bldg -90,-68
                [  85,-62, 6.0,13.0, 62], [  77,-60, 2.8, 6.5, 32],  // bldg 85,-56
                [  18,-88, 6.5,14.0, 68], [  27,-86, 3.0, 7.0, 36],  // bldg 18,-80
                [ -58,-92, 5.0,11.0, 52], [ -66,-90, 2.5, 5.5, 28],  // bldg -58,-86
            ];
            const fireSources = [];
            // Derive flat [x,0,z] list for particle systems (embers, sparks)
            const _firePos = _fireDef.map(([x, z]) => [x, 0, z]);

            _fireDef.forEach(([fx, fz, sz, tall, lRange], idx) => {
                // Flame — 2 crossed vertical planes, tapering upward
                const flameMat = makeFlameMat(idx * 137.508);

                for (let r=0; r<2; r++) {
                    const fp = new THREE.Mesh(
                        new THREE.PlaneGeometry(sz*1.1, tall),
                        flameMat.clone());
                    fp.position.set(fx, tall/2, fz);
                    fp.rotation.y = r * Math.PI/2;
                    lobbyGroup.add(fp);
                }

                // Flickering point light — only 1 in 3 fires gets a light (perf)
                const colors = [0xff4400, 0xff5500, 0xff3300, 0xff6200, 0xff4800];
                if (idx % 3 === 0) {
                    const baseInt = 6.0 + sz * 2.0;
                    const fl = new THREE.PointLight(colors[idx%colors.length], baseInt, lRange * 1.6);
                    fl.position.set(fx, tall * 0.4, fz);
                    lobbyGroup.add(fl);
                    fireSources.push({
                        light:fl, fx, fy:0, fz, sz, tall,
                        phase: (idx * 2.399) % (Math.PI*2),
                        speed: 3.5 + (idx % 5) * 0.6,
                        baseInt,
                    });
                }
            });

            // ── AMBIENT LIGHTING — warm fire-lit night ───────────────
            // Enough fill to see buildings, still fire-dominated
            const _ambWarm = new THREE.HemisphereLight(0x3a1a08, 0x150a04, 0.9);
            lobbyGroup.add(_ambWarm);
            lobbyGroup.userData._ambWarm = _ambWarm;

            // Distant fire glow from the city on fire — warm from ahead
            const cityFireLight = new THREE.DirectionalLight(0x8a3a00, 2.2);
            cityFireLight.position.set(0, 15, -60);
            lobbyGroup.add(cityFireLight);

            // ── SEARCHLIGHT ───────────────────────────────────────────
            const searchSpot = new THREE.SpotLight(0xb8d4ff, 5, 120, Math.PI/24, 0.2, 1.4);
            searchSpot.position.set(-90, 38, 18);
            searchSpot.target.position.set(10, 0, -45);
            searchSpot.castShadow = false;
            lobbyGroup.add(searchSpot);
            lobbyGroup.add(searchSpot.target);

            // ── SMOKE SYSTEM — dark gray rising columns ───────────────
            const fogMats = [];

            // Ground haze planes
            for (let i=0; i<16; i++) {
                const fm = new THREE.MeshBasicMaterial({
                    color: 0x0a0806, transparent:true,
                    opacity: 0.04 + Math.random()*0.045,
                    side: THREE.DoubleSide, depthWrite: false });
                const fp = new THREE.Mesh(
                    new THREE.PlaneGeometry(130+i*24, 5+i*1.9), fm);
                fp.rotation.x = -Math.PI/2;
                fp.position.set((Math.random()-0.5)*60, 0.3+i*0.15, -12+(Math.random()-0.5)*30);
                lobbyGroup.add(fp);
                fogMats.push({ mat:fm, phase:Math.random()*Math.PI*2, mesh:fp,
                    baseX:fp.position.x, baseZ:fp.position.z });
            }



            // ── EMBER PARTICLES ───────────────────────────────────────
            const EMBER_COUNT = 2500;
            const ePos = new Float32Array(EMBER_COUNT*3);
            const eVel = new Float32Array(EMBER_COUNT*3);
            const eLife = new Float32Array(EMBER_COUNT);
            for (let i=0; i<EMBER_COUNT; i++) {
                const src = _firePos[Math.floor(Math.random()*_firePos.length)];
                ePos[i*3]   = src[0]+(Math.random()-0.5)*6;
                ePos[i*3+1] = src[1]+Math.random()*90;
                ePos[i*3+2] = src[2]+(Math.random()-0.5)*6;
                eVel[i*3]   = (Math.random()-0.5)*0.055+0.008;
                eVel[i*3+1] = 0.04+Math.random()*0.10;
                eVel[i*3+2] = (Math.random()-0.5)*0.04;
                eLife[i]    = Math.random();
            }
            const eGeo = new THREE.BufferGeometry();
            eGeo.setAttribute('position', new THREE.BufferAttribute(ePos,3));
            lobbyGroup.add(new THREE.Points(eGeo,
                new THREE.PointsMaterial({ color:0xff5500, size:0.15, transparent:true, opacity:0.88, sizeAttenuation:true })));

            // Sparks
            const SPARK_COUNT = 800;
            const spPos = new Float32Array(SPARK_COUNT*3);
            const spVel = new Float32Array(SPARK_COUNT*3);
            for (let i=0; i<SPARK_COUNT; i++) {
                const src = _firePos[Math.floor(Math.random()*_firePos.length)];
                spPos[i*3]   = src[0]+(Math.random()-0.5)*2.5;
                spPos[i*3+1] = src[1]+Math.random()*40;
                spPos[i*3+2] = src[2]+(Math.random()-0.5)*2.5;
                spVel[i*3]   = (Math.random()-0.5)*0.09;
                spVel[i*3+1] = 0.055+Math.random()*0.1;
                spVel[i*3+2] = (Math.random()-0.5)*0.07;
            }
            const spGeo = new THREE.BufferGeometry();
            spGeo.setAttribute('position', new THREE.BufferAttribute(spPos,3));
            lobbyGroup.add(new THREE.Points(spGeo,
                new THREE.PointsMaterial({ color:0xffcc33, size:0.10, transparent:true, opacity:0.92, sizeAttenuation:true })));

            // Ash / dust
            const ASH_COUNT = 1000;
            const aPos = new Float32Array(ASH_COUNT*3);
            const aVel = new Float32Array(ASH_COUNT*3);
            for (let i=0; i<ASH_COUNT; i++) {
                aPos[i*3]   = (Math.random()-0.5)*240;
                aPos[i*3+1] = 0.5+Math.random()*22;
                aPos[i*3+2] = (Math.random()-0.5)*140;
                aVel[i*3]   = (Math.random()-0.5)*0.014+0.008;
                aVel[i*3+1] = -0.0015+Math.random()*0.004;
                aVel[i*3+2] = (Math.random()-0.5)*0.01;
            }
            const aGeo = new THREE.BufferGeometry();
            aGeo.setAttribute('position', new THREE.BufferAttribute(aPos,3));
            lobbyGroup.add(new THREE.Points(aGeo,
                new THREE.PointsMaterial({ color:0x2e2820, size:0.07, transparent:true, opacity:0.3, sizeAttenuation:true })));

            // ── LEGACY ALIASES (render loop uses these names) ─────────
            const pGeo=eGeo, PARTICLE_COUNT=EMBER_COUNT, pPositions=ePos, pVelocities=eVel;
            const hGlow = { position: new THREE.Vector3() }; // dummy — no longer a mesh
            const _ambRed = { position: new THREE.Vector3() };  // dummy

            lobbyGroup.userData = {
                fireSources, fogMats, searchSpot, hGlow,
                _litWindows, _ambWarm,
                eGeo, ePos, eVel, eLife, EMBER_COUNT,
                spGeo, spPos, spVel, SPARK_COUNT,
                aGeo, aPos, aVel, ASH_COUNT,
                _firePos,
                pGeo, PARTICLE_COUNT, pPositions, pVelocities,
                gridLines:[], ringMeshes:[], scanLights:[], pillars:[],
                blueLight1:null, blueLight2:null, lobbySpot:null,
            };


            // Hide lobby group during game (shown only in MENU)
            lobbyGroup.visible = false;

            // Store lobby camera target for lerp
            const lobbyCamTarget = new THREE.Vector3(0, 8, 0);
            let lobbyCamAngle = 0; // slow pan
            let lobbyFlyIn = false;
            let lobbyFlyT = 0;
            const lobbyFlyDuration = 1.2; // seconds

            function enterLobbyScene() {
                scene.background = new THREE.Color(0x000000);
                scene.fog = null;
                renderer.shadowMap.enabled = false;
                renderer.toneMappingExposure = 1.4;
                hemiLight.intensity = 1.5;
                dirLight.color.set(0x7a3a10);
                dirLight.intensity = 1.8;
                lobbyGroup.visible = true;
                natureGroup.visible = false;
                // Hide all map geometry so it never bleeds into the menu
                try { Object.values(_mapGroups).forEach(grp => { grp.visible = false; }); } catch(e) {}
                // Ensure the last-play screenshot never bleeds into the menu background
                const lpf = document.getElementById('last-play-frame');
                if (lpf) { lpf.style.backgroundImage = ''; lpf.classList.add('hidden'); }
                document.getElementById('lobby-vignette').style.display = 'block';
                document.getElementById('lobby-scanlines').style.display = 'block';
            }

            function exitLobbyScene() {
                scene.fog = new THREE.Fog(0x2c3e50, 20, 150);
                renderer.shadowMap.enabled = true;
                hemiLight.intensity = 0.6;
                dirLight.intensity = 1.2;
                lobbyGroup.visible = false;
                document.getElementById('lobby-vignette').style.display = 'none';
                document.getElementById('lobby-scanlines').style.display = 'none';
            }

            // Start in lobby scene
            enterLobbyScene();

            // ── CAMERA FLY-IN TRANSITION ──────────────────
            function startMatchTransition(callback) {
                lobbySelect();
                exitLobbyScene();
                if (callback) callback();
            }
            window.startMatchTransition = startMatchTransition;
            let activeMapKey = 'valley';
            function getTerrainHeight(x, z) {
                if (activeMapKey === 'raid') return 0;
                const scale1 = 0.05;
                const scale2 = 0.15;
                const h1 = Math.sin(x * scale1) * Math.cos(z * scale1) * 8;
                const h2 = Math.sin(x * scale2 + 2.5) * Math.sin(z * scale2 + 2.5) * 2;
                return Math.max(0, h1 + h2);
            }

            const geo = new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE, 64, 64);
            const posAttr = geo.attributes.position;

            for (let i = 0; i < posAttr.count; i++) {
                const x = posAttr.getX(i);
                const y = posAttr.getY(i);
                posAttr.setZ(i, getTerrainHeight(x, -y));
            }

            geo.computeVertexNormals();

            const ground = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({
                color: 0x3b8c3b, flatShading: true
            }));
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.userData.mapId = 'valley';
            natureGroup.add(ground);

            // ══════════════════════════════════════════════════════════════
            // MAP SYSTEM  —  THE VALLEY | RAID
            // ══════════════════════════════════════════════════════════════

            const MAP_CONFIG = {
                valley: {
                    label:'THE VALLEY', sub:'OPEN TERRAIN — LONG RANGE',
                    svgStroke:'rgba(80,200,80,0.45)',
                    svgPts:'0,36 20,28 45,32 70,18 90,22 115,8 140,14 165,24 190,12 220,20 240,16',
                    sky:0x87CEEB, fogNear:20, fogFar:150,
                    ambientInt:0.6, dirColor:0xffffff, dirInt:1.2, reverbWet:0.22, exposure:1.0,
                    spawnP1:[-180,5,0], spawnP2:[180,5,0],
                },
                raid: {
                    label:'RAID', sub:'LUXURY ESTATE — INDOOR / OUTDOOR',
                    svgStroke:'rgba(200,160,90,0.5)',
                    svgPts:'0,38 20,36 35,38 50,34 65,36 65,18 85,18 85,10 155,10 155,18 175,18 175,36 185,36 225,36 240,38',
                    sky:0x87a0c8, fogNear:18, fogFar:130,
                    ambientInt:0.55, dirColor:0xffffff, dirInt:1.8, reverbWet:0.18, exposure:1.15,
                    spawnP1:[-170,1.2,0], spawnP2:[170,1.2,0],
                },
            };

            // ── Ambient sound nodes (stopped on map change) ───────────────
            let _mapAmbientNodes = [];
            function _stopMapAmbient() {
                _mapAmbientNodes.forEach(n => {
                    try {
                        const ctx = ac();
                        if (n._gainNode) {
                            n._gainNode.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.8);
                            const src = n._src;
                            setTimeout(() => { try { if(src) src.stop(); } catch(e){} }, 900);
                        }
                    } catch(e) {}
                });
                _mapAmbientNodes = [];
            }

            // helper: continuous noise loop with gain control
            function _ambientNoise({ filtType='lowpass', freq=200, Q=0.7, vol=0.04, color='white' }) {
                try {
                    const ctx = ac();
                    // Build a short buffer and loop it
                    const sr = ctx.sampleRate, len = Math.ceil(sr * 2);
                    const buf = ctx.createBuffer(1, len, sr);
                    const d = buf.getChannelData(0);
                    if (color === 'brown') {
                        let last = 0;
                        for (let i = 0; i < len; i++) { last = (last + 0.02*(Math.random()*2-1)) / 1.02; d[i] = last * 3.5; }
                    } else if (color === 'pink') {
                        let b0=0,b1=0,b2=0;
                        for (let i = 0; i < len; i++) {
                            const w = Math.random()*2-1;
                            b0=0.99886*b0+w*0.0555179; b1=0.99332*b1+w*0.0750759; b2=0.96900*b2+w*0.1538520;
                            d[i]=(b0+b1+b2+w*0.5362)*0.11;
                        }
                    } else {
                        for (let i = 0; i < len; i++) d[i] = Math.random()*2-1;
                    }
                    const src = ctx.createBufferSource(); src.buffer = buf; src.loop = true;
                    const filt = ctx.createBiquadFilter(); filt.type = filtType;
                    filt.frequency.value = freq; filt.Q.value = Q;
                    const g = ctx.createGain(); g.gain.value = 0;
                    src.connect(filt); filt.connect(g); g.connect(_comp);
                    src.start();
                    g.gain.linearRampToValueAtTime(vol, ctx.currentTime + 1.2);
                    const node = { _gainNode: g, _src: src };
                    _mapAmbientNodes.push(node);
                    return node;
                } catch(e) { return null; }
            }
            function _ambientTone({ freq=60, vol=0.012, type='sine', vibHz=0, vibDepth=0 }) {
                try {
                    const ctx = ac();
                    const osc = ctx.createOscillator(); osc.type = type; osc.frequency.value = freq;
                    const g = ctx.createGain(); g.gain.value = 0;
                    if (vibHz > 0) {
                        const lfo = ctx.createOscillator(); lfo.frequency.value = vibHz;
                        const lfog = ctx.createGain(); lfog.gain.value = vibDepth;
                        lfo.connect(lfog); lfog.connect(osc.frequency);
                        lfo.start();
                        const stop = osc.stop.bind(osc);
                        osc.stop = (t) => { try { lfo.stop(t); } catch(e){} stop(t); };
                    }
                    osc.connect(g); g.connect(_comp); osc.start();
                    g.gain.linearRampToValueAtTime(vol, ctx.currentTime + 1.5);
                    const node = { _gainNode: g, _src: osc };
                    _mapAmbientNodes.push(node);
                    return node;
                } catch(e) { return null; }
            }

            // ── Per-map ambient starters ──────────────────────────────────
            function _startValleyAmbient() {
                // Very subtle wind whisper — barely perceptible
                _ambientNoise({ filtType:'bandpass', freq:380, Q:0.5, vol:0.006, color:'pink' });
                // Removed the sub-bass tone — too intrusive
            }
            function _startRaidAmbient() {
                // Outdoor breeze + distant birds
                _ambientNoise({ filtType:'bandpass', freq:320, Q:0.5, vol:0.009, color:'brown' });
            }

            // ── Map switching ─────────────────────────────────────────────
            function previewMap(key) {
                if (!MAP_CONFIG[key]) return;
                activeMapKey = key;
                document.querySelectorAll('.map-select-btn').forEach(btn => {
                    btn.classList.toggle('selected', btn.dataset.map === key);
                });
            }
            window.previewMap = previewMap;

            function loadMap(key) {
                if (!MAP_CONFIG[key]) return;
                activeMapKey = key;
                window._solidCache = {};   // clear all map caches on every switch
                window._bboxCache = null;

                const cfg = MAP_CONFIG[key];
                const isValley = key === 'valley';

                // Sky & fog
                scene.background = new THREE.Color(cfg.sky);
                scene.fog = new THREE.Fog(cfg.sky, cfg.fogNear, cfg.fogFar);

                // Lighting
                dirLight.color.set(cfg.dirColor);
                dirLight.intensity = cfg.dirInt;
                hemiLight.intensity = cfg.ambientInt;
                if (cfg.exposure !== undefined) renderer.toneMappingExposure = cfg.exposure;

                // natureGroup holds valley terrain, trees, stones, bushes.
                // enterLobbyScene() hides it — we must restore it here.
                natureGroup.visible = isValley;

                // Build and toggle non-valley map geometry
                if (!isValley) {
                    if (!_mapGroups[key]) {
                        _mapGroups[key] = _buildRaid();
                        // ── Mark every visible mesh as solid so bullets collide ──
                        _mapGroups[key].traverse(obj => {
                            if (!obj.isMesh) return;
                            if (obj.isInstancedMesh) return;
                            const mat = obj.material;
                            if (!mat) return;
                            if (mat.visible === false) return;
                            if (mat.transparent && mat.opacity < 0.15) return;
                            if (mat.side === THREE.DoubleSide && mat.roughness >= 1.0) return;
                            if (mat.emissiveIntensity > 0.5) return;
                            // Skip flat planes (floors/ceilings) — they have near-zero Y extent
                            // Only walls and volumetric objects should block bullets
                            if (obj.geometry && obj.geometry.type === 'PlaneGeometry') return;
                            obj.userData.isSolid = true;
                            mat.side = THREE.DoubleSide;
                        });
                        scene.add(_mapGroups[key]);
                    }
                    _mapGroups[key].visible = true;
                    // Build solid + bbox cache eagerly so bullet collision works from first shot
                    if (!window._solidCache[key]) {
                        const _tmp = [];
                        const mapGrp = _mapGroups[key];
                        mapGrp.traverse(obj => {
                            if (obj.isMesh && obj.userData.isSolid) _tmp.push(obj);
                        });
                        window._solidCache[key] = _tmp;
                    }
                    window._bboxCache = null; // force bbox rebuild from fresh solid list
                } else {
                    Object.keys(_mapGroups).forEach(k => {
                        if (_mapGroups[k]) _mapGroups[k].visible = false;
                    });
                }

                // Spawn points
                const sp1 = cfg.spawnP1;
                const sp2 = cfg.spawnP2;
                window._mapSpawnP1 = new THREE.Vector3(sp1[0], sp1[1], sp1[2]);
                window._mapSpawnP2 = new THREE.Vector3(sp2[0], sp2[1], sp2[2]);
            }
            window.loadMap = loadMap;

            // ── Geometry builders (lazy — built once on first loadMap) ────
            const _mapGroups = {};

            // _buildRaid() — Raid (BO2-inspired luxury estate, indoor/outdoor)
            function _buildRaid() {
                const g = new THREE.Group();

                // ── CONSTANTS ─────────────────────────────────────────────────
                const WT  = 1.0;   // wall thickness (thicker = no tunneling)
                const WH  = 5.0;   // ground floor wall height
                const W2H = 4.5;   // second floor wall height
                const F2  = WH;    // second floor Y base

                // ── MATERIALS ─────────────────────────────────────────────────
                const matStucco    = new THREE.MeshStandardMaterial({ color:0xd4c8a0, roughness:0.92, metalness:0.01 });
                const matStucco2   = new THREE.MeshStandardMaterial({ color:0xc0b490, roughness:0.90, metalness:0.01 });
                const matStuccoDark= new THREE.MeshStandardMaterial({ color:0xa89878, roughness:0.90, metalness:0.01 });
                const matIndoor    = new THREE.MeshStandardMaterial({ color:0x9a7c5a, roughness:0.65, metalness:0.05, polygonOffset:true, polygonOffsetFactor:-1, polygonOffsetUnits:-1 });
                const matMarble    = new THREE.MeshStandardMaterial({ color:0xe8e0d0, roughness:0.20, metalness:0.05, polygonOffset:true, polygonOffsetFactor:-2, polygonOffsetUnits:-2 });
                const matOutdoor   = new THREE.MeshStandardMaterial({ color:0x888878, roughness:0.96, metalness:0.00 });
                const matPaving    = new THREE.MeshStandardMaterial({ color:0x888878, roughness:0.96, metalness:0.00, polygonOffset:true, polygonOffsetFactor:-2, polygonOffsetUnits:-2 });
                const matGrass     = new THREE.MeshStandardMaterial({ color:0x3b8c3b, roughness:1.00, metalness:0.00 });
                const matGrassDark = new THREE.MeshStandardMaterial({ color:0x3b8c3b, roughness:1.00, metalness:0.00 });
                const matCourt     = new THREE.MeshStandardMaterial({ color:0xc07030, roughness:0.95, metalness:0.00, polygonOffset:true, polygonOffsetFactor:-2, polygonOffsetUnits:-2 });
                const matCourtLine = new THREE.MeshBasicMaterial({ color:0xffffff, polygonOffset:true, polygonOffsetFactor:-3, polygonOffsetUnits:-3 });
                const matPool      = new THREE.MeshStandardMaterial({ color:0x0e7599, roughness:0.15, metalness:0.10, transparent:true, opacity:0.88 });
                const matPoolWall  = new THREE.MeshStandardMaterial({ color:0x1a7fa0, roughness:0.4,  metalness:0.08 });
                const matTile      = new THREE.MeshStandardMaterial({ color:0xc8c0b0, roughness:0.50, metalness:0.05, polygonOffset:true, polygonOffsetFactor:-2, polygonOffsetUnits:-2 });
                const matDeck      = new THREE.MeshStandardMaterial({ color:0xb8985a, roughness:0.85, metalness:0.00 });
                const matWood      = new THREE.MeshStandardMaterial({ color:0x6b4c2a, roughness:0.80, metalness:0.00 });
                const matDarkWood  = new THREE.MeshStandardMaterial({ color:0x3b2a1a, roughness:0.75, metalness:0.00 });
                const matMetal     = new THREE.MeshStandardMaterial({ color:0x707880, roughness:0.40, metalness:0.80 });
                const matMetalDark = new THREE.MeshStandardMaterial({ color:0x404850, roughness:0.35, metalness:0.85 });
                const matGarage    = new THREE.MeshStandardMaterial({ color:0x555560, roughness:0.72, metalness:0.20 });
                const matHedge     = new THREE.MeshStandardMaterial({ color:0x2a5e1e, roughness:1.00, metalness:0.00 });
                const matHedgeLight= new THREE.MeshStandardMaterial({ color:0x3a7a2e, roughness:1.00, metalness:0.00 });
                const matLow       = new THREE.MeshStandardMaterial({ color:0xb0a880, roughness:0.92, metalness:0.00 });
                const matCar1      = new THREE.MeshStandardMaterial({ color:0x1a2540, roughness:0.35, metalness:0.70 });
                const matCar2      = new THREE.MeshStandardMaterial({ color:0x8b1a1a, roughness:0.35, metalness:0.70 });
                const matCar3      = new THREE.MeshStandardMaterial({ color:0xf0f0f0, roughness:0.30, metalness:0.65 });
                const matGlass     = new THREE.MeshStandardMaterial({ color:0x80a8c0, roughness:0.05, metalness:0.10, transparent:true, opacity:0.35 });
                const matSofa      = new THREE.MeshStandardMaterial({ color:0x4a3a6a, roughness:0.90, metalness:0.00 });
                const matSofaLight = new THREE.MeshStandardMaterial({ color:0x8a6a4a, roughness:0.90, metalness:0.00 });
                const matTable     = new THREE.MeshStandardMaterial({ color:0x5a3a20, roughness:0.70, metalness:0.05 });
                const matWhite     = new THREE.MeshStandardMaterial({ color:0xf0eeea, roughness:0.95, metalness:0.00 });
                const matBlack     = new THREE.MeshStandardMaterial({ color:0x181818, roughness:0.60, metalness:0.10 });
                const matCeiling   = new THREE.MeshStandardMaterial({ color:0xe8e4dc, roughness:0.98, metalness:0.00 });
                const matRoof      = new THREE.MeshStandardMaterial({ color:0x5a4028, roughness:0.90, metalness:0.00 });
                const matConcrete  = new THREE.MeshStandardMaterial({ color:0x909090, roughness:0.95, metalness:0.00 });
                const matHelipad   = new THREE.MeshStandardMaterial({ color:0x303030, roughness:0.90, metalness:0.00, polygonOffset:true, polygonOffsetFactor:-2, polygonOffsetUnits:-2 });
                const matHeliLine  = new THREE.MeshBasicMaterial({ color:0xffff00 });
                const matPlanter   = new THREE.MeshStandardMaterial({ color:0x6a5040, roughness:0.88, metalness:0.00 });
                const matPlant     = new THREE.MeshStandardMaterial({ color:0x2a8a20, roughness:1.00, metalness:0.00 });
                const matBrick     = new THREE.MeshStandardMaterial({ color:0x8a5a40, roughness:0.95, metalness:0.00 });
                const matScreen    = new THREE.MeshStandardMaterial({ color:0x101820, roughness:0.10, metalness:0.40 });
                const matLamp      = new THREE.MeshStandardMaterial({ color:0xffe080, roughness:0.30, metalness:0.50 });
                const matFence     = new THREE.MeshStandardMaterial({ color:0x484848, roughness:0.40, metalness:0.70 });
                const matTennisClay= new THREE.MeshStandardMaterial({ color:0xc05a30, roughness:0.98, metalness:0.00, polygonOffset:true, polygonOffsetFactor:-2, polygonOffsetUnits:-2 });

                // ── HELPERS ──────────────────────────────────────────────────
                function box(mat, w, h, d, x, y, z, solid=false, ry=0) {
                    const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
                    m.position.set(x,y,z);
                    if (ry) m.rotation.y = ry;
                    m.castShadow = true;
                    m.receiveShadow = true;
                    if (solid) m.userData.isSolid = true;
                    g.add(m); return m;
                }
                function plane(mat, w, d, x, y, z) {
                    const m = new THREE.Mesh(new THREE.PlaneGeometry(w,d), mat);
                    m.rotation.x = -Math.PI/2;
                    m.position.set(x,y,z);
                    m.receiveShadow = true;
                    g.add(m); return m;
                }
                function cyl(mat, rt, rb, h, x, y, z, solid=false) {
                    const m = new THREE.Mesh(new THREE.CylinderGeometry(rt,rb,h,12), mat);
                    m.position.set(x,y,z);
                    m.castShadow = true; m.receiveShadow = true;
                    if (solid) m.userData.isSolid = true;
                    g.add(m); return m;
                }
                // Solid invisible collision box (for areas where you need thick collision on thin visuals)
                function solidBox(w, h, d, x, y, z) {
                    const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d),
                        new THREE.MeshBasicMaterial({ visible:false }));
                    m.position.set(x,y,z);
                    m.userData.isSolid = true;
                    g.add(m); return m;
                }
                // Planter with bush
                function planter(x, z, s=1) {
                    box(matPlanter, s*2, s*0.8, s*2, x, s*0.4, z, true);
                    const ph = s*1.2;
                    cyl(matPlant, s*0.9, s*0.7, ph, x, s*0.8+ph/2, z, false);
                }
                // Street lamp
                function lamp(x, z) {
                    box(matMetal, 0.2, 6, 0.2, x, 3, z, true);
                    box(matLamp,  0.6, 0.2, 0.6, x, 6.2, z);
                    const l = new THREE.PointLight(0xffe8a0, 2.5, 22);
                    l.position.set(x, 6, z); g.add(l);
                }
                // Car helper
                function car(mat, x, z, ry=0) {
                    const cg = new THREE.Group();
                    cg.position.set(x, 0, z);
                    cg.rotation.y = ry;
                    // body
                    const b = new THREE.Mesh(new THREE.BoxGeometry(5.2,1.4,10.5), mat);
                    b.position.y = 0.7; b.castShadow = true; b.receiveShadow = true;
                    b.userData.isSolid = true; cg.add(b);
                    // cabin
                    const c = new THREE.Mesh(new THREE.BoxGeometry(4.2,1.0,5.5), mat);
                    c.position.set(0, 2.0, -0.5); c.castShadow = true;
                    cg.add(c);
                    // wheels x4
                    const wMat = new THREE.MeshStandardMaterial({ color:0x111111, roughness:0.9 });
                    [[-2.7,0.45,-3.2],[2.7,0.45,-3.2],[-2.7,0.45,3.2],[2.7,0.45,3.2]].forEach(([wx,wy,wz])=>{
                        const w = new THREE.Mesh(new THREE.CylinderGeometry(0.45,0.45,0.35,12), wMat);
                        w.rotation.z = Math.PI/2; w.position.set(wx,wy,wz); cg.add(w);
                    });
                    g.add(cg);
                }

                // ════════════════════════════════════════════════════════════
                // GROUND PLANES
                // ════════════════════════════════════════════════════════════
                plane(matGrass, 400, 400, 0, 0, 0);                      // base grass
                // grass overlay planes removed — base plane IS grass now
                plane(matIndoor,   80,  60,   0, 0.002,  0);              // house interior floor
                plane(matMarble,   10,  16,   0, 0.002,  0);              // marble hallway inlay
                plane(matTile,     30,  30, -22, 0.002,-14);              // kitchen tile
                plane(matTile,     30,  30,  22, 0.002, 14);              // dining tile

                // ════════════════════════════════════════════════════════════
                // DRIVEWAY + ENTRANCE GATE
                // ════════════════════════════════════════════════════════════
                plane(matPaving, 16, 80, -75, 0.002, 0);   // main driveway
                plane(matPaving, 20, 28, -52, 0.002,-20);  // parking pad left
                plane(matPaving, 20, 28, -52, 0.002, 20);  // parking pad right

                // Gate pillars
                box(matStucco, 2.5, 5,   2.5, -85,  2.5, -7, true);
                box(matStucco, 2.5, 5,   2.5, -85,  2.5,  7, true);
                box(matStucco, 2.5, 5.5, 2.5, -85,  2.75, -7);
                box(matStucco, 2.5, 5.5, 2.5, -85,  2.75,  7);
                // Gate bar (decorative, open)
                box(matMetal,  13, 0.3, 0.3, -85, 4.5, 0);
                // Gate side walls
                box(matBrick, WT, 3, 30, -82, 1.5, -21, true);
                box(matBrick, WT, 3, 30, -82, 1.5,  21, true);
                // Guardhouses — paredes individuales con puerta de entrada en cara interna (z hacia el centro)
                // Guardhouse inferior (z=-16): puerta en z=-13.5 (cara hacia z=0)
                box(matStucco, 6,  3.5, WT, -95, 1.75, -18.5, true); // pared trasera
                box(matStucco, WT, 3.5, 5,  -98, 1.75, -16,   true); // pared izquierda
                box(matStucco, WT, 3.5, 5,  -92, 1.75, -16,   true); // pared derecha
                box(matStucco, 2,  3.5, WT, -97, 1.75, -13.5, true); // puerta izq (x:-98..-96)
                box(matStucco, 2,  3.5, WT, -93, 1.75, -13.5, true); // puerta der (x:-94..-92)
                box(matStucco, 2,  0.5, WT, -95, 3.25, -13.5, true); // dintel puerta
                box(matGarage, 6,  0.3, 5,  -95, 3.5,  -16,   true); // techo sólido
                // Guardhouse superior (z=+16): puerta en z=+13.5 (cara hacia z=0)
                box(matStucco, 6,  3.5, WT, -95, 1.75,  18.5, true); // pared trasera
                box(matStucco, WT, 3.5, 5,  -98, 1.75,  16,   true); // pared izquierda
                box(matStucco, WT, 3.5, 5,  -92, 1.75,  16,   true); // pared derecha
                box(matStucco, 2,  3.5, WT, -97, 1.75,  13.5, true); // puerta izq
                box(matStucco, 2,  3.5, WT, -93, 1.75,  13.5, true); // puerta der
                box(matStucco, 2,  0.5, WT, -95, 3.25,  13.5, true); // dintel puerta
                box(matGarage, 6,  0.3, 5,  -95, 3.5,   16,   true); // techo sólido
                // Guard windows
                box(matGlass,  2, 1.5, WT, -93, 2, -16);
                box(matGlass,  2, 1.5, WT, -93, 2,  16);
                // Bollards along driveway
                [-30,-10,10,30].forEach(bz => {
                    cyl(matMetal, 0.25, 0.3, 1.0, -72, 0.5, bz, true);
                    cyl(matMetal, 0.25, 0.3, 1.0, -78, 0.5, bz, true);
                });

                // ════════════════════════════════════════════════════════════
                // FOUNTAIN (front of house)
                // ════════════════════════════════════════════════════════════
                const FNX=-57, FNZ=0;
                cyl(matMarble, 6, 6.5, 0.8, FNX, 0.4, FNZ, true);   // base
                cyl(matMarble, 3, 3,   0.5, FNX, 0.85, FNZ, true);  // inner ring
                cyl(matPool,   2.8, 2.8, 0.15, FNX, 0.88, FNZ);     // water
                cyl(matWhite,  0.3, 0.4, 2.5, FNX, 1.25, FNZ);      // center column
                cyl(matPool,   0.8, 0.8, 0.2, FNX, 2.55, FNZ);      // top basin
                const fl = new THREE.PointLight(0x80d0ff, 2, 12);
                fl.position.set(FNX, 0.5, FNZ); g.add(fl);

                // ════════════════════════════════════════════════════════════
                // BASKETBALL COURT
                // ════════════════════════════════════════════════════════════
                const CX=-130, CZ=0, CW=70, CD=42;
                plane(matCourt,    CW, CD, CX, 0.002, CZ);
                plane(matCourtLine, CW, 0.25, CX, 0.002, CZ);
                plane(matCourtLine, 0.25, CD, CX, 0.002, CZ);
                plane(matCourtLine, 0.25, CD*0.6, CX-CW*0.32, 0.002, CZ);
                plane(matCourtLine, CW*0.3, 0.25, CX-CW*0.3, 0.002, CZ-CD*0.18);
                plane(matCourtLine, CW*0.3, 0.25, CX-CW*0.3, 0.002, CZ+CD*0.18);
                plane(matCourtLine, 0.25, CD*0.6, CX+CW*0.32, 0.002, CZ);
                plane(matCourtLine, CW*0.3, 0.25, CX+CW*0.3, 0.002, CZ-CD*0.18);
                plane(matCourtLine, CW*0.3, 0.25, CX+CW*0.3, 0.002, CZ+CD*0.18);
                // Hoops
                // Left hoop — pole near baseline, arm goes in X toward court center
                box(matMetal, 0.2, 3.8, 0.2, CX-CW/2+1.5, 1.9, CZ, true);          // pole
                box(matMetal, 1.8, 0.2, 0.2, CX-CW/2+2.4, 3.8, CZ, true);           // arm in X direction
                box(matCourtLine, 0.15, 1.2, 1.8, CX-CW/2+3.3, 3.5, CZ, false);     // backboard (thin, faces court)
                cyl(matMetal, 0.32, 0.32, 0.1, CX-CW/2+3.3, 3.05, CZ, false);       // hoop ring
                // Right hoop
                box(matMetal, 0.2, 3.8, 0.2, CX+CW/2-1.5, 1.9, CZ, true);          // pole
                box(matMetal, 1.8, 0.2, 0.2, CX+CW/2-2.4, 3.8, CZ, true);           // arm in X direction
                box(matCourtLine, 0.15, 1.2, 1.8, CX+CW/2-3.3, 3.5, CZ, false);     // backboard
                cyl(matMetal, 0.32, 0.32, 0.1, CX+CW/2-3.3, 3.05, CZ, false);       // hoop ring
                // Court fencing — con entrada en pared frontal (z negativo, hacia la casa)
                box(matFence, WT, 3, CD+2, CX-CW/2-0.5, 1.5, CZ, true);
                box(matFence, WT, 3, CD+2, CX+CW/2+0.5, 1.5, CZ, true);
                // Pared frontal dividida: gap de 6u en el centro para la entrada
                box(matFence, CW/2-4, 3, WT, CX-CW/4-2, 1.5, CZ-CD/2-0.5, true); // izquierda
                box(matFence, CW/2-4, 3, WT, CX+CW/4+2, 1.5, CZ-CD/2-0.5, true); // derecha
                // Pared trasera completa (sin entrada necesaria)
                box(matFence, CW+2, 3, WT, CX, 1.5, CZ+CD/2+0.5, true);
                // Bleachers
                // Bleachers — each slab extends from y=0 down so nothing floats
                [0,1,2].forEach(i=>{
                    const th = 0.4 + i * 1.1;
                    box(matConcrete, CW+2, th, 2.5, CX, th/2, CZ+CD/2+3.5+i*2.5, true);
                });
                // Court lights
                lamp(CX-CW/2-4, CZ-CD/2+5);
                lamp(CX+CW/2+4, CZ-CD/2+5);
                lamp(CX-CW/2-4, CZ+CD/2-5);
                lamp(CX+CW/2+4, CZ+CD/2-5);

                // ════════════════════════════════════════════════════════════
                // TENNIS COURT (behind basketball, far left)
                // ════════════════════════════════════════════════════════════
                const TX=-140, TZ=-80, TW=36, TD=18;
                plane(matTennisClay, TW+8, TD+8, TX, 0.002, TZ);
                plane(matCourtLine, TW, TD, TX, 0.002, TZ);
                plane(matCourtLine, 0.2, TD, TX, 0.002, TZ);
                plane(matCourtLine, TW, 0.2, TX, 0.002, TZ);
                plane(matCourtLine, 0.2, TD, TX-TW*0.25, 0.002, TZ);
                plane(matCourtLine, 0.2, TD, TX+TW*0.25, 0.002, TZ);
                // Net
                box(matWhite, TW, 1.0, 0.1, TX, 0.5, TZ, true);
                // Tennis lights
                lamp(TX-TW/2-3, TZ-TD/2-3);
                lamp(TX+TW/2+3, TZ-TD/2-3);
                lamp(TX-TW/2-3, TZ+TD/2+3);
                lamp(TX+TW/2+3, TZ+TD/2+3);
                // Fence — con entrada en pared frontal (z negativo)
                box(matFence, WT, 3.5, TD+10, TX-TW/2-4, 1.75, TZ, true);
                box(matFence, WT, 3.5, TD+10, TX+TW/2+4, 1.75, TZ, true);
                // Pared frontal dividida: gap de 6u centrado para entrada
                box(matFence, TW/2-1, 3.5, WT, TX-TW/4-0.5, 1.75, TZ-TD/2-4, true); // izquierda
                box(matFence, TW/2-1, 3.5, WT, TX+TW/4+0.5, 1.75, TZ-TD/2-4, true); // derecha
                // Pared trasera completa
                box(matFence, TW+10, 3.5, WT, TX, 1.75, TZ+TD/2+4, true);

                // ════════════════════════════════════════════════════════════
                // POOL + DECK AREA (right side x:80..190)
                // ════════════════════════════════════════════════════════════
                const PX=118, PZ=0, PW=55, PD=32, PDEPTH=1.5;
                plane(matTile, 110, 80, PX+8, 0.002, PZ);
                plane(matPool, PW-1, PD-1, PX, -PDEPTH+0.05, PZ);
                // Pool walls (SOLID thick)
                box(matPoolWall, PW, PDEPTH*2+0.5, WT*2, PX, -PDEPTH/2, PZ-PD/2, true);
                box(matPoolWall, PW, PDEPTH*2+0.5, WT*2, PX, -PDEPTH/2, PZ+PD/2, true);
                box(matPoolWall, WT*2, PDEPTH*2+0.5, PD, PX-PW/2, -PDEPTH/2, PZ, true);
                box(matPoolWall, WT*2, PDEPTH*2+0.5, PD, PX+PW/2, -PDEPTH/2, PZ, true);
                plane(matPoolWall, PW-1.5, PD-1.5, PX, -PDEPTH*2, PZ);
                // Pool curb
                box(matMarble, PW+3, 0.4, WT*2, PX, 0.2, PZ-PD/2-1, true);
                box(matMarble, PW+3, 0.4, WT*2, PX, 0.2, PZ+PD/2+1, true);
                box(matMarble, WT*2, 0.4, PD+3, PX-PW/2-1, 0.2, PZ, true);
                box(matMarble, WT*2, 0.4, PD+3, PX+PW/2+1, 0.2, PZ, true);
                // Loungers
                [-14,-6,6,14].forEach(lz => {
                    box(matDeck, 0.8, 0.3, 2.5, PX-PW/2-5, 0.15, lz, false);
                    box(matDeck, 0.8, 0.3, 2.5, PX+PW/2+5, 0.15, lz, false);
                    box(matWhite, 0.8, 0.06, 2.5, PX-PW/2-5, 0.32, lz); // towel
                });
                // Umbrellas
                [-12,12].forEach(uz => {
                    cyl(matMetal, 0.1, 0.1, 4, PX-PW/2-9, 2, uz, true);
                    cyl(matDeck, 3, 0.2, 0.15, PX-PW/2-9, 4, uz);
                    cyl(matMetal, 0.1, 0.1, 4, PX+PW/2+9, 2, uz, true);
                    cyl(matDeck, 3, 0.2, 0.15, PX+PW/2+9, 4, uz);
                });
                // BBQ / bar area
                box(matStucco, 10, 1.0, 2.5, PX-30, 0.5, PZ-PD/2-8, true);   // bar counter
                box(matMetalDark, 8, 0.8, 2.0, PX-30, 1.1, PZ-PD/2-8);       // grill
                box(matBlack, 1.5, 1.0, 1.5, PX-24, 0.5, PZ-PD/2-8, true);   // cabinet
                box(matBlack, 1.5, 1.0, 1.5, PX-36, 0.5, PZ-PD/2-8, true);
                // Pool bar stools
                [-3,0,3].forEach(bsx=>{
                    cyl(matMetal, 0.2, 0.2, 1.1, PX-30+bsx*2.5, 0.55, PZ-PD/2-5, true);
                    cyl(matDeck,  0.5, 0.5, 0.1, PX-30+bsx*2.5, 1.15, PZ-PD/2-5);
                });
                // Pool lighting
                const lPool = new THREE.PointLight(0x00ccff, 4, 40);
                lPool.position.set(PX, -0.5, PZ); g.add(lPool);
                const lPoolBar = new THREE.PointLight(0xffaa44, 2, 20);
                lPoolBar.position.set(PX-30, 2, PZ-PD/2-8); g.add(lPoolBar);

                // ════════════════════════════════════════════════════════════
                // HELIPAD (far right)
                // ════════════════════════════════════════════════════════════
                const HLX=160, HLZ=-60;
                plane(matHelipad, 26, 26, HLX, 0.002, HLZ);
                // H marking
                box(matHeliLine, 0.6, 0.05, 14, HLX, 0.025, HLZ, false);
                box(matHeliLine, 0.6, 0.05, 14, HLX-5, 0.025, HLZ);
                box(matHeliLine, 0.6, 0.05, 14, HLX+5, 0.025, HLZ);
                box(matHeliLine, 10.6, 0.05, 0.6, HLX, 0.025, HLZ);
                // Circle ring
                cyl(matHeliLine, 11, 11, 0.05, HLX, 0.025, HLZ);
                cyl(matHelipad,  10, 10, 0.06, HLX, 0.03, HLZ);
                // Lights
                [[10,0],[0,10],[-10,0],[0,-10],[7,7],[-7,7],[7,-7],[-7,-7]].forEach(([dx,dz])=>{
                    const ll = new THREE.PointLight(0xff4400, 1.5, 5);
                    ll.position.set(HLX+dx, 0.2, HLZ+dz); g.add(ll);
                });
                // Wind sock pole
                box(matMetal, 0.2, 5, 0.2, HLX+13, 2.5, HLZ, true);
                box(matCar2, 2, 0.6, 0.6, HLX+14, 5.2, HLZ);
                // Helipad perimeter
                box(matConcrete, 28, 0.4, WT, HLX, 0.2, HLZ-13, true);
                box(matConcrete, 28, 0.4, WT, HLX, 0.2, HLZ+13, true);
                box(matConcrete, WT, 0.4, 28, HLX-13, 0.2, HLZ, true);
                box(matConcrete, WT, 0.4, 28, HLX+13, 0.2, HLZ, true);

                // ════════════════════════════════════════════════════════════
                // GARAGE (right side, near house)
                // ════════════════════════════════════════════════════════════
                const GX=68, GZ=-22, GW=30, GD=24, GH=5;
                // Floors
                plane(matPaving, GW, GD, GX, 0.002, GZ);
                // Walls
                box(matStucco, GW, GH, WT, GX, GH/2, GZ-GD/2, true);   // front
                box(matStucco, GW, GH, WT, GX, GH/2, GZ+GD/2, true);   // back
                box(matStucco, WT, GH, GD, GX-GW/2, GH/2, GZ, true);   // left
                box(matStucco, WT, GH, GD, GX+GW/2, GH/2, GZ, true);   // right
                // Roof — sólido para no poder atravesarlo
                box(matRoof, GW+1, 0.5, GD+1, GX, GH+0.25, GZ, true);
                // Garage doors (3 bays, open/raised)
                [-9,0,9].forEach(gox=>{
                    box(matGarage, 8.5, 4, 0.2, GX+gox, GH-2, GZ-GD/2, false);
                });
                // Interior columns
                box(matStucco, 0.6, GH, 0.6, GX-GW/2+9.5, GH/2, GZ-GD/2+WT, true);
                box(matStucco, 0.6, GH, 0.6, GX+GW/2-9.5, GH/2, GZ-GD/2+WT, true);
                // Cars inside garage
                car(matCar1, GX-9, GZ);
                car(matCar3, GX+9, GZ);
                // Driveway to garage
                plane(matPaving, GW, 35, GX, 0.002, GZ+GD/2+17);
                // Parked car outside
                car(matCar2, 52, -22, 0.1);

                // ════════════════════════════════════════════════════════════
                // THE MANSION — x:-40..+40, z:-30..+30
                // ════════════════════════════════════════════════════════════

                // ── EXTERIOR WALLS (ground floor) ──────────────────────────
                // FRONT WALL (z=-30) — 3 door openings: left gap x:[-15,-9], center x:[-3,+3], right x:[+9,+15]
                box(matStucco, 24, WH, WT, -28,  WH/2, -30, true);
                box(matStucco,  6, WH, WT,  -6,  WH/2, -30, true);
                box(matStucco,  6, WH, WT,   6,  WH/2, -30, true);
                box(matStucco, 24, WH, WT,  28,  WH/2, -30, true);
                // Lintels (thick, solid — prevent jumping through)
                box(matStucco,  6, 1.4, WT, -12, WH-0.7, -30, true);
                box(matStucco,  6, 1.4, WT,   0, WH-0.7, -30, true);
                box(matStucco,  6, 1.4, WT,  12, WH-0.7, -30, true);

                // BACK WALL (z=+30)
                box(matStucco, 26, WH, WT, -22, WH/2,  30, true);
                box(matStucco,  8, WH, WT,  -3, WH/2,  30, true);
                box(matStucco,  8, WH, WT,  18, WH/2,  30, true);
                box(matStucco, 10, WH, WT,  35, WH/2,  30, true);
                box(matStucco,  6, 1.4, WT, -12, WH-0.7, 30, true);
                box(matStucco,  6, 1.4, WT,  12, WH-0.7, 30, true);
                // Window frames back wall
                box(matGlass, 6, 2.5, WT*0.2, -3, 2.5, 30);
                box(matGlass, 6, 2.5, WT*0.2, 18, 2.5, 30);

                // LEFT EXTERIOR WALL (x=-40) — passage at z:[-8,+8]
                box(matStucco, WT, WH, 22, -40, WH/2, -19, true);
                box(matStucco, WT, WH, 22, -40, WH/2,  19, true);
                box(matStucco, WT, 1.4, 16, -40, WH-0.7,  0, true);
                // Window on left wall
                box(matGlass, WT*0.2, 2, 5, -40, 2.5, -24);
                box(matGlass, WT*0.2, 2, 5, -40, 2.5,  24);

                // RIGHT EXTERIOR WALL (x=+40) — opening to pool at z:[-12,+12]
                box(matStucco, WT, WH, 18, 40, WH/2, -21, true);
                box(matStucco, WT, WH, 18, 40, WH/2,  21, true);
                box(matStucco, WT, 1.4, 24, 40, WH-0.7, 0, true);
                // Glass sliding doors on right
                box(matGlass, WT*0.2, 3.5, 10, 40, 1.75, 0);

                // ── INTERIOR PARTITION WALLS (ground floor) ─────────────────
                // Hallway walls x=-5 and x=+5
                box(matStucco, WT, WH, 22, -5, WH/2, -19, true);
                box(matStucco, WT, WH, 22, -5, WH/2,  19, true);
                box(matStucco, WT, 1.4, 16, -5, WH-0.7, 0, true);
                box(matStucco, WT, WH, 22,  5, WH/2, -19, true);
                box(matStucco, WT, WH, 22,  5, WH/2,  19, true);
                box(matStucco, WT, 1.4, 16,  5, WH-0.7, 0, true);

                // Cross wall dividing rooms (z=0 in wings)
                // Left wing: living/office divider (z=2, opening at x:[-40,-30])
                box(matStucco, 22, WH, WT, -29, WH/2, 2, true);   // x:-40..-18
                box(matStucco, 14, WH, WT,  -8, WH/2, 2, true);   // x:-15..-1
                box(matStucco, WT, 1.4, WT, -18.5, WH-0.7, 2, true); // lintel over door

                // Right wing: kitchen/dining divider (z=2)
                box(matStucco, 22, WH, WT,  29, WH/2, 2, true);
                box(matStucco, 10, WH, WT,  10, WH/2, 2, true);
                box(matStucco, WT, 1.4, WT, 14.5, WH-0.7, 2, true);

                // ── CEILINGS ─────────────────────────────────────────────────
                plane(matCeiling, 80, 60, 0, WH-0.05, 0);

                // ── COLUMNS (interior decorative+solid) ──────────────────────
                [[-34,-28],[-34,27],[34,-28],[34,27],[-16,-28],[-16,27],[16,-28],[16,27]].forEach(([cx,cz])=>{
                    box(matMarble, 1.0, WH, 1.0, cx, WH/2, cz, true);
                });

                // ── GROUND FLOOR FURNITURE ───────────────────────────────────
                // === LIVING ROOM (left wing, z:-30..+2, x:-40..-5) ===
                // Sofa set
                box(matSofa, 12, 1.0, 2.5, -22, 0.5,  -8, true);  // main sofa
                box(matSofa,  1.0, 1.2, 2.5, -28, 0.6, -8);       // left armrest
                box(matSofa,  1.0, 1.2, 2.5, -16, 0.6, -8);       // right armrest
                box(matSofaLight, 5, 1.0, 2.2, -22, 0.5, -16, true); // loveseat
                box(matTable, 5, 0.4, 3, -22, 0.8, -12, true);    // coffee table
                cyl(matTable, 0.15, 0.15, 0.8, -22, 0.4, -12);    // table leg
                // TV / entertainment center
                box(matDarkWood, 14, 1.8, 0.6, -22, 0.9, -28, true); // media console
                box(matScreen,   10, 2.2, 0.15, -22, 2.8, -27.9);    // TV screen
                // Rug
                plane(matSofa, 10, 12, -22, 0.03, -13);
                // Lamp
                cyl(matMetal, 0.08, 0.12, 2.5, -14, 1.25, -24, true);
                box(matLamp, 0.8, 0.8, 0.8, -14, 2.6, -24);
                // Bookshelf on left wall
                box(matDarkWood, 0.5, 4.0, 8, -39, 2.0, -8, true);
                [0,1,2,3].forEach(s => box(matWood, 0.4, 0.15, 7.5, -39, 0.5+s, -8));

                // === OFFICE (left wing, z:+2..+30, x:-40..-5) ===
                box(matTable, 10, 0.9, 2.5, -22, 0.45, 18, true);     // desk
                box(matDarkWood, 0.5, 0.8, 2.5, -27.5, 0.45, 18);    // desk side
                box(matScreen, 1.8, 1.2, 0.1, -22, 1.55, 16.8);      // monitor
                box(matBlack, 2.2, 0.1, 1.6, -22, 0.98, 17.5);       // keyboard area
                // Filing cabinets
                box(matMetalDark, 2, 3.5, 2, -36, 1.75, 25, true);
                box(matMetalDark, 2, 3.5, 2, -33, 1.75, 25, true);
                // Bookcase wall
                box(matDarkWood, 0.5, 4.5, 18, -39, 2.25, 16, true);
                [0,1,2,3,4].forEach(s => box(matWood, 0.4, 0.1, 17, -39, 0.4+s, 16));

                // === KITCHEN (right wing, z:-30..-2, x:+5..+40) ===
                // Island
                box(matMarble, 8, 1.1, 3.5, 22, 0.55, -16, true);
                box(matStucco, 7.5, 0.9, 3, 22, 0.5, -16);
                // Counter L-shape
                box(matMarble, 16, 1.1, 2, 32, 0.55, -28, true);    // back counter
                box(matMarble, 2, 1.1, 14, 39, 0.55, -20, true);    // side counter
                // Cabinets above
                box(matDarkWood, 16, 2, 1, 32, 3.5, -29, true);
                box(matDarkWood, 2, 2, 14, 39.5, 3.5, -20, true);
                // Oven/stove
                box(matMetalDark, 4, 1.1, 2, 24, 0.55, -28, true);
                box(matMetal, 3.5, 0.05, 1.5, 24, 1.1, -28);
                // Refrigerator
                box(matMetal, 2, 4, 2, 38, 2, -28, true);
                // Bar stools at island
                [-3,0,3].forEach(ksx=>{
                    cyl(matMetal, 0.2, 0.25, 0.9, 22+ksx*2, 0.45, -12, true);
                    cyl(matWood, 0.5, 0.5, 0.1, 22+ksx*2, 0.95, -12);
                });

                // === DINING ROOM (right wing, z:+2..+30, x:+5..+40) ===
                // Large dining table
                box(matTable, 14, 0.9, 5, 22, 0.45, 17, true);
                cyl(matTable, 0.4, 0.5, 0.9, 15, 0.45, 17, true);
                cyl(matTable, 0.4, 0.5, 0.9, 29, 0.45, 17, true);
                // Chairs
                [-4,-1.5,1.5,4].forEach(dcx=>{
                    box(matDarkWood, 1.5, 0.8, 1.5, 22+dcx*2.5, 0.4, 12, true);
                    box(matDarkWood, 1.5, 1.6, 0.3, 22+dcx*2.5, 1.0, 12.9);
                    box(matDarkWood, 1.5, 0.8, 1.5, 22+dcx*2.5, 0.4, 22, true);
                    box(matDarkWood, 1.5, 1.6, 0.3, 22+dcx*2.5, 1.0, 21.1);
                });
                // Sideboard
                box(matDarkWood, 10, 1.2, 1.5, 22, 0.6, 28, true);
                // Chandelier
                cyl(matMetal, 0.1, 0.1, 3, 22, 3.5, 17);
                const chandelier = new THREE.PointLight(0xfff0cc, 3.5, 25);
                chandelier.position.set(22, 3, 17); g.add(chandelier);

                // ── HALLWAY OBJECTS ──────────────────────────────────────────
                // Staircase
                const NSTEPS=10;
                for(let i=0;i<NSTEPS;i++){
                    const sw=10, sd=1.6, sh=WH/NSTEPS;
                    box(matMarble, sw, sh, sd, 0, (i+0.5)*sh, -8+(i+0.5)*(16/NSTEPS), true);
                }
                // Landing en la cima de la escalera — evita caerse al llegar arriba
                box(matMarble, 10, 0.5, 2, 0, WH+0.25, 8.5, true);
                // Stair railing
                box(matMetal, 0.1, WH, 0.1, -5.5, WH/2, -8);
                box(matMetal, 0.1, WH, 0.1,  5.5, WH/2, -8);
                // Entry console table
                box(matTable, 6, 1.0, 1, 0, 0.5, -29, true);
                cyl(matPlant, 0.8, 0.6, 2, 0, 1.5, -29, false);

                // ════════════════════════════════════════════════════════════
                // SECOND FLOOR  (F2=5 to F2+W2H=9.5)
                // ════════════════════════════════════════════════════════════

                // Floor slab split into 3 pieces — gap at x:-6..+6, z:-8..+10 for stairwell
                box(matIndoor, 34, 0.5, 40, -23, F2+0.25, -10, true);  // left   (x:-40..-6)
                box(matIndoor, 34, 0.5, 40,  23, F2+0.25, -10, true);  // right  (x:+6..+40)
                box(matIndoor, 12, 0.5, 22,   0, F2+0.25, -19, true);  // back-center (z:-30..-8)
                // Balcony deck
                box(matDeck, 80, 0.4, 20, 0, F2+0.2, 20, true);
                // Underside trim
                box(matCeiling, 80, 0.3, 60, 0, F2-0.15, 0);

                // Second floor walls — ventanas abiertas para disparar y salir
                // WH=5, W2H=4.5, techo en y=9.5
                // Ventanas: 10 ancho x 3.0 alto (F2+0.8 a F2+3.8)
                // Estructura por pared: franja baja (sill) + franja alta (lintel) + columnas entre ventanas

                // ── PARED FRONTAL (z=-30, mira al exterior, x: -40..+40) ──
                // sill: F2+0 a F2+0.8  →  h=0.8, cy=F2+0.4
                box(matStucco, 80, 0.8, WT,   0,  F2+0.4,    -30, true);
                // lintel: F2+3.8 a F2+4.5  →  h=0.7, cy=F2+4.15
                box(matStucco, 80, 0.7, WT,   0,  F2+4.15,   -30, true);
                // Columnas entre ventanas (ventanas en x=-25, x=0, x=+25, cada una 10 ancha)
                // Ventana izq:   x=-30..-20  → columna izq: x=-40..-30 (w=10, cx=-35)
                box(matStucco, 10, 3.0, WT, -35,  F2+2.3,    -30, true);
                // entre izq y centro: x=-20..-5 (w=15, cx=-12.5)
                box(matStucco, 15, 3.0, WT,-12.5, F2+2.3,    -30, true);
                // entre centro y der: x=+5..+20 (w=15, cx=+12.5)
                box(matStucco, 15, 3.0, WT, 12.5, F2+2.3,    -30, true);
                // columna der: x=+30..+40 (w=10, cx=+35)
                box(matStucco, 10, 3.0, WT,  35,  F2+2.3,    -30, true);
                // Ventana izq:  x=-30..-20 → ABIERTA
                // Ventana centro: x=-5..+5 → ABIERTA
                // Ventana der:  x=+20..+30 → ABIERTA

                // ── PARED IZQUIERDA (x=-40, z: -30..+10) ──
                box(matStucco, WT, 0.8, 40, -40,  F2+0.4,    -10, true);  // sill
                box(matStucco, WT, 0.7, 40, -40,  F2+4.15,   -10, true);  // lintel
                // Ventanas en z=-20 y z=0, cada una 10 ancha
                // columna sur: z=-30..-25 (d=5, cz=-27.5)
                box(matStucco, WT, 3.0,  5, -40,  F2+2.3,  -27.5, true);
                // entre z=-15 y z=+5 (d=20, cz=-5)
                box(matStucco, WT, 3.0, 20, -40,  F2+2.3,    -5,  true);
                // columna norte: z=+5..+10 (d=5, cz=+7.5)
                box(matStucco, WT, 3.0,  5, -40,  F2+2.3,    7.5, true);
                // Ventana sur:  z=-25..-15 → ABIERTA
                // Ventana norte: z=-5..+5  → ABIERTA

                // ── PARED DERECHA (x=+40, z: -30..+10) ──
                box(matStucco, WT, 0.8, 40,  40,  F2+0.4,    -10, true);  // sill
                box(matStucco, WT, 0.7, 40,  40,  F2+4.15,   -10, true);  // lintel
                // columna sur: z=-30..-25
                box(matStucco, WT, 3.0,  5,  40,  F2+2.3,  -27.5, true);
                // entre z=-15 y z=+5
                box(matStucco, WT, 3.0, 20,  40,  F2+2.3,    -5,  true);
                // columna norte: z=+5..+10
                box(matStucco, WT, 3.0,  5,  40,  F2+2.3,    7.5, true);
                // Ventana sur:  z=-25..-15 → ABIERTA
                // Ventana norte: z=-5..+5  → ABIERTA

                box(matStucco, 80, W2H, WT,  0, F2+W2H/2,  10, true);   // back of rooms (da al balcón)

                // Interior walls 2F — dividing into 3 bedrooms
                box(matStucco, WT, W2H, 40, -20, F2+W2H/2, -10, true);  // bedroom divider
                box(matStucco, WT, W2H, 40,  20, F2+W2H/2, -10, true);
                // Door openings (leave gaps — just lintels)
                box(matStucco, WT, 1.4, 6, -20, F2+W2H-0.7, -7, true);
                box(matStucco, WT, 1.4, 6,  20, F2+W2H-0.7, -7, true);

                // Balcony railings
                box(matStucco, 80, 1.2, WT, 0, F2+0.6, 30, true);
                box(matStucco, WT, 1.2, 20, -40, F2+0.6, 20, true);
                box(matStucco, WT, 1.2, 20,  40, F2+0.6, 20, true);
                // Balcony access wall (back of room)
                box(matStucco, 80, W2H, WT, 0, F2+W2H/2, 10, true);
                // Balcony door opening
                box(matStucco, WT, 1.4, 8, 0, F2+W2H-0.7, 10, true);  // lintel
                box(matGlass, 6, 3, WT*0.2, 0, F2+1.5, 10);

                // Roof — solid: impide atravesar el techo desde abajo
                box(matRoof, 82, 0.5, 42, 0, F2+W2H+0.25, -10, true);

                // ── BEDROOM FURNITURE (2F) ───────────────────────────────────
                // Master bedroom (center, x:-20..+20)
                box(matSofaLight, 12, 0.8, 7, 0, F2+0.65, -22, true);   // king bed
                box(matWhite, 11, 0.5, 6.5, 0, F2+1.1, -22);            // mattress
                box(matDarkWood, 14, 1.4, 1.5, 0, F2+0.7, -28, true);   // headboard
                box(matDarkWood, 2, 0.8, 1.5, -7.5, F2+0.4, -22, true); // nightstand L
                box(matDarkWood, 2, 0.8, 1.5,  7.5, F2+0.4, -22, true); // nightstand R
                box(matLamp, 0.5, 0.5, 0.5, -7.5, F2+1.05, -22);
                box(matLamp, 0.5, 0.5, 0.5,  7.5, F2+1.05, -22);
                // Walk-in closet hint
                box(matDarkWood, 8, 3.5, 0.5, 0, F2+1.75, -29.7, true);

                // Left bedroom (x:-40..-20)
                box(matSofa, 8, 0.7, 5.5, -30, F2+0.6, -22, true);  // bed
                box(matWhite, 7.5, 0.4, 5, -30, F2+0.95, -22);
                box(matDarkWood, 9, 1.2, 1.2, -30, F2+0.6, -28, true);
                box(matDarkWood, 6, 3.5, 0.5, -30, F2+1.75, -14, true); // shelf

                // Right bedroom (x:+20..+40)
                box(matSofa, 8, 0.7, 5.5, 30, F2+0.6, -22, true);
                box(matWhite, 7.5, 0.4, 5, 30, F2+0.95, -22);
                box(matDarkWood, 9, 1.2, 1.2, 30, F2+0.6, -28, true);

                // ── SECOND FLOOR CEILING ─────────────────────────────────────
                plane(matRoof, 80, 40, 0, F2+W2H, -10);

                // ════════════════════════════════════════════════════════════
                // OUTDOOR COVER OBJECTS (tactical cover between zones)
                // ════════════════════════════════════════════════════════════
                // Left approach (house ↔ court corridor)
                box(matLow, 8, 1.4, WT*2, -58, 0.7, -18, true);
                box(matLow, 8, 1.4, WT*2, -58, 0.7,  18, true);
                box(matLow, WT*2, 1.4, 10, -58, 0.7,  0, true);
                // Dumpster pair
                box(matMetalDark, 3, 1.5, 2, -55, 0.75, -28, true);
                box(matMetalDark, 3, 1.5, 2, -55, 0.75,  28, true);
                // Crates left approach
                [[-50,-22,-14],[-50,-22,14],[-50,-26,-20],[-50,-26,20]].forEach(([cx,cz1,cz2])=>{
                    box(matWood, 2, 2, 2, cz1, 1.0, cz2, true);
                });
                // Right approach (house ↔ pool)
                box(matDeck, 8, 1.2, WT*2, 55, 0.6, -14, true);
                box(matDeck, 8, 1.2, WT*2, 55, 0.6,  14, true);
                box(matDeck, WT*2, 1.2, 10, 55, 0.6,  0, true);
                // Planters along right approach
                planter(52, -28, 1.2);
                planter(52,  28, 1.2);
                planter(58, -8, 1);
                planter(58,  8, 1);

                // Front of house planters
                planter(-42, -26, 1.2);
                planter(-42,  26, 1.2);
                planter(-48, -10, 1);
                planter(-48,  10, 1);
                planter(42, -26, 1.2);
                planter(42,  26, 1.2);

                // ════════════════════════════════════════════════════════════
                // PERIMETER WALLS + HEDGES
                // ════════════════════════════════════════════════════════════
                const HH=3.5;
                // Main perimeter
                box(matBrick,  380, HH, WT*2, 0, HH/2, -192, true);
                box(matBrick,  380, HH, WT*2, 0, HH/2,  192, true);
                box(matBrick,  WT*2, HH, 388, -192, HH/2, 2, true);
                box(matBrick,  WT*2, HH, 388,  192, HH/2, 2, true);
                // Hedge rows (as corridors between zones)
                box(matHedge, WT*2, HH, 80, -52, HH/2,  50, true);
                box(matHedge, WT*2, HH, 80, -52, HH/2, -50, true);
                box(matHedgeLight, WT*2, 2.5, 50, 50, 1.25, 55, true);
                box(matHedgeLight, WT*2, 2.5, 50, 50, 1.25,-55, true);
                // Hedge along driveway
                box(matHedge, WT*2, 2, 60, -82, 1, 35, true);
                box(matHedge, WT*2, 2, 60, -82, 1,-35, true);

                // ════════════════════════════════════════════════════════════
                // LIGHTS
                // ════════════════════════════════════════════════════════════
                // Indoor ground floor — more lights, higher intensity
                [[-22,3.5,-20],[22,3.5,-20],[-22,3.5,14],[22,3.5,14],
                 [0,3.5,-22],[0,3.5,22],[-35,3.5,-10],[35,3.5,-10],
                 [-22,3.5,-5],[22,3.5,-5],[0,3.5,5]].forEach(([lx,ly,lz])=>{
                    const l = new THREE.PointLight(0xffdd99, 3.5, 28);
                    l.position.set(lx,ly,lz); g.add(l);
                });
                // Second floor bedroom lights
                [-25,0,25].forEach(bx=>{
                    const l = new THREE.PointLight(0xffeebb, 3.0, 24);
                    l.position.set(bx, F2+3.5, -22); g.add(l);
                });
                // Second floor hallway / balcony lights
                [-20,0,20].forEach(bx=>{
                    const l = new THREE.PointLight(0xfff0cc, 2.5, 20);
                    l.position.set(bx, F2+3.0, -5); g.add(l);
                });
                // Pathway lamps
                lamp(-62, -32); lamp(-62, 0); lamp(-62, 32);
                lamp(-30, -50); lamp( 30, -50);
                lamp(60,  -55); lamp(60, 55);

                // ════════════════════════════════════════════════════════════
                // PLATFORMS (physics)
                // ════════════════════════════════════════════════════════════
                if (!window._mapPlatforms) window._mapPlatforms = {};
                window._mapPlatforms['raid'] = [
                    { x:-23, z:-10, w:34, d:40, y:WH+0.5 },    // 2F left  (x:-40..-6)
                    { x: 23, z:-10, w:34, d:40, y:WH+0.5 },    // 2F right (x:+6..+40)
                    { x:0,   z:-19, w:12, d:22, y:WH+0.5 },    // 2F back-center (z:-30..-8)
                    { x:0,   z:20,  w:80, d:20, y:WH+0.4 },    // balcony
                    // Escalera: rampa extendida a z=9 con y1=WH+0.5 para que conecte al nivel del piso 2
                    { x:0, z:0.5, w:10, d:17, ramp:{ z0:-8, z1:9, y0:0, y1:WH+0.5 } },
                    // Landing extra en el tope para que no se caiga
                    { x:0, z:9, w:10, d:2, y:WH+0.5 },
                    { x:GX,  z:GZ,  w:GW, d:GD, y:0.05 },      // garage floor
                    { x:PX,  z:PZ,  w:PW+8, d:PD+12, y:0.02 }, // pool deck
                ];

                // ════════════════════════════════════════════════════════════
                // MATERIALES EXTRA
                // ════════════════════════════════════════════════════════════
                const matBurnt     = new THREE.MeshStandardMaterial({ color:0x1a1008, roughness:1.0, metalness:0.15 });
                const matRust      = new THREE.MeshStandardMaterial({ color:0x6b2c0a, roughness:0.98, metalness:0.30 });
                const matBus       = new THREE.MeshStandardMaterial({ color:0xd4a800, roughness:0.40, metalness:0.30 });
                const matBusWhite  = new THREE.MeshStandardMaterial({ color:0xeeeeee, roughness:0.60, metalness:0.10 });
                const matCar4      = new THREE.MeshStandardMaterial({ color:0x1c6e2e, roughness:0.38, metalness:0.65 });
                const matCar5      = new THREE.MeshStandardMaterial({ color:0xc8a020, roughness:0.40, metalness:0.60 });
                const matCar6      = new THREE.MeshStandardMaterial({ color:0x2a2a50, roughness:0.38, metalness:0.70 });
                const matGrassTuft = new THREE.MeshStandardMaterial({ color:0x3b8c3b, roughness:1.0, metalness:0.0, side:THREE.DoubleSide });
                const matGrassPale = new THREE.MeshStandardMaterial({ color:0x3b8c3b, roughness:1.0, metalness:0.0, side:THREE.DoubleSide });
                const matContainer = new THREE.MeshStandardMaterial({ color:0x8b3a18, roughness:0.75, metalness:0.40 });
                const matBarrel    = new THREE.MeshStandardMaterial({ color:0x2a2a2a, roughness:0.70, metalness:0.50 });
                const matDebris    = new THREE.MeshStandardMaterial({ color:0x707060, roughness:0.98, metalness:0.00 });
                const matBroken    = new THREE.MeshStandardMaterial({ color:0x404040, roughness:0.95, metalness:0.10, emissive:0x100800, emissiveIntensity:0.3 });
                const matEmber     = new THREE.MeshStandardMaterial({ color:0xff3300, roughness:0.7, metalness:0.0, emissive:0xff2200, emissiveIntensity:1.5 });

                // ════════════════════════════════════════════════════════════
                // HELPER: COLECTIVO / BUS
                // ════════════════════════════════════════════════════════════
                function bus(mat, x, z, ry=0, burnt=false) {
                    const bg = new THREE.Group();
                    bg.position.set(x, 0, z);
                    bg.rotation.y = ry;
                    const bMat = burnt ? matBurnt : mat;
                    // Carrocería
                    const body = new THREE.Mesh(new THREE.BoxGeometry(3.2, 3.2, 12), bMat);
                    body.position.y = 1.6; body.castShadow=true; body.receiveShadow=true;
                    body.userData.isSolid = true; bg.add(body);
                    // Techo redondeado (caja plana encima)
                    const roof = new THREE.Mesh(new THREE.BoxGeometry(3.0, 0.6, 11.8), burnt ? matBurnt : matBusWhite);
                    roof.position.y = 3.5; roof.castShadow=true; bg.add(roof);
                    // Ventanas laterales (decorativas)
                    if (!burnt) {
                        [-3.5,-1.5,0.5,2.5].forEach(wx=>{
                            const wm = new THREE.Mesh(new THREE.BoxGeometry(0.1,1.2,1.4), matGlass);
                            wm.position.set(1.65, 2.2, wx); bg.add(wm);
                            const wm2 = wm.clone(); wm2.position.x = -1.65; bg.add(wm2);
                        });
                    }
                    // Frente / fondo
                    const front = new THREE.Mesh(new THREE.BoxGeometry(3.2,3.2,0.15), burnt ? matBurnt : bMat);
                    front.position.set(0,1.6,-6.1); front.castShadow=true; bg.add(front);
                    // Ruedas
                    const wMat = new THREE.MeshStandardMaterial({color:burnt?0x0a0a0a:0x111111, roughness:0.9});
                    [[-1.7,0.55,-4.0],[1.7,0.55,-4.0],[-1.7,0.55,4.0],[1.7,0.55,4.0],
                     [-1.7,0.55,-1.5],[1.7,0.55,-1.5]].forEach(([wx,wy,wz])=>{
                        const w = new THREE.Mesh(new THREE.CylinderGeometry(0.55,0.55,0.4,12), wMat);
                        w.rotation.z = Math.PI/2; w.position.set(wx,wy,wz); bg.add(w);
                    });
                    g.add(bg);
                    return bg;
                }

                // HELPER: COCHE VOLCADO / EXPLOTADO
                function wreck(mat, x, z, ry=0, tiltX=0, tiltZ=0) {
                    const wg = new THREE.Group();
                    wg.position.set(x, 0.55, z);
                    wg.rotation.set(tiltX, ry, tiltZ);
                    // Carrocería quemada
                    const body = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.9, 4.2), matBurnt);
                    body.position.y = 0; body.castShadow=true; body.receiveShadow=true;
                    body.userData.isSolid = true; wg.add(body);
                    const cab = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.8, 2.2), matBurnt);
                    cab.position.set(0, 0.85, -0.3); wg.add(cab);
                    // Ruedas rotas (algunas caídas)
                    const wMat = new THREE.MeshStandardMaterial({color:0x0a0a0a, roughness:0.9});
                    [[-1.15,0.0,-1.5],[1.15,0.0,-1.5],[-1.15,0.0,1.5],[1.15,0.0,1.5]].forEach(([wx,wy,wz],idx)=>{
                        const w = new THREE.Mesh(new THREE.CylinderGeometry(0.42,0.42,0.3,10), wMat);
                        w.rotation.z = Math.PI/2;
                        if (idx===2) { w.rotation.z = Math.PI/2+0.6; } // rueda torcida
                        w.position.set(wx,wy,wz); wg.add(w);
                    });
                    // Brasa / fuego (punto de luz + mesh emisivo)
                    const ember = new THREE.Mesh(new THREE.SphereGeometry(0.3,6,4), matEmber);
                    ember.position.set(0, 1.2, 0); wg.add(ember);
                    const fl = new THREE.PointLight(0xff4400, 3.0, 10);
                    fl.position.set(x, 2.0, z); g.add(fl);
                    g.add(wg);
                }

                // HELPER: CONTENEDOR
                function container(x, z, ry=0) {
                    const cg = new THREE.Group();
                    cg.position.set(x, 0, z);
                    cg.rotation.y = ry;
                    const body = new THREE.Mesh(new THREE.BoxGeometry(2.6, 2.6, 6.1), matContainer);
                    body.position.y = 1.3; body.castShadow=true; body.receiveShadow=true;
                    body.userData.isSolid = true; cg.add(body);
                    // Ribs metálicos
                    [-2.4,-0.8,0.8,2.4].forEach(rx=>{
                        const rib = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2.5, 0.12), matMetal);
                        rib.position.set(rx, 1.3, 0); cg.add(rib);
                    });
                    // Puerta trasera
                    const door = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 0.12), matMetalDark);
                    door.position.set(0, 1.3, 3.1); cg.add(door);
                    g.add(cg);
                }

                // HELPER: BARRIL
                function barrel(x, z, onSide=false) {
                    const b = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.9, 10), matBarrel);
                    b.position.set(x, onSide ? 0.35 : 0.45, z);
                    if (onSide) b.rotation.z = Math.PI/2;
                    b.castShadow=true; b.userData.isSolid=true; g.add(b);
                }

                // ════════════════════════════════════════════════════════════
                // RELLENO 200x200 — OPTIMIZADO
                // Sin PointLight por objeto, geometrías mergeadas / instanced
                // ════════════════════════════════════════════════════════════

                // ── MATERIALES EXTRA ─────────────────────────────────────
                const matAsphalt   = new THREE.MeshStandardMaterial({ color:0x3b8c3b, roughness:1.00 }); // outer grass
                const matSidewalk  = new THREE.MeshStandardMaterial({ color:0x3b8c3b, roughness:0.98 }); // outer grass
                const matBuilding  = new THREE.MeshStandardMaterial({ color:0x7a6e60, roughness:0.92 });
                const matBuilding2 = new THREE.MeshStandardMaterial({ color:0x6a5e52, roughness:0.90 });
                const matBuilding3 = new THREE.MeshStandardMaterial({ color:0x5a5248, roughness:0.88 });
                const matWarehouse = new THREE.MeshStandardMaterial({ color:0x8a7458, roughness:0.93 });
                const matMetal2    = new THREE.MeshStandardMaterial({ color:0x5a6060, roughness:0.50, metalness:0.75 });
                const matDirt      = new THREE.MeshStandardMaterial({ color:0x3b8c3b, roughness:1.00 });
                const matRubble    = new THREE.MeshStandardMaterial({ color:0x706050, roughness:0.98 });
                const matSandbag   = new THREE.MeshStandardMaterial({ color:0xc8a864, roughness:0.99 });
                const matFuelTank  = new THREE.MeshStandardMaterial({ color:0x224422, roughness:0.65, metalness:0.55 });
                const matCar7      = new THREE.MeshStandardMaterial({ color:0x444488, roughness:0.38, metalness:0.68 });
                const matCar8      = new THREE.MeshStandardMaterial({ color:0x886622, roughness:0.40, metalness:0.60 });

                // ── HELPERS ──────────────────────────────────────────────
                // prop sin shadow ni isSolid (puro visual)
                function propBox(mat, w, h, d, x, y, z, ry=0) {
                    const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
                    m.position.set(x,y,z); if(ry) m.rotation.y=ry;
                    m.castShadow=true; m.receiveShadow=true;
                    g.add(m); return m;
                }
                // prop sólida, sin shadow (ahorra GPU)
                function propSolid(mat, w, h, d, x, y, z, ry=0) {
                    const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
                    m.position.set(x,y,z); if(ry) m.rotation.y=ry;
                    m.castShadow=true; m.receiveShadow=true;
                    m.userData.isSolid=true; g.add(m); return m;
                }
                // edificio: cuerpo + techo, sin ventanas → pocos drawcalls
                function bldg(mat, w, h, d, x, z, ry=0) {
                    propSolid(mat, w, h, d, x, h/2, z, ry);
                    propBox(matRubble, w+0.2, 0.4, d+0.2, x, h+0.2, z, ry);
                }
                // wreck barato: 2 cajas + brasa emisiva
                function cheapWreck(mat, x, z, ry=0) {
                    const m1=new THREE.Mesh(new THREE.BoxGeometry(2.0,1.0,4.2),matBurnt);
                    m1.position.set(x,0.5,z); m1.rotation.y=ry; m1.castShadow=true; m1.receiveShadow=true; m1.userData.isSolid=true; g.add(m1);
                    const m2=new THREE.Mesh(new THREE.BoxGeometry(1.8,0.8,2.0),matBurnt);
                    m2.position.set(x,1.35,z); m2.rotation.y=ry; m2.castShadow=true; g.add(m2);
                    const e=new THREE.Mesh(new THREE.SphereGeometry(0.25,5,3),matEmber);
                    e.position.set(x,1.2,z); g.add(e);
                }
                // bus barato: 2 cajas
                function cheapBus(x, z, ry=0, burnt=false) {
                    const bm=burnt?matBurnt:matBus;
                    const b=new THREE.Mesh(new THREE.BoxGeometry(3.2,3.2,12),bm);
                    b.position.set(x,1.6,z); b.rotation.y=ry; b.castShadow=true; b.receiveShadow=true; b.userData.isSolid=true; g.add(b);
                    const r=new THREE.Mesh(new THREE.BoxGeometry(3.0,0.5,11.8),burnt?matBurnt:matAsphalt);
                    r.position.set(x,3.45,z); r.rotation.y=ry; r.castShadow=true; g.add(r);
                    if(burnt){const e=new THREE.Mesh(new THREE.SphereGeometry(0.3,5,3),matEmber);e.position.set(x,2.5,z);g.add(e);}
                }
                // auto barato: 2 cajas
                function cheapCar(mat, x, z, ry=0) {
                    const b=new THREE.Mesh(new THREE.BoxGeometry(2.1,1.4,4.4),mat);
                    b.position.set(x,0.7,z); b.rotation.y=ry; b.castShadow=true; b.receiveShadow=true; b.userData.isSolid=true; g.add(b);
                    const c=new THREE.Mesh(new THREE.BoxGeometry(1.9,1.0,2.4),mat);
                    c.position.set(x,1.9,z); c.rotation.y=ry; c.castShadow=true; g.add(c);
                }
                // contenedor: 1 caja sólida
                function cheapContainer(x, z, ry=0) { propSolid(matContainer,2.6,2.6,6.1,x,1.3,z,ry); }
                // sandbag: 1 caja sólida
                function cheapSandbags(x, z, w, ry=0) { propSolid(matSandbag,w,0.9,0.55,x,0.45,z,ry); }
                // poste: solo geometría, sin luz
                function cheapPole(x, z) {
                    propBox(matMetal,0.18,7,0.18,x,3.5,z);
                    propBox(matMetal,2.5,0.12,0.12,x+1.0,7.0,z);
                }
                // pasto instanced: 1 drawcall por patch
                function grassPatch(cx, cz, count, radius, scale=1.0) {
                    const geo=new THREE.PlaneGeometry(1,1);
                    const mat=Math.random()>0.5?matGrassTuft:matGrassPale;
                    const im=new THREE.InstancedMesh(geo,mat,count*2);
                    im.instanceMatrix.setUsage(THREE.StaticDrawUsage);
                    const dummy=new THREE.Object3D(); let idx=0;
                    for(let i=0;i<count;i++){
                        const a=Math.random()*Math.PI*2, r=Math.random()*radius;
                        const tx=cx+Math.cos(a)*r, tz=cz+Math.sin(a)*r;
                        const h=scale*(0.2+Math.random()*0.3), w=scale*(0.5+Math.random()*0.5);
                        dummy.position.set(tx,h/2,tz); dummy.rotation.set(0,Math.random()*Math.PI,0);
                        dummy.scale.set(w,h,1); dummy.updateMatrix(); im.setMatrixAt(idx++,dummy.matrix);
                        dummy.rotation.y+=Math.PI/2; dummy.updateMatrix(); im.setMatrixAt(idx++,dummy.matrix);
                    }
                    im.count=idx; im.instanceMatrix.needsUpdate=true; g.add(im);
                }

                // ════════════════════════════════════════════════════════════
                // PISOS (planes — baratos)
                // ════════════════════════════════════════════════════════════
                plane(matAsphalt, 390,120,  0, 0.005,-130);
                plane(matDirt,    390, 50,  0, 0.003,-175);
                plane(matAsphalt, 390, 90,  0, 0.005, 115);
                plane(matDirt,    200, 40,-95, 0.003, 165);
                plane(matGrass,   200, 40, 95, 0.003, 165);
                plane(matAsphalt,  80,390,145, 0.005,   0);
                plane(matGrass,    90,200,-155,0.004,   0);
                plane(matDirt,     30,390,-185,0.003,   0);
                plane(matAsphalt, 390, 14,  0, 0.006, -70);
                plane(matAsphalt, 390, 14,  0, 0.006,  70);
                plane(matSidewalk,390,  3,  0, 0.009, -77);
                plane(matSidewalk,390,  3,  0, 0.009,  77);
                plane(matSidewalk,390,  3,  0, 0.009, -63);
                plane(matSidewalk,390,  3,  0, 0.009,  63);

                // ════════════════════════════════════════════════════════════
                // EDIFICIOS (cuerpo + techo, sin ventanas)
                // ════════════════════════════════════════════════════════════
                // Norte fila 1 (z=-100)
                const _mB=[matBuilding,matBuilding2,matBuilding3,matWarehouse];
                [[-160,10,14],[-140,8,12],[-120,11,14],[-100,7,10],[-170,6,16],
                 [-40,9,12],[-20,7,10],[0,10,14],[20,8,12],[40,10,12],
                 [80,9,14],[100,11,14],[120,8,12],[140,6,14],[160,9,12]
                ].forEach(([bx,bh,bd],i)=> bldg(_mB[i%4],16,bh,bd,bx,-100));
                // Norte fila 2 (z=-155)
                [[-150,6,10],[-120,8,12],[-80,7,10],[-40,9,12],[0,5,14],
                 [40,8,12],[80,6,10],[120,9,12],[160,7,10]
                ].forEach(([bx,bh,bd],i)=> bldg(_mB[i%4],14,bh,bd,bx,-155));
                // Sur (z=90 y z=155)
                [[-150,7,22],[-110,7,20],[-70,8,22],[-30,6,16],[0,5,14],
                 [40,6,16],[80,7,20],[110,7,20],[140,6,22]
                ].forEach(([bx,bh,bd],i)=> bldg(i%3===0?matWarehouse:matBuilding2,20,bh,bd,bx,90));
                [[-160,6,18],[-120,5,18],[-70,7,14],[-30,8,14],[20,6,14],
                 [80,5,18],[130,6,18],[170,7,12]
                ].forEach(([bx,bh,bd],i)=> bldg(i%2===0?matWarehouse:matBuilding3,18,bh,bd,bx,155));
                // Este
                [[80,30,9,16],[80,-30,7,14],[80,65,11,14],[80,-65,8,12],
                 [120,20,8,14],[120,-20,6,12],[120,55,10,14],[120,-55,7,12],
                 [165,25,8,12],[165,-25,9,14],[165,60,7,12],[165,-60,5,16]
                ].forEach(([bx,bz,bh,bd])=> bldg(matBuilding2,14,bh,bd,bx,bz,Math.PI/2));
                // Oeste
                [[-155,130,6,18],[-155,-130,5,16],[-155,50,5,12],[-155,-50,5,10],
                 [-185,100,4,14],[-185,-100,4,14],[-185,0,5,16]
                ].forEach(([bx,bz,bh,bd])=> bldg(matWarehouse,20,bh,bd,bx,bz));

                // ════════════════════════════════════════════════════════════
                // RUINAS
                // ════════════════════════════════════════════════════════════
                [[-50,-85,10,4,1],[-55,-89,1,4,8],[30,-85,8,2,1],[170,-90,6,5,1],[174,-93,1,3,6],
                 [40,77,12,3,1],[45,81,1,5,9],[-60,77,8,2,1],[150,77,10,3,1],
                 [-130,15,10,5,1],[-134,18,1,5,8],[-130,-15,8,3,1],
                 [-170,30,12,4,1],[-170,-30,10,6,1]
                ].forEach(([rx,rz,rw,rh,rd])=> propSolid(matRubble,rw,rh,rd,rx,rh/2,rz));

                // ════════════════════════════════════════════════════════════
                // VEHÍCULOS
                // ════════════════════════════════════════════════════════════
                // Wrecks
                [[-155,-85,0.5],[-90,-82,2.0],[50,-85,1.0],[130,-82,0.8],
                 [-140,80,1.0],[-40,80,2.5],[80,80,0.5],[170,78,1.8],
                 [-75,-70,0.2],[-30,-70,2.8],[80,70,1.1],[140,-70,0.6],
                 [80,42,0.8],[80,-42,2.0],[-165,60,1.4],[-165,-60,0.6]
                ].forEach(([wx,wz,wr],i)=> cheapWreck(_mB[i%4],wx,wz,wr));
                // Buses
                [[-105,-40,Math.PI/2,false],[-152,55,0.35,true],[-60,-155,0,true],
                 [80,-155,Math.PI/2,true],[90,0,Math.PI/2,false],[-90,100,Math.PI/2,false],
                 [50,155,0,true],[-20,70,0,false],[60,-70,0,true]
                ].forEach(([bx,bz,br,bb])=> cheapBus(bx,bz,br,bb));
                // Autos
                [[matCar7,-40,-82,0.2],[matCar8,-5,-82,3.0],[matCar4,160,-82,0.4],
                 [matCar7,-160,78,0.2],[matCar8,10,78,-0.1],[matCar4,140,78,0.3],
                 [matCar7,118,35,Math.PI/2],[matCar4,118,-35,Math.PI/2],
                 [matCar8,165,10,Math.PI/2],[matCar4,-110,35,0.3],[matCar5,-110,-35,-0.2],
                 [matCar7,-100,-70,0.1],[matCar4,50,70,-0.1],[matCar8,-50,70,3.1]
                ].forEach(([cm,cx,cz,cry])=> cheapCar(cm,cx,cz,cry));

                // ════════════════════════════════════════════════════════════
                // CONTENEDORES
                // ════════════════════════════════════════════════════════════
                [[-88,-55,0],[-88,55,0],[-88,-62,0],
                 [-140,80,0.2],[-140,88,0.2],[-140,-80,-0.2],[-140,-88,-0.2],
                 [-155,118,0],[-155,125,0],[0,118,Math.PI/2],[8,118,Math.PI/2],
                 [125,0,Math.PI/2],[125,8,Math.PI/2],[125,-8,Math.PI/2],
                 [170,40,0],[170,-40,0],[-85,-130,0.4],[90,-130,-0.2]
                ].forEach(([cx,cz,cry])=> cheapContainer(cx,cz,cry));

                // ════════════════════════════════════════════════════════════
                // TANQUES + TORRES DE AGUA
                // ════════════════════════════════════════════════════════════
                [[-180,100],[-180,108],[-175,104],[160,100],[160,108],[175,0],[175,8],[-185,30],[-185,-30]
                ].forEach(([tx,tz])=> cyl(matFuelTank,1.8,1.8,3.5,tx,1.75,tz,true));
                // torres
                [[-150,0],[-5,-170],[170,-150]].forEach(([tx,tz])=>{
                    [[-1.5,-1.5],[1.5,-1.5],[-1.5,1.5],[1.5,1.5]].forEach(([lx,lz])=>
                        propSolid(matMetal,0.25,8,0.25,tx+lx,4,tz+lz));
                    cyl(matMetal2,3.5,3.0,5,tx,10.5,tz,true);
                    propBox(matRoof,7.4,2.0,7.4,tx,14,tz);
                });

                // ════════════════════════════════════════════════════════════
                // POSTES (sin luz)
                // ════════════════════════════════════════════════════════════
                [-160,-120,-80,-40,0,40,80,120,160].forEach(px=>{
                    cheapPole(px,-125); cheapPole(px,-180);
                    cheapPole(px, 95);  cheapPole(px, 180);
                });
                [-60,-20,20,60].forEach(pz=>{
                    cheapPole(-170,pz); cheapPole(-140,pz); cheapPole(-110,pz);
                    cheapPole(115,pz);  cheapPole(175,pz);
                });
                [-180,-140,-100,-60,-20,20,60,100,140,180].forEach(px=>{
                    cheapPole(px,-74); cheapPole(px,74);
                });

                // ════════════════════════════════════════════════════════════
                // SACOS DE ARENA + MUROS DE COBERTURA
                // ════════════════════════════════════════════════════════════
                [[-30,-78,6,0],[20,-78,6,0],[-80,-82,4,Math.PI/2],[100,-82,4,Math.PI/2],
                 [-20,78,6,0],[30,78,6,0],[120,82,4,Math.PI/2],
                 [0,-68,4,0],[0,68,4,0],[-72,0,4,Math.PI/2],[72,0,4,Math.PI/2]
                ].forEach(([sx,sz,sw,sry])=> cheapSandbags(sx,sz,sw,sry));
                [[-65,-58,8,1,0.8],[-65,58,8,1,0.8],[-65,-10,0.8,1,6],[-65,10,0.8,1,6],
                 [68,8,0.8,1.2,8],[68,-8,0.8,1.2,8],[100,-50,6,1.2,0.8],[100,50,6,1.2,0.8],
                 [140,-52,8,1.2,0.8],[140,52,8,1.2,0.8],[-70,-50,4,1,0.8],[-70,50,4,1,0.8]
                ].forEach(([cx,cz,cw,ch,cd])=> propSolid(matConcrete,cw,ch,cd,cx,ch/2,cz));

                // ════════════════════════════════════════════════════════════
                // BARRILES — InstancedMesh (1 drawcall)
                // ════════════════════════════════════════════════════════════
                {
                    const bGeo=new THREE.CylinderGeometry(0.35,0.35,0.9,8);
                    const bIM=new THREE.InstancedMesh(bGeo,matBarrel,50);
                    bIM.instanceMatrix.setUsage(THREE.StaticDrawUsage);
                    const dum=new THREE.Object3D();
                    [[-55,-42],[-55,42],[-48,-38],[-48,38],[-120,0],[-122,-8],[-118,8],
                     [130,-55],[135,-58],[132,-62],[-168,-5],[-172,5],[-166,12],
                     [-100,80],[-98,83],[-95,80],[110,80],[113,83],[110,77],
                     [-145,10],[-155,14],[-165,10],[-145,-10],[-155,-14],[-165,-10],
                     [-55,-120],[-52,-123],[70,-120],[73,-123]
                    ].forEach(([bx,bz],i)=>{
                        const s=i%4===0; dum.position.set(bx,s?0.35:0.45,bz);
                        dum.rotation.set(0,Math.random()*Math.PI,s?Math.PI/2:0);
                        dum.scale.setScalar(1); dum.updateMatrix(); bIM.setMatrixAt(i,dum.matrix);
                    });
                    bIM.count=29; bIM.instanceMatrix.needsUpdate=true; g.add(bIM);
                }

                // ════════════════════════════════════════════════════════════
                // PASTO — InstancedMesh por zona (pocos drawcalls)
                // ════════════════════════════════════════════════════════════
                // Pasto instanced — zonas seguras sin superposición con pisos/edificios
                // Oeste lejano (x≤-100, lejos de basketball x=-130 y mansion x=-40)
                grassPatch(-165,  0,  55, 28, 0.9);  // extremo oeste, sin tocar canchas
                grassPatch(-155, 70,  30, 22, 0.8);  // esquina NO
                grassPatch(-155,-70,  30, 22, 0.8);  // esquina SO
                // Norte profundo (z≤-85, lejos de la mansion z=-30)
                grassPatch(   0,-140, 60, 50, 0.8);
                grassPatch(-100,-140, 40, 40, 0.8);
                grassPatch( 100,-140, 40, 40, 0.8);
                // Sur profundo (z≥+85, lejos de la back wall z=+30)
                grassPatch(   0, 140, 60, 50, 0.8);
                grassPatch(-100, 140, 40, 40, 0.8);
                grassPatch( 100, 140, 40, 40, 0.8);
                // Back-right (helipad zone tiene concreto, pasto solo en bordes)
                grassPatch( 185, 120, 30, 15, 1.0);
                grassPatch( 185,-120, 30, 15, 1.0);

                // ════════════════════════════════════════════════════════════
                // LUCES DE ZONA — solo 8 PointLight para TODO el relleno
                // ════════════════════════════════════════════════════════════
                [[0,-130,0xffe8b0,4,120],[0,130,0xffe8b0,4,120],
                 [150,0,0xffe8b0,3,100],[-160,0,0xffdd90,3,100],
                 [-80,-70,0xffe8b0,3,80],[80,70,0xffe8b0,3,80],
                 [-150,-100,0xff2200,2,60],[130,90,0xff2200,2,60]
                ].forEach(([lx,lz,lc,li,lr])=>{
                    const al=new THREE.PointLight(lc,li,lr);
                    al.position.set(lx,8,lz); g.add(al);
                });

                return g;
            }




            function createTree(x, z) {
                const h = getTerrainHeight(x, z);
                const g = new THREE.Group();
                g.position.set(x, h, z);

                const t = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, 3, 6), new THREE.MeshStandardMaterial({
                    color: 0x4d2926
                }));
                t.position.y = 1.5;
                t.castShadow = true;
                t.userData.isTree = true;

                const l = new THREE.Mesh(new THREE.ConeGeometry(3, 6, 8), new THREE.MeshStandardMaterial({
                    color: 0x1e591e
                }));
                l.position.y = 4.5;
                l.castShadow = true;
                l.userData.isTree = true;
                g.add(t);
                g.add(l);
                g.userData.mapId = 'valley';
                natureGroup.add(g);
            }

            const treePos = [
                { x:  15, z:  25 }, { x: -30, z:  40 }, { x:  55, z: -20 }, { x: -55, z: -35 },
                { x:  80, z:  50 }, { x: -80, z:  60 }, { x:  40, z:  80 }, { x: -40, z: -70 },
                { x: 100, z: -60 }, { x:-100, z:  30 }, { x:  70, z: -90 }, { x: -70, z:  90 },
                { x: 120, z:  20 }, { x:-120, z: -50 }, { x:  30, z: 110 }, { x: -30, z:-110 },
                { x: 140, z:  80 }, { x:-140, z: -80 }, { x:  90, z: 130 }, { x: -90, z:-130 },
                { x: 160, z: -30 }, { x:-160, z:  10 }, { x:  10, z:-150 }, { x: -10, z: 150 },
                { x: 170, z: 110 }, { x:-170, z:-100 }, { x:  50, z:-170 }, { x: -50, z: 170 },
            ];
            treePos.forEach(p => createTree(p.x, p.z));

            // -- STONES --
            const stonePos = [
                // Zona original
                { x: 10,   z: 10,  s: 1.0, r: 0.5  },
                { x: -50,  z: 20,  s: 2.0, r: 2.1  },
                { x: 60,   z: -30, s: 1.5, r: -1.0 },
                { x: -20,  z: -60, s: 2.5, r: 3.0  },
                { x: 30,   z: 70,  s: 1.2, r: 1.5  },
                // Zona nueva
                { x: 130,  z: 60,  s: 1.8, r: 0.8  },
                { x: -110, z: -80, s: 2.2, r: 2.5  },
                { x: 160,  z: -110,s: 1.4, r: -0.5 },
                { x: -170, z: 140, s: 2.8, r: 1.2  },
                { x: 100,  z: -160,s: 1.6, r: 2.0  },
            ];

            function createStone(x, z, s, r) {
                const h = getTerrainHeight(x, z);
                // Use Dodecahedron for a low-poly rock look
                const geo = new THREE.DodecahedronGeometry(1.5 * s, 0); // Radius 1.5 base * scale
                const mat = new THREE.MeshStandardMaterial({
                    color: 0x888888,
                    flatShading: true,
                    roughness: 0.8,
                    metalness: 0.2
                });

                const mesh = new THREE.Mesh(geo, mat);
                mesh.userData.isStone = true;

                // Embed slightly in ground
                mesh.position.set(x, h + (0.5 * s), z);
                mesh.rotation.y = r;
                mesh.rotation.x = Math.random() * 0.5; // Slight random tilt
                mesh.rotation.z = Math.random() * 0.5;

                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData.mapId = 'valley';
                natureGroup.add(mesh);
            }

            stonePos.forEach(p => createStone(p.x, p.z, p.s, p.r));

            // -- BUSHES --
            const bushPos = [
                // Zona original
                { x: -35,  z: 15,  s: 1.2 },
                { x: 45,   z: 55,  s: 3.2 },
                { x: -65,  z: -45, s: 1.0 },
                { x: 25,   z: -75, s: 2.8 },
                { x: 75,   z: -50, s: 1.3 },
                // Zona nueva
                { x: 120,  z: 120, s: 2.0 },
                { x: -140, z: 90,  s: 1.5 },
                { x: 170,  z: -80, s: 2.5 },
                { x: -100, z: -150,s: 1.8 },
                { x: 80,   z: 170, s: 1.2 },
            ];

            function createBush(x, z, s) {
                const h = getTerrainHeight(x, z);
                const g = new THREE.Group();
                g.position.set(x, h, z);

                const colors = [0x2d6e2d, 0x3a8c3a, 0x245724, 0x4aad3a];
                const sphereOffsets = [
                    { ox: 0,      oy: s * 0.7, oz: 0,      r: s * 1.0 },
                    { ox: s*0.7,  oy: s * 0.4, oz: s*0.3,  r: s * 0.75 },
                    { ox: -s*0.7, oy: s * 0.4, oz: -s*0.2, r: s * 0.75 },
                    { ox: s*0.3,  oy: s * 0.3, oz: -s*0.7, r: s * 0.7  },
                    { ox: -s*0.3, oy: s * 0.5, oz: s*0.6,  r: s * 0.65 },
                ];

                sphereOffsets.forEach((o, i) => {
                    const mat = new THREE.MeshStandardMaterial({
                        color: colors[i % colors.length],
                        transparent: true,
                        opacity: 0.82,
                        roughness: 1,
                        metalness: 0
                    });
                    const mesh = new THREE.Mesh(new THREE.SphereGeometry(o.r, 7, 6), mat);
                    mesh.position.set(o.ox, o.oy, o.oz);
                    mesh.castShadow = true;
                    mesh.userData.isBush = true; // ignorar en raycasts de disparo
                    g.add(mesh);
                });

                g.userData.mapId = 'valley';
                natureGroup.add(g);
            }

            // CHANGED: Patch 4A — Sphere vs AABB intersection (3D). Usada para colisiones con
            // edificios, contenedores y objetos de mapa. Más precisa que dx²+dz²<r² (ignoraba Y).
            function sphereIntersectsAABB(sphereCenter, sphereRadius, aabbMin, aabbMax) {
                let sqDist = 0;
                const axes = ['x', 'y', 'z'];
                for (let i = 0; i < 3; i++) {
                    const v   = sphereCenter[axes[i]];
                    const min = aabbMin[axes[i]];
                    const max = aabbMax[axes[i]];
                    if (v < min) sqDist += (min - v) ** 2;
                    if (v > max) sqDist += (v - max) ** 2;
                }
                return sqDist <= sphereRadius * sphereRadius;
            }

            // CHANGED: Patch 4C — Calcula el vector de penetración mínima (eje más corto).
            // Devuelve el vector con el que empujar la esfera fuera del AABB.
            function computePenetration(sphereCenter, sphereRadius, aabbMin, aabbMax) {
                // Clamp center to AABB surface to find closest point
                const closest = new THREE.Vector3(
                    Math.max(aabbMin.x, Math.min(aabbMax.x, sphereCenter.x)),
                    Math.max(aabbMin.y, Math.min(aabbMax.y, sphereCenter.y)),
                    Math.max(aabbMin.z, Math.min(aabbMax.z, sphereCenter.z))
                );
                const diff = sphereCenter.clone().sub(closest);
                const dist = diff.length();
                if (dist < 0.0001) {
                    // Centro dentro del AABB: elegir eje de menor profundidad
                    const dx = Math.min(sphereCenter.x - aabbMin.x, aabbMax.x - sphereCenter.x);
                    const dy = Math.min(sphereCenter.y - aabbMin.y, aabbMax.y - sphereCenter.y);
                    const dz = Math.min(sphereCenter.z - aabbMin.z, aabbMax.z - sphereCenter.z);
                    if (dx <= dy && dx <= dz) return new THREE.Vector3((sphereCenter.x < (aabbMin.x + aabbMax.x) * 0.5 ? -1 : 1) * (sphereRadius + dx), 0, 0);
                    if (dy <= dx && dy <= dz) return new THREE.Vector3(0, (sphereCenter.y < (aabbMin.y + aabbMax.y) * 0.5 ? -1 : 1) * (sphereRadius + dy), 0);
                    return new THREE.Vector3(0, 0, (sphereCenter.z < (aabbMin.z + aabbMax.z) * 0.5 ? -1 : 1) * (sphereRadius + dz));
                }
                // Empujar fuera: normal × (radius - dist)
                return diff.normalize().multiplyScalar(sphereRadius - dist);
            }

            // CHANGED: Patch 4B — Helper: construye AABB min/max a partir de posición y half-extents.
            // Uso: const {min,max} = makeAABB(new THREE.Vector3(x,y,z), hw,hh,hd)
            function makeAABB(center, hw, hh, hd) {
                return {
                    min: new THREE.Vector3(center.x - hw, center.y - hh, center.z - hd),
                    max: new THREE.Vector3(center.x + hw, center.y + hh, center.z + hd),
                };
            }

            bushPos.forEach(b => createBush(b.x, b.z, b.s));

            // Devuelve true si el jugador está dentro de algún arbusto
            // y no acaba de disparar (en ese caso está expuesto 5s)
            let bushExposedUntil = 0; // timestamp ms hasta el que el jugador está expuesto tras disparar

            let _wasInBush = false;

            function isPlayerInBush() {
                if (Date.now() < bushExposedUntil) return false; // disparó — está expuesto
                for (const b of bushPos) {
                    const r = b.s * 1.4;
                    const dx = p1.mesh.position.x - b.x;
                    const dz = p1.mesh.position.z - b.z;
                    if (dx * dx + dz * dz < r * r) return true;
                }
                return false;
            }

            function createWeaponModel(weaponType, weaponColor) {
                const weaponGroup = new THREE.Group();
                const baseColor = weaponColor != null ? weaponColor : 0x222222;
                const mat = new THREE.MeshStandardMaterial({ color: baseColor, metalness: 0.7, roughness: 0.35 });

                if (weaponType === 'pistol') {
                    // Handle at Z=0 (Grip)
                    const handle = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.3, 0.1), mat);
                    handle.position.set(0, -0.1, 0);
                    weaponGroup.add(handle);

                    // Barrel points to +Z (Forward)
                    const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, 0.35), mat);
                    barrel.position.set(0, 0.05, 0.15);
                    weaponGroup.add(barrel);
                }
                else if (weaponType === 'smg') {
                    const body = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.2, 0.3), mat);
                    body.position.set(0, 0, 0.1);
                    weaponGroup.add(body);

                    const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.35), mat);
                    barrel.position.set(0, 0.05, 0.35);
                    weaponGroup.add(barrel);
                }
                else if (weaponType === 'ar') {
                    const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.4), mat);
                    body.position.set(0, 0, 0.15);
                    weaponGroup.add(body);

                    const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.5), mat);
                    barrel.position.set(0, 0.04, 0.55);
                    weaponGroup.add(barrel);

                    const stock = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, 0.25), mat);
                    stock.position.set(0, -0.05, -0.1);
                    weaponGroup.add(stock);
                }
                else if (weaponType === 'sniper') {
                    const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.5), mat);
                    body.position.set(0, 0, 0.2);
                    weaponGroup.add(body);

                    const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.9), mat);
                    barrel.position.set(0, 0.04, 0.85);
                    weaponGroup.add(barrel);

                    const scope = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.35, 8),
                        new THREE.MeshStandardMaterial({ color: 0x111111 }));
                    scope.rotation.z = Math.PI / 2;
                    scope.position.set(0, 0.15, 0.2);
                    weaponGroup.add(scope);

                    const stock = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.12, 0.35), mat);
                    stock.position.set(0, -0.05, -0.15);
                    weaponGroup.add(stock);
                }
                else if (weaponType === 'shotgun') {
                    // Chunky body + thick short barrel
                    const body = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.18, 0.45), mat);
                    body.position.set(0, 0, 0.1);
                    weaponGroup.add(body);

                    const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.3), mat);
                    barrel.position.set(0, 0.05, 0.45);
                    weaponGroup.add(barrel);

                    const pump = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.1, 0.15), mat);
                    pump.position.set(0, -0.05, 0.3);
                    weaponGroup.add(pump);
                }

                // Store barrel tip relative to weapon origin
                let tipZ = 0.35; // default for pistol
                if (weaponType === 'smg') tipZ = 0.55;
                else if (weaponType === 'ar') tipZ = 0.85;
                else if (weaponType === 'sniper') tipZ = 1.35;
                else if (weaponType === 'shotgun') tipZ = 0.6;

                const tipPos = new THREE.Vector3(0, 0.05, tipZ);
                weaponGroup.userData.barrelTip = tipPos;

                // Add Muzzle Flash (Hidden by default)
                const flash = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8 })
                );
                flash.position.copy(tipPos);
                flash.visible = false;
                weaponGroup.add(flash);
                weaponGroup.userData.muzzleFlash = flash;

                return weaponGroup;
            }

            // -- PLAYER CLASS --
            class Player {
                constructor(id, color, startPos, weaponKey = 'pistol') {
                    this.id = id;
                    this.color = color;
                    // ── BUILD TACTICAL SOLDIER MESH ─────────────────────────
                    // Colores según ID: P1=negro táctico, P2=arena/desert, bot=verde oliva
                    this.mesh = new THREE.Group();

                    // ── PALETA DE COLORES POR JUGADOR ───────────────────────
                    let cBase, cDark, cLight, cBoot, cKnee, cGoggle, cVisor, cStripe;
                    if (id === 1) {
                        // P1 — Operador desert / camo arena
                        cBase   = 0xb8956a; cDark   = 0x8a6a44; cLight  = 0xd4b080;
                        cBoot   = 0x5a3e28; cKnee   = 0x4a3220; cGoggle = 0x2a1a0a;
                        cVisor  = 0x00ccff; cStripe = 0x00aadd;
                    } else if (id === 2) {
                        // P2 — Operador desert / camo arena
                        cBase   = 0xb8956a; cDark   = 0x8a6a44; cLight  = 0xd4b080;
                        cBoot   = 0x5a3e28; cKnee   = 0x4a3220; cGoggle = 0x2a1a0a;
                        cVisor  = 0xff8800; cStripe = 0xffaa44;
                    } else {
                        // BOT — militar verde oliva
                        cBase   = 0x2e3820; cDark   = 0x1e2814; cLight  = 0x404e2c;
                        cBoot   = 0x141a0c; cKnee   = 0x1a2010; cGoggle = 0x0a1408;
                        cVisor  = 0xff2200; cStripe = 0xff4400;
                    }

                    // ── MATERIALES ───────────────────────────────────────────
                    const mBase  = new THREE.MeshStandardMaterial({ color:cBase,  roughness:0.85, metalness:0.05 });
                    const mDark  = new THREE.MeshStandardMaterial({ color:cDark,  roughness:0.90, metalness:0.05 });
                    const mLight = new THREE.MeshStandardMaterial({ color:cLight, roughness:0.80, metalness:0.05 });
                    const mBoot  = new THREE.MeshStandardMaterial({ color:cBoot,  roughness:0.92, metalness:0.08 });
                    const mKnee  = new THREE.MeshStandardMaterial({ color:cKnee,  roughness:0.95, metalness:0.02 });
                    const mVisor = new THREE.MeshStandardMaterial({ color:cVisor, roughness:0.05, metalness:0.6, emissive:new THREE.Color(cVisor), emissiveIntensity:0.25 });
                    const mStripe= new THREE.MeshStandardMaterial({ color:cStripe,roughness:0.5,  metalness:0.4, emissive:new THREE.Color(cStripe), emissiveIntensity:0.15 });
                    const mMetal = new THREE.MeshStandardMaterial({ color:0x303038,roughness:0.35, metalness:0.85 });
                    const mBlack = new THREE.MeshStandardMaterial({ color:0x080808,roughness:0.88, metalness:0.05 });
                    const mSkin  = new THREE.MeshStandardMaterial({ color:0x8a6040,roughness:0.80, metalness:0.00 });

                    // ── HELPER INTERNO ───────────────────────────────────────
                    function sm(mat, w, h, d, x, y, z) {
                        const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
                        m.position.set(x,y,z); m.castShadow=true; return m;
                    }
                    function sc(mat, rt, rb, h, x, y, z) {
                        const m = new THREE.Mesh(new THREE.CylinderGeometry(rt,rb,h,8), mat);
                        m.position.set(x,y,z); m.castShadow=true; return m;
                    }

                    // ════════════════════════════════════════════════════════
                    // TORSO — this.body  (pivot y=0, rotado por animación)
                    // ════════════════════════════════════════════════════════
                    const bodyGrp = new THREE.Group();
                    bodyGrp.position.y = 0.05;

                    // Cintura / pantalón táctico (parte baja del torso)
                    bodyGrp.add(sm(mBase, 0.58, 0.20, 0.30, 0, -0.18, 0));
                    // Cinturón táctico
                    bodyGrp.add(sm(mDark, 0.60, 0.07, 0.32, 0, -0.09, 0));
                    // Hebilla metálica
                    bodyGrp.add(sm(mMetal, 0.10, 0.06, 0.06, 0, -0.09, 0.17));

                    // Chaleco táctico principal (PECA / plate carrier)
                    bodyGrp.add(sm(mLight, 0.60, 0.44, 0.30, 0, 0.13, 0));
                    // Placa frontal (SAPI plate) — más oscura y rígida
                    bodyGrp.add(sm(mDark, 0.44, 0.34, 0.06, 0, 0.16, 0.15));
                    // Placa trasera
                    bodyGrp.add(sm(mDark, 0.44, 0.34, 0.06, 0, 0.16, -0.16));
                    // Bolsillos MOLLE frontales (3 pouches)
                    [-0.16, 0, 0.16].forEach(px => bodyGrp.add(sm(mBase, 0.10, 0.10, 0.07, px, -0.01, 0.19)));
                    // Bolsillo lateral izquierdo (radio pouch)
                    bodyGrp.add(sm(mBase, 0.07, 0.18, 0.10, -0.32, 0.05, 0.10));
                    // Bolsillo lateral derecho (admin pouch)
                    bodyGrp.add(sm(mBase, 0.07, 0.14, 0.10,  0.32, 0.05, 0.10));
                    // Straps / tirantes del chaleco
                    bodyGrp.add(sm(mDark, 0.07, 0.28, 0.05, -0.20, 0.13, 0.15));
                    bodyGrp.add(sm(mDark, 0.07, 0.28, 0.05,  0.20, 0.13, 0.15));
                    // Cuello / collar táctico
                    bodyGrp.add(sm(mBase, 0.28, 0.09, 0.24, 0, 0.38, 0));
                    // Stripe / ID de equipo en hombro izquierdo
                    bodyGrp.add(sm(mStripe, 0.04, 0.10, 0.06, -0.30, 0.32, 0.14));

                    this.mesh.add(bodyGrp);
                    this.body = bodyGrp;

                    // ════════════════════════════════════════════════════════
                    // CABEZA — this.head  (posición y=0.65)
                    // ════════════════════════════════════════════════════════
                    const headGrp = new THREE.Group();
                    headGrp.position.y = 0.65;

                    // Pasamontañas / balaclava (cara)
                    headGrp.add(sm(mBase, 0.36, 0.34, 0.32, 0, 0, 0));
                    // Zona de ojos: visera táctica (visor/goggles)
                    headGrp.add(sm(mVisor, 0.30, 0.10, 0.06, 0, 0.06, 0.17));
                    // Montura de las gafas (plástico oscuro)
                    headGrp.add(sm(mBlack, 0.34, 0.12, 0.04, 0, 0.06, 0.16));
                    // Lente izquierdo
                    const gogL = new THREE.Mesh(new THREE.SphereGeometry(0.055,8,6), mVisor);
                    gogL.position.set(-0.095, 0.06, 0.175); headGrp.add(gogL);
                    // Lente derecho
                    const gogR = gogL.clone();
                    gogR.position.set(0.095, 0.06, 0.175); headGrp.add(gogR);
                    // Casco balístico (forma levemente curvada con box)
                    headGrp.add(sm(mDark, 0.42, 0.18, 0.44, 0, 0.20, -0.01));
                    headGrp.add(sm(mDark, 0.40, 0.12, 0.40, 0, 0.27, 0)); // cúpula
                    // Borde frontal del casco
                    headGrp.add(sm(mDark, 0.40, 0.05, 0.08, 0, 0.10, 0.21));
                    // Borde trasero del casco (más pronunciado)
                    headGrp.add(sm(mDark, 0.38, 0.06, 0.07, 0, 0.12, -0.22));
                    // Velcro del casco (parche de identificación)
                    headGrp.add(sm(mLight, 0.12, 0.09, 0.02, 0, 0.22, 0.21));
                    // Sistema de NVG mount (varilla + soporte)
                    headGrp.add(sm(mMetal, 0.06, 0.04, 0.16, 0, 0.30, 0.17));
                    // Rieles laterales del casco (RAILS)
                    headGrp.add(sm(mMetal, 0.03, 0.10, 0.40, -0.22, 0.22, 0));
                    headGrp.add(sm(mMetal, 0.03, 0.10, 0.40,  0.22, 0.22, 0));
                    // Correa del casco (chin strap)
                    headGrp.add(sm(mDark, 0.03, 0.20, 0.04, -0.17, 0.00, 0.10));
                    headGrp.add(sm(mDark, 0.03, 0.20, 0.04,  0.17, 0.00, 0.10));
                    // Máscara inferior (boca/nariz cubierta)
                    headGrp.add(sm(mBase, 0.30, 0.12, 0.08, 0, -0.10, 0.16));
                    // Oídos / auricular táctico izquierdo
                    headGrp.add(sm(mMetal, 0.04, 0.10, 0.14, -0.20, 0.06, 0));
                    // Antena de radio (pequeña, en el casco)
                    headGrp.add(sm(mBlack, 0.02, 0.14, 0.02, -0.18, 0.34, -0.08));

                    this.mesh.add(headGrp);
                    this.head = headGrp;

                    // ════════════════════════════════════════════════════════
                    // PIERNAS — this.legL / this.legR  (pivote en cadera)
                    // ════════════════════════════════════════════════════════
                    function buildLeg(side) {  // side: -1=izquierda, +1=derecha
                        const lg = new THREE.Group();
                        lg.position.set(side * 0.20, -0.28, 0);

                        // Muslo / pantalón táctico superior
                        lg.add(sm(mBase, 0.22, 0.34, 0.24, 0, -0.17, 0));
                        // Bolsillo de muslo (cargo pocket)
                        lg.add(sm(mDark, 0.09, 0.14, 0.07, side*0.12, -0.18, 0.10));
                        // Rodillera táctica
                        lg.add(sm(mKnee, 0.22, 0.14, 0.10, 0, -0.40, 0.07));
                        // Shin / espinilla (pantorrilla táctica)
                        lg.add(sm(mBase, 0.18, 0.28, 0.20, 0, -0.58, 0));
                        // Bota táctica (parte superior)
                        lg.add(sm(mBoot, 0.22, 0.13, 0.28, 0, -0.76, 0.02));
                        // Suela de la bota
                        lg.add(sm(mBlack, 0.24, 0.06, 0.32, 0, -0.83, 0.03));
                        // Correa de la bota
                        lg.add(sm(mMetal, 0.20, 0.03, 0.02, 0, -0.72, 0.15));
                        // Detalle de holster / portamagazine en muslo izquierdo
                        if (side === -1) lg.add(sm(mDark, 0.06, 0.14, 0.08, -0.12, -0.26, 0.12));

                        return lg;
                    }

                    const legLGrp = buildLeg(-1);
                    const legRGrp = buildLeg(1);
                    this.mesh.add(legLGrp);
                    this.mesh.add(legRGrp);
                    this.legL = legLGrp;
                    this.legR = legRGrp;

                    // ════════════════════════════════════════════════════════
                    // BRAZOS — this.armL / this.armR  (pivote en hombro)
                    // ════════════════════════════════════════════════════════
                    function buildArmPivot(side) {  // side: -1=izquierdo, +1=derecho
                        const pivot = new THREE.Group();
                        pivot.position.set(side * 0.46, 0.40, 0);

                        // Hombrera táctica (shoulder pad)
                        pivot.add(sm(mLight, 0.14, 0.14, 0.18, 0, 0.04, 0));
                        // Brazo superior (manga táctica)
                        pivot.add(sm(mBase, 0.17, 0.26, 0.17, 0, -0.14, 0));
                        // Codo / protector de codo
                        pivot.add(sm(mKnee, 0.18, 0.10, 0.12, 0, -0.30, 0.03));
                        // Antebrazo (manga)
                        pivot.add(sm(mBase, 0.14, 0.22, 0.14, 0, -0.46, 0));
                        // Guante táctico (mano)
                        pivot.add(sm(mBlack, 0.14, 0.12, 0.16, 0, -0.62, 0.02));
                        // Nudillos reforzados del guante
                        [[-0.04,0.04], [0,0.04], [0.04,0.04]].forEach(([kx,kz]) =>
                            pivot.add(sm(mMetal, 0.03, 0.03, 0.03, kx, -0.58, kz+0.08))
                        );
                        // Parche de identificación en brazo izquierdo (IR patch)
                        if (side === -1) pivot.add(sm(mStripe, 0.02, 0.08, 0.12, -0.09, -0.12, 0));

                        return pivot;
                    }

                    const armLPivot = buildArmPivot(-1);
                    const armRPivot = buildArmPivot(1);
                    this.mesh.add(armLPivot);
                    this.mesh.add(armRPivot);
                    this.armL = armLPivot;
                    this.armR = armRPivot;

                    // Weapon Model
                    this.currentWeaponKey = weaponKey;
                    this.weaponModel = createWeaponModel(weaponKey, (WEAPONS[weaponKey] || WEAPONS.ar).color);
                    // Add weapon to armL pivot — at hand position (0, -0.6, 0) relative to pivot
                    // (pivot is at shoulder y=0.4, hand is 0.6 below = pivot y - 0.6)
                    this.weaponModel.position.set(0, -0.6, 0);
                    this.armL.add(this.weaponModel);

                    this.mesh.position.copy(startPos);
                    scene.add(this.mesh);

                    this.camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);

                    this.cameraAngle = {
                        x: 0, y: Math.PI
                    }

                        ; // x=Pitch, y=Yaw
                    this.velocity = new THREE.Vector3(0, 0, 0);
                    this.onGround = false;
                    this.hp = 100;
                    this.ammo = 30;
                    this.reloading = false;

                    // Stamina
                    this.stamina = 100;
                    this.maxStamina = 100;

                    // Stats
                    this.moveSpeed = 12;

                    // Load Weapon Stats
                    this.setWeapon(weaponKey);

                    this.recoil = 0;
                    this.muzzleFlashTimer = 0;
                    this.hitFlashTimer = null;
                    this.lastTrigger = 0;
                    this.lastDamageTime = -Infinity; // timestamp (ms) of last hit
                    this.regenTimer = 0;             // accumulates seconds toward next +10 tick
                    this.zoomLevel = 0; // 0 = default, 1 = fully zoomed
                    this.isExhausted = false;

                    // Input State
                    this.input = {
                        x: 0, y: 0, jump: false, shoot: false, reload: false, sprint: false, aim: false
                    }

                        ;

                    this.prevInput = {
                        ...this.input
                    }

                        ;

                    this.zoomLevel = 0; // 0 = default, 1 = fully zoomed

                    // Walking animation state (must init here to avoid NaN on first update)
                    this.walkCycle = 0;
                    this.bobPhase = 0;
                    this.aimAnimT   = 0;   // 0 = hip fire, 1 = fully aimed
                    this.shootRaiseT = 0;  // 0 = lowered, 1 = raised (on shoot)
                    this.breathPhase = Math.random() * Math.PI * 2; // offset aleatorio por jugador
                }

                setWeapon(key) {
                    const w = WEAPONS[key] || WEAPONS.ar;
                    this.damage = w.dmg;
                    this.projSpeed = w.speed;
                    this.reloadTime = w.reload;
                    this.fireRate = w.cd;
                    this.projColor = 0x999999;  // balas siempre grises
                    this.maxAmmo = w.maxAmmo || 30;
                    this.ammo = Math.min(this.ammo, this.maxAmmo);
                    this.range = w.range || 100;

                    // Swap weapon model if different
                    if (this.currentWeaponKey !== key && this.weaponModel) {
                        this.armL.remove(this.weaponModel);
                        this.currentWeaponKey = key;
                        this.weaponModel = createWeaponModel(key, w.color);
                        this.weaponModel.position.set(0, -0.6, 0);
                        this.armL.add(this.weaponModel);
                    }
                }

                respawn(pos) {
                    this.mesh.position.copy(pos);
                    this.velocity.set(0, 0, 0);
                    this.hp = 100;
                    this.ammo = this.maxAmmo || 30;
                    this.stamina = this.maxStamina; // Reset Stamina
                    this.reloading = false;
                    this.isExhausted = false;
                    this.lastDamageTime = -Infinity;
                    this.regenTimer = 0;

                    this.cameraAngle = {
                        x: 0, y: Math.PI
                    }

                        ;

                    // Animation properties
                    this.walkCycle = 0;
                    this.bobPhase = 0;

                    this.mesh.children.forEach(c => {
                        if (c.material && c.material.type === 'MeshStandardMaterial') {
                            c.material.color.setHex(this.color);
                        }
                    });
                }

                takeDamage(amount) {
                    this.hp -= amount;
                    this.lastDamageTime = performance.now();
                    this.regenTimer = 0;
                    SFX.impact('bot', sfxDistVol(this.mesh.position));

                    // Flash blanco — traverse todos los descendientes
                    this.mesh.traverse(child => {
                        if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                            if (!child.material.userData.origColor) {
                                child.material.userData.origColor = child.material.color.getHex();
                            }
                            child.material.color.setHex(0xffffff);
                            child.material.emissive.setHex(0xffffff);
                            child.material.emissiveIntensity = 0.6;
                        }
                    });

                    if (this.hitFlashTimer) clearTimeout(this.hitFlashTimer);

                    this.hitFlashTimer = setTimeout(() => {
                        this.mesh.traverse(child => {
                            if (child.isMesh && child.material && child.material.isMeshStandardMaterial) {
                                const orig = child.material.userData.origColor;
                                if (orig !== undefined) child.material.color.setHex(orig);
                                child.material.emissive.setHex(0x000000);
                                child.material.emissiveIntensity = 0;
                            }
                        });
                    }, 100);
                }

                update(dt) {
                    if (this.hp <= 0) return;

                    if (isNaN(this.mesh.position.x) || isNaN(this.mesh.position.y) || isNaN(this.mesh.position.z) ||
                        isNaN(this.cameraAngle.x) || isNaN(this.cameraAngle.y)) {
                        // Only log/reset during active gameplay; during killcam/end just skip
                        if (gameMode === MODE.SOLO || gameMode === MODE.PVP) {
                            console.warn("NaN Detected! Performing Deep Reset on Player " + this.id);
                            this.respawn(this.spawnPos || new THREE.Vector3(0, 2, 0));
                            this.velocity.set(0, 0, 0);
                            this.walkCycle = 0;
                            this.bobPhase = 0;
                        }
                        return;
                    }

                    if (isNaN(dt) || dt <= 0) return;

                    // ── REGEN: heal 10 HP/sec after 5s without taking damage ──
                    if (this.hp > 0 && this.hp < 100) {
                        const timeSinceHit = performance.now() - this.lastDamageTime;
                        if (timeSinceHit >= 5000) {
                            this.regenTimer += dt;
                            if (this.regenTimer >= 1.0) {
                                this.regenTimer -= 1.0;
                                this.hp = Math.min(100, this.hp + 10);
                            }
                        } else {
                            this.regenTimer = 0;
                        }
                    }

                    // Validate velocity
                    if (isNaN(this.velocity.x) || isNaN(this.velocity.y) || isNaN(this.velocity.z)) {
                        this.velocity.set(0, 0, 0);
                    }

                    // Validate input values
                    if (isNaN(this.input.x)) this.input.x = 0;
                    if (isNaN(this.input.y)) this.input.y = 0;

                    // -- MOVEMENT --
                    // Yaw applies to movement frame
                    const sinY = Math.sin(this.cameraAngle.y);
                    const cosY = Math.cos(this.cameraAngle.y);

                    // Validate trigonometric results
                    if (isNaN(sinY) || isNaN(cosY)) {
                        this.cameraAngle.y = Math.PI;
                        return;
                    }

                    const forward = new THREE.Vector3(-sinY, 0, -cosY);
                    const right = new THREE.Vector3(cosY, 0, -sinY);

                    const moveDir = new THREE.Vector3();
                    moveDir.add(forward.clone().multiplyScalar(this.input.y));
                    moveDir.add(right.clone().multiplyScalar(this.input.x));

                    if (moveDir.length() > 0.01) moveDir.normalize();

                    // Stamina & ADS Speed Logic
                    let currentSpeed = this.moveSpeed;
                    const isMoving = moveDir.length() > 0;

                    if (this.input.aim) {
                        currentSpeed *= 0.5; // 50% speed penalty while aiming
                    } else if (this.input.sprint && isMoving && this.stamina > 0 && !this.isExhausted) {
                        currentSpeed *= 1.6;
                        this.stamina -= 30 * dt;
                        if (this.stamina <= 0) {
                            this.stamina = 0;
                            this.isExhausted = true; // Mark as exhausted
                        }
                    }

                    else {
                        this.stamina += 15 * dt;
                        if (this.stamina > this.maxStamina) this.stamina = this.maxStamina;

                        // Recover from exhaustion at 20%
                        if (this.isExhausted && this.stamina >= 20) {
                            this.isExhausted = false;
                        }
                    }

                    if (isMoving) {
                        const step = moveDir.multiplyScalar(currentSpeed * dt);
                        const nextPos = this.mesh.position.clone().add(step);
                        // Tree collision — ONLY on The Valley map
                        let hit = false;

                        if (activeMapKey === 'valley') {
                            for (let t of treePos) {
                                if ((nextPos.x - t.x) ** 2 + (nextPos.z - t.z) ** 2 < 1.0) hit = true;
                            }

                            // Stone Collision — ONLY on The Valley map
                            for (let s of stonePos) {
                                const r = 1.3 * s.s; // hitbox ligeramente menor que el visual (1.5)
                                const dx = nextPos.x - s.x;
                                const dz = nextPos.z - s.z;
                                if (dx * dx + dz * dz < r * r) {
                                    const stoneBaseY = getTerrainHeight(s.x, s.z);
                                    const stoneTop = stoneBaseY + 1.6 * s.s;
                                    if (this.mesh.position.y < stoneTop + 0.5) hit = true;
                                }
                            }
                        }

                        if (!hit) {
                            // CHANGED: Patch 4B+4C — después de aplicar el step, resolver colisiones
                            // con objetos isSolid del mapa activo usando Sphere vs AABB + sliding.
                            // Radio del jugador: ~0.5m (cápsula simplificada a esfera XZ).
                            const PLAYER_RADIUS = 0.5;
                            const candidatePos = this.mesh.position.clone().add(step);
                            // Collect all isSolid objects — use cached list if available
                            if (!window._solidCache) window._solidCache = {};
                            const _cacheKey = activeMapKey || 'valley';
                            if (!window._solidCache[_cacheKey]) {
                                const _tmp = [];
                                scene.traverse(obj => {
                                    if (!obj.userData.isSolid) return;
                                    // For non-valley maps: only include objects inside their map group
                                    if (activeMapKey !== 'valley') {
                                        const mapGrp = _mapGroups[activeMapKey];
                                        if (!mapGrp) return;
                                        let parent = obj.parent;
                                        let inGroup = false;
                                        while (parent) { if (parent === mapGrp) { inGroup = true; break; } parent = parent.parent; }
                                        if (!inGroup) return;
                                    } else {
                                        // For valley: exclude objects that belong to ANY other map group
                                        const otherGroups = Object.values(_mapGroups).filter(g => g);
                                        for (const grp of otherGroups) {
                                            let parent = obj.parent;
                                            while (parent) { if (parent === grp) return; parent = parent.parent; }
                                        }
                                    }
                                    _tmp.push(obj);
                                });
                                window._solidCache[_cacheKey] = _tmp;
                            }
                            const solidObjects = window._solidCache[_cacheKey];
                            // Resolve ALL collisions (not just the first one)
                            for (const obj of solidObjects) {
                                const bbox = new THREE.Box3().setFromObject(obj);
                                if (sphereIntersectsAABB(candidatePos, PLAYER_RADIUS, bbox.min, bbox.max)) {
                                    const pen = computePenetration(candidatePos, PLAYER_RADIUS, bbox.min, bbox.max);
                                    pen.y = 0;
                                    if (pen.lengthSq() > 0.0001) {
                                        candidatePos.add(pen);
                                        const normal = pen.clone().normalize();
                                        const proj = step.dot(normal);
                                        if (proj < 0) step.sub(normal.multiplyScalar(proj));
                                    }
                                }
                            }
                            this.mesh.position.copy(candidatePos);
                        }

                        // Face Camera Yaw
                        this.mesh.rotation.y = this.cameraAngle.y + Math.PI;

                        // WALKING ANIMATION - Independent limb movement
                        const walkSpeed = this.input.sprint ? 12 : 8;
                        this.walkCycle += dt * walkSpeed;

                        // Footstep sound (solo p1 y p2)
                        if (this.id === 1) SFX.tickFootstep(this.walkCycle, true);
                        if (this.id === 2) SFX.tickFootstep2(this.walkCycle, true);

                        // Animate arms and legs independently (alternating)
                        const swingAmount = 0.4; // Amount of swing

                        // Only animate if references exist (safety check)
                        if (this.armR && this.armL && this.legR && this.legL && this.body) {
                            // Right arm and legs: normal walk swing
                            // armR handled by always-raised block below
                            this.legL.rotation.x = Math.sin(this.walkCycle) * swingAmount;
                            this.legR.rotation.x = -Math.sin(this.walkCycle) * swingAmount;

                            // Subtle body lean
                            this.body.rotation.z = Math.cos(this.walkCycle * 0.5) * 0.02;
                        }
                    }

                    else {
                        this.mesh.rotation.y = this.cameraAngle.y + Math.PI;

                        // Reset limb rotations (with safety check)
                        if (this.armR && this.armL && this.legR && this.legL && this.body) {
                            // armR handled by always-raised block below
                            this.legR.rotation.x *= 0.9;
                            this.legL.rotation.x *= 0.9;
                            this.body.rotation.z *= 0.9;
                        }
                    }

                    // -- ARM ANIMATION --
                    // Update aimAnimT: lerps 0→1 when ADS held, 1→0 when released
                    this.aimAnimT = this.aimAnimT || 0;
                    this.aimAnimT += ((this.input.aim ? 1 : 0) - this.aimAnimT) * Math.min(1, dt * 8);

                    if (this.armL && this.armR && this.body) {
                        const aimT = this.aimAnimT;
                        this.body.rotation.x = 0;

                        // Shoulders stay fixed at their original positions (±0.62).
                        // Instead, arms rotate inward (Y axis) and the weapon slides
                        // in local X so it always appears at world center when aiming.
                        this.armL.position.x = -0.46;
                        this.armR.position.x =  0.46;

                        this.armL.position.z = 0;
                        this.armR.position.z = 0;

                        // armL: porta el arma — rota hacia adelante al apuntar
                        this.armL.rotation.x = -Math.PI / 2 + this.recoil;
                        this.armL.rotation.y = 0;
                        this.armL.rotation.z = aimT * 0.75;

                        // armR: apoyo — cierra simétricamente
                        const targetRx = -Math.PI / 2 * aimT + this.recoil * 0.6 * aimT;
                        const targetRz = -aimT * 0.95;
                        this.armR.rotation.x += (targetRx - this.armR.rotation.x) * 0.15;
                        this.armR.rotation.y += (0 - this.armR.rotation.y) * 0.15;
                        this.armR.rotation.z += (targetRz - this.armR.rotation.z) * 0.15;

                        if (this.weaponModel) {
                            // armL en x=-0.46 + rotZ=0.75 → arma se va izquierda; compensar con +0.22
                            this.weaponModel.position.x = aimT * 0.17;
                            this.weaponModel.position.y = -0.6;
                            this.weaponModel.position.z = 0;
                            // El arma debe quedar con la misma orientación mundial que el mesh del jugador
                            // (barril +Z = hacia donde mira el jugador). Calculamos en espacio mundial.
                            const qArmWorld = new THREE.Quaternion();
                            this.armL.getWorldQuaternion(qArmWorld);
                            const qMeshWorld = new THREE.Quaternion();
                            this.mesh.getWorldQuaternion(qMeshWorld);
                            // localQuat = armWorld^-1 * meshWorld → weapon orientado igual que el mesh
                            this.weaponModel.quaternion.copy(qArmWorld.invert().multiply(qMeshWorld));
                        }
                    }

                    // -- ANIMATION UPDATES (Recoil & Flash) --
                    this.recoil *= 0.8; // Fast decay
                    if (this.recoil < 0.001) this.recoil = 0;

                    if (this.muzzleFlashTimer > 0) {
                        this.muzzleFlashTimer -= dt;
                        if (this.weaponModel && this.weaponModel.userData.muzzleFlash) {
                            this.weaponModel.userData.muzzleFlash.visible = true;
                            this.weaponModel.userData.muzzleFlash.scale.setScalar(0.5 + Math.random() * 1.5);
                        }
                    } else {
                        if (this.weaponModel && this.weaponModel.userData.muzzleFlash) {
                            this.weaponModel.userData.muzzleFlash.visible = false;
                        }
                    }

                    // Jump
                    if (this.input.jump && this.onGround) {
                        this.velocity.y = 15;
                        this.onGround = false;
                    }

                    // Physics — store prevY for swept ceiling collision
                    const prevY = this.mesh.position.y;
                    this.velocity.y += GRAVITY * dt;
                    this.mesh.position.y += this.velocity.y * dt;

                    // Terrain bounds
                    this.mesh.position.x = Math.max(-198, Math.min(198, this.mesh.position.x));
                    this.mesh.position.z = Math.max(-198, Math.min(198, this.mesh.position.z));
                    const h = getTerrainHeight(this.mesh.position.x, this.mesh.position.z);

                    const CHAR_FOOT_OFFSET = 0.9;
                    const CHAR_HEAD_OFFSET = 1.2;

                    // ── CEILING COLLISION (swept, runs before floor so it wins) ──
                    // Uses prevY so it catches slabs thinner than one frame of movement.
                    if (this.velocity.y > 0 && activeMapKey && activeMapKey !== 'valley') {
                        const solidObjs = window._solidCache && window._solidCache[activeMapKey];
                        if (solidObjs) {
                            const px = this.mesh.position.x, pz = this.mesh.position.z;
                            const prevHeadY = prevY + CHAR_HEAD_OFFSET;
                            const currHeadY = this.mesh.position.y + CHAR_HEAD_OFFSET;
                            for (const obj of solidObjs) {
                                const bbox = new THREE.Box3().setFromObject(obj);
                                if (px < bbox.min.x - 0.3 || px > bbox.max.x + 0.3) continue;
                                if (pz < bbox.min.z - 0.3 || pz > bbox.max.z + 0.3) continue;
                                // Swept: was below slab bottom, now at or above it → hit ceiling
                                if (prevHeadY < bbox.min.y && currHeadY >= bbox.min.y) {
                                    this.mesh.position.y = bbox.min.y - CHAR_HEAD_OFFSET;
                                    this.velocity.y = 0;
                                    break;
                                }
                            }
                        }
                    }

                    // ── FLOOR DETECTION ──────────────────────────────────────────
                    let floorY = h;
                    if (activeMapKey === 'valley') {
                        for (let s of stonePos) {
                            const r = 1.3 * s.s;
                            const dx = this.mesh.position.x - s.x;
                            const dz = this.mesh.position.z - s.z;
                            if (dx * dx + dz * dz < r * r) {
                                const stoneBaseY = getTerrainHeight(s.x, s.z);
                                const stoneTop = stoneBaseY + 1.6 * s.s;
                                if (stoneTop > floorY) floorY = stoneTop;
                            }
                        }
                    }
                    // Map-specific platforms (second floors, ramps, stairs)
                    const _platforms = window._mapPlatforms && window._mapPlatforms[activeMapKey];
                    if (_platforms) {
                        const px = this.mesh.position.x, pz = this.mesh.position.z;
                        for (const p of _platforms) {
                            if (Math.abs(px - p.x) <= p.w/2 + 0.3 && Math.abs(pz - p.z) <= p.d/2 + 0.3) {
                                let surfY = p.y;
                                if (p.ramp) {
                                    const t = Math.max(0, Math.min(1, (pz - p.ramp.z0) / (p.ramp.z1 - p.ramp.z0)));
                                    surfY = p.ramp.y0 + t * (p.ramp.y1 - p.ramp.y0);
                                }
                                if (surfY > floorY && this.mesh.position.y + 0.5 >= surfY) {
                                    floorY = surfY;
                                }
                            }
                        }
                    }
                    // isSolid top-surface: lets player land/stand on any solid object (crates, walls, etc.)
                    // Only activates when falling (velocity.y <= 0) to avoid fighting with ceiling check.
                    if (this.velocity.y <= 0 && activeMapKey && activeMapKey !== 'valley') {
                        const solidObjs = window._solidCache && window._solidCache[activeMapKey];
                        if (solidObjs) {
                            const px = this.mesh.position.x, pz = this.mesh.position.z;
                            const py = this.mesh.position.y;
                            for (const obj of solidObjs) {
                                const bbox = new THREE.Box3().setFromObject(obj);
                                if (px < bbox.min.x - 0.3 || px > bbox.max.x + 0.3) continue;
                                if (pz < bbox.min.z - 0.3 || pz > bbox.max.z + 0.3) continue;
                                const topY = bbox.max.y;
                                // Feet at or just below topY (within 2 units from above)
                                if (topY > floorY && py + CHAR_FOOT_OFFSET >= topY && py <= topY + 2.0) {
                                    floorY = topY;
                                }
                            }
                        }
                    }

                    // Floor snap
                    if (this.mesh.position.y < floorY + CHAR_FOOT_OFFSET) {
                        this.mesh.position.y = floorY + CHAR_FOOT_OFFSET;
                        this.velocity.y = 0;
                        this.onGround = true;
                    } else {
                        this.onGround = false;
                    }


                    // FALL RESET: If player falls through world or flies too high
                    if (this.mesh.position.y < -50 || this.mesh.position.y > 500) {
                        this.hp = 0; // Die if void
                    }

                    // -- ADS ZOOM --
                    const zoomSpeed = 10;
                    if (this.input.aim) {
                        this.zoomLevel = Math.min(1, this.zoomLevel + dt * zoomSpeed);
                    } else {
                        this.zoomLevel = Math.max(0, this.zoomLevel - dt * zoomSpeed);
                    }

                    // FOV Zoom: 75 -> 40
                    this.camera.fov = 75 - (this.zoomLevel * 35);
                    this.camera.updateProjectionMatrix();

                    // Orbital Camera Update
                    // Dist: 6 -> 4 (Zoom in closer to player)
                    const camDist = 6 - (this.zoomLevel * 2);
                    // Limit pitch to prevent flipping (e.g. -80 to +80 deg)
                    // Clamp Pitch HERE to strictly prevent accumulation
                    this.cameraAngle.x = Math.max(-1.4, Math.min(1.4, this.cameraAngle.x));

                    const pitch = this.cameraAngle.x;
                    const cHeight = Math.sin(pitch) * camDist;
                    const cHoriz = Math.cos(pitch) * camDist;

                    // X/Z offset depends on Yaw
                    const offX = Math.sin(this.cameraAngle.y) * cHoriz;
                    const offZ = Math.cos(this.cameraAngle.y) * cHoriz;

                    // Target is Player Center/Head
                    const target = this.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0));

                    // Camera Position — sin bob, cámara estable.
                    this.camera.position.set(target.x + offX,
                        target.y + cHeight,
                        target.z + offZ);

                    this.camera.lookAt(target);

                    // Action: Shoot
                    if (this.input.shoot) {
                        // Removed !prevInput check for auto-fire support if wanted, but cooldown handles it
                        this.shoot();
                    }

                    // Action: Reload
                    if (this.input.reload && !this.prevInput.reload) {
                        this.startReload();
                    }

                    this.prevInput = {
                        ...this.input
                    }

                        ;
                }

                shoot() {
                    if (this.reloading || this.ammo <= 0) return;

                    // Rate Limit from Weapon
                    if (Date.now() - this.lastTrigger < this.fireRate) return;
                    this.lastTrigger = Date.now();

                    // Si el jugador (id=1) dispara dentro de un arbusto, queda expuesto 5s
                    if (this.id === 1) {
                        for (const b of bushPos) {
                            const r = b.s * 1.4;
                            const dx = this.mesh.position.x - b.x;
                            const dz = this.mesh.position.z - b.z;
                            if (dx * dx + dz * dz < r * r) {
                                bushExposedUntil = Date.now() + 5000;
                                break;
                            }
                        }
                    }

                    this.ammo--;

                    // Trigger Visuals
                    this.recoil = 0.15; // Reduced from 0.4
                    this.muzzleFlashTimer = 0.05;
                    // Sound
                    const _shootVm = (this.id > 2) ? sfxDistVol(this.mesh.position) * (gameMode === MODE.SOLO ? 0.6 : 1) : 1;
                    SFX.shoot(this.currentWeaponKey, _shootVm);

                    // --- AIMING DIRECTION ---
                    // The camera orbits the player and looks AT the player head, so
                    // getWorldDirection() points camera→head (slightly downward on flat ground).
                    // We project a far aim point along that ray (300 units), then compute
                    // the direction from the barrelTip to that far point — this gives the
                    // correct bullet direction regardless of barrel vs camera height difference.
                    const camWorldDir = new THREE.Vector3();
                    this.camera.getWorldDirection(camWorldDir);
                    const aimFarPoint = this.camera.position.clone().addScaledVector(camWorldDir, 300);

                    // Arm is always raised, so localToWorld gives the correct barrel tip position.
                    const start = new THREE.Vector3();
                    if (this.weaponModel && this.weaponModel.userData.barrelTip) {
                        this.weaponModel.updateMatrixWorld(true);
                        const tip = this.weaponModel.userData.barrelTip.clone();
                        this.weaponModel.localToWorld(tip);
                        start.copy(tip);
                    } else {
                        start.copy(this.mesh.position).add(new THREE.Vector3(0, 1.5, 0));
                    }

                    const finalDir = new THREE.Vector3().subVectors(aimFarPoint, start).normalize();

                    // For bots, push start forward so bullet clears the body
                    const isBot = (this.id !== 1 && this.id !== 2);
                    if (isBot) {
                        start.addScaledVector(finalDir, 0.7);
                    }

                    if (this.currentWeaponKey === 'shotgun') {
                        // Shotgun: 9 perdigones en patrón fijo:
                        //    o  o  o       (fila superior: separación s)
                        //  o    o    o     (fila central:  separación w > s)
                        //    o  o  o       (fila inferior: separación s)
                        const PELLET_DMG = 25; // 9×25 = 225 daño máximo a quemarropa
                        const s = 0.07;  // offset filas superior/inferior
                        const w = 0.13;  // offset fila central (más abierta)

                        const PATTERN = [
                            [-s, +s], [0, +s], [+s, +s],   // fila superior
                            [-w,  0], [0,  0], [+w,  0],   // fila central
                            [-s, -s], [0, -s], [+s, -s],   // fila inferior
                        ];

                        // Dos vectores perpendiculares al eje de disparo
                        const perp1 = new THREE.Vector3();
                        if (Math.abs(finalDir.y) < 0.9)
                            perp1.crossVectors(finalDir, new THREE.Vector3(0, 1, 0)).normalize();
                        else
                            perp1.crossVectors(finalDir, new THREE.Vector3(1, 0, 0)).normalize();
                        const perp2 = new THREE.Vector3().crossVectors(finalDir, perp1).normalize();

                        for (const [h, v] of PATTERN) {
                            const pelletDir = finalDir.clone()
                                .addScaledVector(perp1, h)
                                .addScaledVector(perp2, v)
                                .normalize();
                            spawnProjectile(start.clone(), pelletDir, this.projSpeed, this.id, PELLET_DMG, this.projColor, this.range, this.currentWeaponKey);
                        }
                    } else {
                        spawnProjectile(start, finalDir, this.projSpeed, this.id, this.damage, this.projColor, this.range, this.currentWeaponKey);
                    }

                    if (this.ammo === 0) this.startReload();
                }

                startReload() {
                    if (this.reloading || this.ammo === 30) return;
                    this.reloading = true;

                    setTimeout(() => {
                        this.ammo = this.maxAmmo;
                        this.reloading = false;
                    }

                        , this.reloadTime); // Weapon Reload Time
                }
            }

            const p1 = new Player(1, 0x00ccff, new THREE.Vector3(0, 2, 0), 'ar');
            const p2 = new Player(2, 0xff00ff, new THREE.Vector3(0, 2, 0), 'ar');

            // -- ENEMIES --
            const enemies = [];

            // Los puntos de spawn de enemigos se generan dinámicamente en startSoloConfirm
            // dentro de un radio de 150m alrededor del spawn del jugador.

            class AIEnemy extends Player {
                constructor(pos) {
                    // Random Weapon for AI
                    const keys = Object.keys(WEAPONS);
                    const rndKey = keys[Math.floor(Math.random() * keys.length)];

                    // Get terrain height at spawn position for proper ground placement
                    const terrainHeight = getTerrainHeight(pos.x, pos.z);
                    super(3, 0xc23616, new THREE.Vector3(pos.x, terrainHeight + 2, pos.z), rndKey);

                    // Store original spawn position for respawn
                    this.spawnPos = new THREE.Vector3(pos.x, terrainHeight + 2, pos.z);

                    this.aggro = false;
                    this.nextMove = 0;
                    this.strafe = 1;
                    this.lastShot = 0;

                    // CUSTOM STATS
                    this.moveSpeed = 8;
                    // projSpeed/Damage etc inherited from setWeapon call in super

                    // Behavior Config
                    this.preferredDist = 40 + Math.random() * 20; // 40-60m Range (Doubled)
                    this.shootInterval = 1000 + Math.random() * 1000; // Faster frequency check

                    // Desync Start
                    this.lastShot = Date.now() - Math.random() * 500;
                }

                // Override to add AGGRO
                takeDamage(amount) {
                    super.takeDamage(amount);
                    this.aggro = true; // Alerts AI if shot from far away
                }

                update(dt) {
                    if (this.hp <= 0) {
                        // Keep meshes in scene during killcam/end modes for visual reconstruction
                        if (gameMode === MODE.KILLCAM || gameMode === MODE.END || kcKillerEntity === this) {
                            if (!this.mesh.parent) scene.add(this.mesh);
                            this.mesh.visible = true;
                            // Resetear el timer para que super.update(0) apague el flash correctamente
                            this.muzzleFlashTimer = 0;
                            super.update(0);
                            return;
                        }
                        // Remove dead enemy from scene immediately otherwise
                        if (this.mesh.parent) {
                            scene.remove(this.mesh);
                        }
                        return;
                    }

                    // Don't update AI once game is over / during killcam
                    if (gameEnding || gameMode === MODE.KILLCAM || gameMode === MODE.END) {
                        // Apagar muzzle flash de bots congelados
                        if (this.weaponModel && this.weaponModel.userData.muzzleFlash) {
                            this.weaponModel.userData.muzzleFlash.visible = false;
                        }
                        return;
                    }

                    try {
                        // Guard against NaN in p1 position
                        if (isNaN(p1.mesh.position.x) || isNaN(p1.mesh.position.z)) return;

                        const dist = this.mesh.position.distanceTo(p1.mesh.position);
                        if (!isFinite(dist)) return;

                        // Si el jugador está en un arbusto, el bot solo lo detecta si está muy cerca
                        const detectionRange = isPlayerInBush() ? 8 : 100;

                        if (dist < detectionRange || (this.aggro && !isPlayerInBush())) {
                            const toPlayer = p1.mesh.position.clone().sub(this.mesh.position);
                            const distSq = toPlayer.lengthSq();

                            if (distSq > 0.0001) {
                                const toP = toPlayer.normalize();

                                // Update Yaw to FACE player
                                this.cameraAngle.y = Math.atan2(toP.x, toP.z) + Math.PI;

                                // Update Pitch to AIM at player
                                const dx = p1.mesh.position.x - this.mesh.position.x;
                                const dz = p1.mesh.position.z - this.mesh.position.z;
                                const hDist = Math.sqrt(dx * dx + dz * dz);
                                const vDist = (p1.mesh.position.y + 0.4) - (this.mesh.position.y + 1.5);

                                this.cameraAngle.x = -Math.atan2(vDist, Math.max(0.1, hDist));
                            }

                            // Move Logic
                            if (dist > this.preferredDist + 2) this.input.y = 1;
                            else if (dist < 20) this.input.y = -1;

                            if (Date.now() > this.nextMove) {
                                this.strafe *= -1;
                                this.nextMove = Date.now() + 1000 + Math.random() * 2000;
                                if (Math.random() > 0.7) this.input.jump = true;
                            } else {
                                this.input.jump = false;
                            }

                            this.input.x = this.strafe;

                            // SHOOTING & RELOADING
                            this.input.shoot = (dist < detectionRange);
                            this.input.reload = (this.ammo === 0);
                        } else {
                            this.input.shoot = false;
                            this.input.reload = false;
                            this.input.y = 0;
                            this.input.x = 0;
                        }

                        super.update(dt);
                    }

                    catch (e) {
                        console.error("AI Error", e);
                    }
                }
            }

            // -- PROJECTILES --
            const projectiles = [];
            // Información de la última muerte para la cámara de replay
            let lastKillInfo = null;

            // ── REPLAY BUFFER ─────────────────────────────────────
            // Records p1 camera state every frame; keeps last REPLAY_WINDOW seconds

            // CHANGED: Patch 2A — CircularBuffer evita push/shift O(n) y limita memoria
            // a una ventana fija sin reasignar el array (clara separación de crecimiento).
            class CircularBuffer {
                constructor(capacity) {
                    this.capacity = capacity;
                    this.buffer = new Array(capacity);
                    this.head = 0;
                    this.size = 0;
                }
                push(item) {
                    this.buffer[(this.head + this.size) % this.capacity] = item;
                    if (this.size < this.capacity) {
                        this.size++;
                    } else {
                        this.head = (this.head + 1) % this.capacity;
                    }
                }
                toArray() {
                    const arr = [];
                    for (let i = 0; i < this.size; i++) {
                        arr.push(this.buffer[(this.head + i) % this.capacity]);
                    }
                    return arr;
                }
                // Vaciar sin reasignar — las referencias vivas siguen apuntando al mismo objeto
                clear() {
                    this.head = 0;
                    this.size = 0;
                }
                // Compatibilidad con código que lee .length
                get length() { return this.size; }
                // Compatibilidad con código que itera: [0].t para prune
                get 0() { return this.size > 0 ? this.buffer[this.head] : undefined; }
                // Array.prototype.map / .filter parity
                map(fn) { return this.toArray().map(fn); }
                filter(fn) { return this.toArray().filter(fn); }
                forEach(fn) { this.toArray().forEach(fn); }
                shift() {
                    if (this.size === 0) return undefined;
                    const item = this.buffer[this.head];
                    this.head = (this.head + 1) % this.capacity;
                    this.size--;
                    return item;
                }
            }

            const REPLAY_WINDOW = 2.0;
            // CHANGED: Patch 2B — capacidad calculada: 5s × 60ticks = 300 entradas máx
            const REPLAY_SECONDS   = 5;
            const TICKS_PER_SECOND = 60;
            const REPLAY_CAPACITY  = Math.ceil(REPLAY_SECONDS * TICKS_PER_SECOND); // 300

            // replayBuffer sigue como array normal (pequeño: ~120 frames × 2s)
            const replayBuffer = [];
            // CHANGED: Patch 2B — Map de CircularBuffers por entidad en lugar de arrays crecientes
            const enemyReplayBuffers = new Map(); // enemy → CircularBuffer
            // CHANGED: Patch 2B — CircularBuffer para proyectiles en replay
            const projectileReplayBuffer = new CircularBuffer(REPLAY_CAPACITY); // stores projectile spawn events

            function recordReplayFrame() {
                if (gameMode !== MODE.SOLO && gameMode !== MODE.PVP) return;
                const now = performance.now() / 1000;
                const frame = {
                    t: now,
                    // P1
                    pos: p1.camera.position.clone(),
                    quat: p1.camera.quaternion.clone(),
                    meshPos: p1.mesh.position.clone(),
                    meshRotY: p1.mesh.rotation.y,
                    armLx: p1.armL.rotation.x,
                    armRx: p1.armR.rotation.x,
                    legLx: p1.legL.rotation.x,
                    legRx: p1.legR.rotation.x,
                };
                // P2 (only in PvP)
                if (gameMode === MODE.PVP && p2.mesh.parent) {
                    frame.p2meshPos = p2.mesh.position.clone();
                    frame.p2meshRotY = p2.mesh.rotation.y;
                    frame.p2armLx = p2.armL.rotation.x;
                    frame.p2armRx = p2.armR.rotation.x;
                    frame.p2legLx = p2.legL.rotation.x;
                    frame.p2legRx = p2.legR.rotation.x;
                }
                replayBuffer.push(frame);
                const cutoff = now - REPLAY_WINDOW;
                while (replayBuffer.length > 0 && replayBuffer[0].t < cutoff) replayBuffer.shift();

                // Record each living enemy
                for (const e of enemies) {
                    if (e.hp <= 0) continue;
                    // CHANGED: Patch 2B — usar CircularBuffer por entidad para limitar memoria
                    if (!enemyReplayBuffers.has(e)) enemyReplayBuffers.set(e, new CircularBuffer(REPLAY_CAPACITY));
                    const buf = enemyReplayBuffers.get(e);
                    buf.push({
                        t: now,
                        meshPos: e.mesh.position.clone(),
                        meshRotY: e.mesh.rotation.y,
                        armLx: e.armL.rotation.x,
                        armRx: e.armR.rotation.x,
                        legLx: e.legL.rotation.x,
                        legRx: e.legR.rotation.x,
                        // Build a chase-cam position: behind the enemy
                        camPos: e.camera.position.clone(),
                        camQuat: e.camera.quaternion.clone(),
                    });
                    // CHANGED: Patch 2B — CircularBuffer descarta automáticamente entradas viejas;
                    // no se necesita while-shift manual. Proyectiles también gestionados igual.
                    while (buf.length > 0 && buf[0] && buf[0].t < cutoff) buf.shift();
                }

                // CHANGED: Patch 2B — CircularBuffer gestiona capacidad automáticamente;
                // el while-shift sigue funcionando via compat .shift() del CircularBuffer
                while (projectileReplayBuffer.length > 0 && projectileReplayBuffer[0] && projectileReplayBuffer[0].t < cutoff) {
                    projectileReplayBuffer.shift();
                }
            }

            function snapshotReplay() {
                return replayBuffer.map(f => ({
                    t: f.t,
                    pos: f.pos.clone(),
                    quat: f.quat.clone(),
                    meshPos: f.meshPos.clone(),
                    meshRotY: f.meshRotY,
                    armLx: f.armLx,
                    armRx: f.armRx,
                    legLx: f.legLx,
                    legRx: f.legRx,
                    // P2
                    p2meshPos: f.p2meshPos ? f.p2meshPos.clone() : null,
                    p2meshRotY: f.p2meshRotY ?? null,
                    p2armLx: f.p2armLx ?? null,
                    p2armRx: f.p2armRx ?? null,
                    p2legLx: f.p2legLx ?? null,
                    p2legRx: f.p2legRx ?? null,
                }));
            }

            function snapshotAllEnemyReplays() {
                const snapshots = new Map();
                for (const [enemy, buffer] of enemyReplayBuffers) {
                    snapshots.set(enemy, buffer.map(f => ({
                        t: f.t,
                        meshPos: f.meshPos.clone(),
                        meshRotY: f.meshRotY,
                        armLx: f.armLx, armRx: f.armRx,
                        legLx: f.legLx, legRx: f.legRx,
                        camPos: f.camPos.clone(),
                        camQuat: f.camQuat.clone(),
                    })));
                }
                return snapshots;
            }

            // ── KILLCAM ──────────────────────────────────────────────
            // 4 seconds total:
            //   Phase 1 (0-2s): Killer's POV – camera locked at killer cam position,
            //                   bullet travels from killerPos → victimPos at cinematic speed.
            //   Phase 2 (2-4s): Bullet cam – camera follows bullet in slow-mo to impact.
            let KC_DURATION = 4000;   // ms total — recalculado en cada killcam
            let KC_PHASE2 = 2000;     // ms donde empieza la fase 2 — recalculado en cada killcam
            const KC_SLOWMO = 0.25;   // factor de cámara lenta

            const killcamCamera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            let kcActive = false;
            let kcSlowmoActive = false;  // true durante toda la killcam, false al terminar
            let kcImpacted = false;      // true desde que la bala principal impacta al objetivo
            let kcStartTime = 0;
            let kcCallback = null;

            // Bullet state (shared between phases)
            let kcBulletMesh = null;
            let kcBulletPos = null;
            let kcBulletDir = null;
            let kcBulletSpeed = 0;
            let kcKillerOrigin = null;
            let kcKillerCamPos = null;
            let kcVictimPos = null;
            let kcProjSpawnTime = 0;
            let kcBulletAppearElapsed = null; // ms de elapsed cuando la bala se hace visible por primera vez

            // Replay playback state
            let kcReplayFrames = null;   // array of { t, pos, quat }
            let kcReplayStart = 0;      // replay[0].t mapped to kcStartTime
            let kcMasterReplay = null;   // snapshot of the global replayBuffer (P1/P2)
            let kcKillerEntity = null;   // the Player/AIEnemy object that made the kill
            let kcKillerOwner = 0;      // owner id of the killer (1, 2, or 3 for AI)
            let kcReplayProjectiles = []; // snapshots of projectiles to spawn during Phase 1
            let kcAllEnemyReplays = null; // Map of enemy -> snapshots

            // DOM refs
            const kcOverlay = document.getElementById('killcam-overlay');
            const kcBarTop = document.getElementById('killcam-bar-top');
            const kcBarBot = document.getElementById('killcam-bar-bottom');
            const kcLabel = document.getElementById('killcam-label');
            const kcSlowmo = document.getElementById('killcam-slowmo-label');
            const kcTimerBar = document.getElementById('killcam-timer-bar');
            const kcTimerFill = document.getElementById('killcam-timer-fill');
            const kcColorGrade = document.getElementById('killcam-colorgrade');
            const kcImpact = document.getElementById('killcam-impact-flash');

            function startKillcam(onDone) {
                if (!lastKillInfo) { onDone(); return; }

                // ── FIX: Si ya hay una killcam activa (muerte rápida doble), abortarla primero
                // sin ejecutar el callback anterior — el nuevo callback reemplaza al viejo.
                if (kcActive) {
                    // Limpiar estado visual sin disparar el callback previo
                    kcCallback = null;
                    endKillcam();
                    // endKillcam pone kcActive=false y limpia todo, pero no ejecuta callback (lo pusimos null)
                }

                const info = lastKillInfo;
                kcCallback = onDone;
                kcStartTime = performance.now();
                kcActive = true;
                kcSlowmoActive = true;
                kcImpacted = false;

                // Apagar muzzle flash de todos los bots y jugadores al inicio de la killcam.
                // El render loop no llama a update() durante KILLCAM, así que el flash
                // quedaría congelado en el estado que tenía — hay que resetearlo aquí.
                [p1, p2, ...enemies].forEach(e => {
                    if (e && e.muzzleFlashTimer !== undefined) e.muzzleFlashTimer = 0;
                    if (e && e.weaponModel && e.weaponModel.userData.muzzleFlash) {
                        const flash = e.weaponModel.userData.muzzleFlash;
                        flash.visible = false;
                        flash._kcFlashUntil = 0;
                    }
                });

                // Limpiar todas las balas activas para que no aparezcan en la killcam
                projectiles.forEach(p => { if (p.mesh && p.mesh.parent) scene.remove(p.mesh); });
                projectiles.length = 0;

                // ── Positions ──
                // killerPos = weapon origin (shot was fired from here)
                const kp = info.killerPos.clone();
                // Use the actual bullet impact point if available, otherwise fall back to torso
                const vp = info.hitPos
                    ? info.hitPos.clone()
                    : info.victimPos.clone().add(new THREE.Vector3(0, 0.8, 0));
                kcVictimPos = vp;

                // Direction from killer to victim
                const raw = vp.clone().sub(kp);
                const dist = raw.length();
                kcBulletDir = dist > 0.01 ? raw.clone().normalize() : new THREE.Vector3(0, 0, 1);

                // Bullet starts exactly at the killer position
                kcBulletPos = kp.clone();
                kcKillerOrigin = kp.clone(); // frozen start for time-based position calc

                // Velocidad real del proyectil escalada al factor slow-mo — siempre fija
                const realSpeed = info.projSpeed || 30;
                kcBulletSpeed = realSpeed * KC_SLOWMO;

                // ── Duración dinámica ──
                // La bala viaja a kcBulletSpeed. Necesitamos saber en qué momento del timeline
                // de la killcam aparece la bala, para que KC_PHASE2 coincida exactamente con el impacto.
                //
                // Durante la fase 1:  replayProgress = elapsed / KC_PHASE2  →  0..1
                // La bala aparece cuando replayProgress = bulletFireOffset / replayDuration
                // es decir:  appearElapsed = (bulletFireOffset / replayDuration) * KC_PHASE2
                //
                // Después de aparecer, la bala tarda travelSec en llegar al objetivo:
                //   KC_PHASE2 = appearElapsed + travelSec * 1000
                //   KC_PHASE2 = (ratio * KC_PHASE2) + travelSec * 1000
                //   KC_PHASE2 * (1 - ratio) = travelSec * 1000
                //   KC_PHASE2 = travelSec * 1000 / (1 - ratio)
                //
                // KC_DURATION = KC_PHASE2 + 1000ms  (1 segundo fijo post-impacto)

                const travelSec = dist / kcBulletSpeed;

                const replayFramesForTiming = info.killerReplay || info.killerEnemyReplay || null;
                let ratio = 0; // proporción del replay transcurrida cuando se disparó la bala
                if (replayFramesForTiming && replayFramesForTiming.length > 1 && info.projSpawnTime) {
                    const rDur = replayFramesForTiming[replayFramesForTiming.length - 1].t
                                 - replayFramesForTiming[0].t;
                    const fireOffset = info.projSpawnTime - replayFramesForTiming[0].t;
                    ratio = rDur > 0 ? Math.min(0.99, Math.max(0, fireOffset / rDur)) : 0;
                }

                KC_PHASE2 = Math.max(500, Math.round((travelSec * 1000) / (1 - ratio)));
                KC_DURATION = KC_PHASE2 + 1000; // 1 segundo fijo después del impacto

                // ── Bullet visual ──
                if (kcBulletMesh) { scene.remove(kcBulletMesh); kcBulletMesh = null; }
                kcBulletAppearElapsed = null;
                const bMat = new THREE.MeshBasicMaterial({ color: info.projColor != null ? info.projColor : 0xffffff });
                kcBulletMesh = new THREE.Mesh(new THREE.SphereGeometry(info.killerWeapon === 'shotgun' ? 0.32 : 0.16, 8, 8), bMat);
                kcBulletMesh.position.copy(kcBulletPos);
                kcBulletMesh.visible = false;  // oculta hasta que replayT alcance el momento del disparo
                scene.add(kcBulletMesh);

                // Timestamp real del disparo dentro del buffer de replay
                kcProjSpawnTime = info.projSpawnTime || 0;

                // ── Phase 1: load replay buffer ──
                // Resolve which entity is the killer so we show the right mesh
                const killerOwner = info.killerOwner;
                kcKillerOwner = killerOwner;
                if (killerOwner === 1) {
                    kcKillerEntity = p1;
                } else if (killerOwner === 2) {
                    kcKillerEntity = p2;
                } else {
                    // AI enemy: use the exact reference saved at kill time, fallback to closest
                    if (info.killerEnemyRef && enemies.includes(info.killerEnemyRef)) {
                        kcKillerEntity = info.killerEnemyRef;
                    } else {
                        let best = null, bestDist = Infinity;
                        for (const en of enemies) {
                            const d = en.mesh.position.distanceTo(kp);
                            if (d < bestDist) { bestDist = d; best = en; }
                        }
                        kcKillerEntity = best;
                    }
                }

                // If the killer was already removed from the scene (e.g. died same frame as the kill),
                // force it back in so it's visible during the killcam.
                if (kcKillerEntity && kcKillerEntity.mesh) {
                    if (!kcKillerEntity.mesh.parent) scene.add(kcKillerEntity.mesh);
                    kcKillerEntity.mesh.visible = true;
                }

                // kcMasterReplay is the last 2s of the global world (P1/P2)
                kcMasterReplay = (info.killerReplay && info.killerReplay.length > 0)
                    ? info.killerReplay : null;

                // kcReplayFrames is specifically for the killer (human or AI) to drive the camera logic
                kcReplayFrames = (kcKillerOwner === 1 || kcKillerOwner === 2)
                    ? kcMasterReplay
                    : (info.killerEnemyReplay && info.killerEnemyReplay.length > 0 ? info.killerEnemyReplay : null);

                // Fijar el asesino en su posición del momento del kill (último frame del replay)
                // para que la bala salga desde donde se ve el arma, sin desfase temporal.
                if (kcKillerEntity && kcReplayFrames && kcReplayFrames.length > 0) {
                    const lastFrame = kcReplayFrames[kcReplayFrames.length - 1];
                    const pos  = lastFrame.meshPos || lastFrame.pos;
                    const rotY = lastFrame.meshRotY;
                    if (pos)  kcKillerEntity.mesh.position.copy(pos);
                    if (rotY !== undefined) kcKillerEntity.mesh.rotation.y = rotY;
                    if (lastFrame.armLx !== undefined) kcKillerEntity.armL.rotation.x = lastFrame.armLx;
                    if (lastFrame.armRx !== undefined) kcKillerEntity.armR.rotation.x = lastFrame.armRx;
                }

                // Map replay time: replay[0].t → kcStartTime (ms)
                if (kcReplayFrames) {
                    kcReplayStart = kcReplayFrames[0].t;
                    // AI frames use camPos/camQuat; player frames use pos/quat
                    const f0 = kcReplayFrames[0];
                    const initPos = f0.pos || f0.camPos;
                    const initQuat = f0.quat || f0.camQuat;
                    if (initPos) killcamCamera.position.copy(initPos);
                    if (initQuat) killcamCamera.quaternion.copy(initQuat);
                } else {
                    // Fallback: use saved static cam pos/quat
                    if (info.killerCamPos) kcKillerCamPos = info.killerCamPos.clone();
                    else kcKillerCamPos = kp.clone().add(new THREE.Vector3(0, 2, 0));
                    killcamCamera.position.copy(kcKillerCamPos);
                    if (info.killerCamQuat) killcamCamera.quaternion.copy(info.killerCamQuat);
                    else killcamCamera.lookAt(vp);
                }
                killcamCamera.fov = 70;
                killcamCamera.aspect = window.innerWidth / window.innerHeight;
                killcamCamera.updateProjectionMatrix();

                // ── Projectile Replay ──
                kcReplayProjectiles = projectileReplayBuffer.map(p => ({ ...p, spawned: false }));
                kcAllEnemyReplays = info.allEnemyReplays || null;

                // ── UI ──
                kcOverlay.style.display = 'block';
                kcColorGrade.style.opacity = '0';
                kcImpact.style.opacity = '0';
                // COD2: thin bars snap in fast
                setTimeout(() => { kcBarTop.style.height = '52px'; kcBarBot.style.height = '52px'; }, 10);
                // Sepia and label appear with the bars
                setTimeout(() => {
                    kcColorGrade.style.opacity = '1';
                    kcLabel.style.opacity = '1';
                }, 120);

                // ── FORZAR VISIBILIDAD SOLO DEL ENEMIGO VÍCTIMA ──
                // Solo re-añadimos y hacemos visible al enemigo que acaba de morir (victimEnemyRef).
                // Los enemigos eliminados anteriormente deben seguir ocultos/fuera de escena.
                if (info.victimEnemyRef) {
                    const ve = info.victimEnemyRef;
                    if (!ve.mesh.parent) scene.add(ve.mesh);
                    ve.mesh.visible = true;
                    ve.mesh.traverse(child => { if (child.isMesh) child.visible = true; });
                }

                gameMode = MODE.KILLCAM;
            }

            function updateKillcam(now) {
                if (!kcActive || !kcBulletPos) return;

                const elapsed = now - kcStartTime;
                const t = Math.min(elapsed / KC_DURATION, 1);

                // Timer bar shrinks
                kcTimerFill.style.transform = `scaleX(${1 - t})`;

                // ── Slow-Mo Time Mapping ──
                let replayProgress;
                if (elapsed < KC_PHASE2) {
                    replayProgress = elapsed / KC_PHASE2;  // 0→1 durante la fase 1
                } else {
                    replayProgress = 1.0;                  // congelado en el momento del kill durante fase 2
                }

                const replayDuration = (kcMasterReplay && kcMasterReplay.length > 1)
                    ? (kcMasterReplay[kcMasterReplay.length - 1].t - kcMasterReplay[0].t)
                    : 2.0;
                const replayT = (kcMasterReplay && kcMasterReplay.length > 0)
                    ? (kcMasterReplay[0].t + replayProgress * replayDuration)
                    : (performance.now() / 1000);

                // ── Bullet position ──
                // La bala permanece oculta hasta que el replay alcanza el momento real del disparo.
                // Una vez visible, avanza con su tiempo propio (elapsed desde que apareció),
                // independiente de replayT — así no se congela en fase 2.
                if (kcProjSpawnTime > 0 && replayT < kcProjSpawnTime) {
                    // Disparo aún no ha ocurrido en el replay
                    kcBulletMesh.visible = false;
                    kcBulletPos.copy(kcKillerOrigin);
                    kcBulletAppearElapsed = null;
                } else {
                    // Primera vez que aparece: guardar el elapsed en ese momento
                    if (kcBulletAppearElapsed === null) {
                        kcBulletAppearElapsed = elapsed;
                        // Sonido de disparo al aparecer la bala (arma del asesino)
                        const weapon = lastKillInfo && lastKillInfo.killerWeapon ? lastKillInfo.killerWeapon : 'pistol';
                        SFX.shoot(weapon, 0.85);
                    }
                    kcBulletMesh.visible = true;
                    // Avanzar en tiempo real de killcam desde que apareció
                    const bulletSec = (elapsed - kcBulletAppearElapsed) / 1000;
                    const distTravelled = kcBulletSpeed * bulletSec;
                    kcBulletPos.copy(kcKillerOrigin).addScaledVector(kcBulletDir, distTravelled);
                    // Clamp: nunca pasar al objetivo
                    if (kcBulletPos.clone().sub(kcKillerOrigin).dot(kcBulletDir) >=
                        kcVictimPos.clone().sub(kcKillerOrigin).dot(kcBulletDir)) {
                        kcBulletPos.copy(kcVictimPos);
                        if (!kcImpacted) {
                            // Sonido de impacto en bot al momento exacto del hit
                            SFX.impact('bot', 0.9);
                        }
                        kcImpacted = true;  // la bala ha llegado — congelar las demás
                    }
                }
                kcBulletMesh.position.copy(kcBulletPos);

                // ── Ensuring Visibility ──
                p1.mesh.visible = true;
                if (p2 && p2.mesh) p2.mesh.visible = true;
                // Mantener visible SOLO el enemigo víctima (el recién eliminado).
                // Los enemigos muertos anteriormente no deben reaparecer.
                if (lastKillInfo && lastKillInfo.victimEnemyRef) {
                    const ve = lastKillInfo.victimEnemyRef;
                    if (!ve.mesh.parent) scene.add(ve.mesh);
                    ve.mesh.visible = true;
                    ve.mesh.traverse(child => { if (child.isMesh) child.visible = true; });
                }

                // ── REPLAY ALL ENTITIES (Always active, synchronized with replayT) ──
                if (kcMasterReplay && kcMasterReplay.length > 1) {
                    let snapIdx = 0;
                    for (let j = 0; j < kcMasterReplay.length - 1; j++) {
                        if (kcMasterReplay[j + 1].t >= replayT) { snapIdx = j; break; }
                    }
                    const fa = kcMasterReplay[snapIdx];
                    const fb = kcMasterReplay[snapIdx + 1];
                    const span = fb.t - fa.t;
                    const alpha = span > 0.00001 ? (replayT - fa.t) / span : 1;

                    // Replay P1
                    p1.mesh.position.lerpVectors(fa.meshPos, fb.meshPos, alpha);
                    p1.mesh.rotation.y = fa.meshRotY + (fb.meshRotY - fa.meshRotY) * alpha;
                    p1.armL.rotation.x = fa.armLx + (fb.armLx - fa.armLx) * alpha;
                    p1.armR.rotation.x = fa.armRx + (fb.armRx - fa.armRx) * alpha;
                    p1.legL.rotation.x = fa.legLx + (fb.legLx - fa.legLx) * alpha;
                    p1.legR.rotation.x = fa.legRx + (fb.legRx - fa.legRx) * alpha;

                    // Replay P2 (if exists in snapshot)
                    if (fa.p2meshPos && fb.p2meshPos) {
                        p2.mesh.position.lerpVectors(fa.p2meshPos, fb.p2meshPos, alpha);
                        p2.mesh.rotation.y = fa.p2meshRotY + (fb.p2meshRotY - fa.p2meshRotY) * alpha;
                        p2.armL.rotation.x = fa.p2armLx + (fb.p2armLx - fa.p2armLx) * alpha;
                        p2.armR.rotation.x = fa.p2armRx + (fb.p2armRx - fa.p2armRx) * alpha;
                        p2.legL.rotation.x = fa.p2legLx + (fb.p2legLx - fa.p2legLx) * alpha;
                        p2.legR.rotation.x = fa.p2legRx + (fb.p2legRx - fa.p2legRx) * alpha;
                    }
                }

                // Replay All AI Enemies from individual snapshots
                if (kcAllEnemyReplays) {
                    for (const [enemy, buf] of kcAllEnemyReplays) {
                        if (buf.length < 2) continue;
                        let eIdx = 0;
                        for (let j = 0; j < buf.length - 1; j++) {
                            if (buf[j + 1].t >= replayT) { eIdx = j; break; }
                        }
                        const efa = buf[eIdx];
                        const efb = buf[eIdx + 1];
                        const eSpan = efb.t - efa.t;
                        const eAlpha = eSpan > 0.00001 ? (replayT - efa.t) / eSpan : 1;

                        enemy.mesh.position.lerpVectors(efa.meshPos, efb.meshPos, eAlpha);
                        enemy.mesh.rotation.y = efa.meshRotY + (efb.meshRotY - efa.meshRotY) * eAlpha;
                        enemy.armL.rotation.x = efa.armLx + (efb.armLx - efa.armLx) * eAlpha;
                        enemy.armR.rotation.x = efa.armRx + (efb.armRx - efa.armRx) * eAlpha;
                        enemy.legL.rotation.x = efa.legLx + (efb.legLx - efa.legLx) * eAlpha;
                        enemy.legR.rotation.x = efa.legRx + (efb.legRx - efa.legRx) * eAlpha;
                    }
                }

                // Replay projectile spawns at their original timestamps
                for (const rp of kcReplayProjectiles) {
                    if (!rp.spawned && replayT >= rp.t) {
                        rp.spawned = true;
                        const mesh = new THREE.Mesh(new THREE.SphereGeometry(rp.weaponKey === 'shotgun' ? 0.30 : 0.15), new THREE.MeshBasicMaterial({
                            color: 0x999999
                        }));
                        mesh.position.copy(rp.pos);
                        scene.add(mesh);
                        projectiles.push({
                            mesh,
                            vel: rp.dir.clone().multiplyScalar(rp.speed),
                            life: rp.range / rp.speed,
                            owner: rp.ownerId,
                            damage: rp.damage,
                            origin: rp.pos.clone(),
                            isReplay: true  // purely visual — skip all collision checks
                        });

                        // Activar muzzle flash de la entidad que disparó
                        let shooter = null;
                        if (rp.ownerId === 1) shooter = p1;
                        else if (rp.ownerId === 2) shooter = p2;
                        else shooter = enemies.find(e => e.id === rp.ownerId) || enemies[0] || null;
                        if (shooter && shooter.weaponModel && shooter.weaponModel.userData.muzzleFlash) {
                            shooter.weaponModel.userData.muzzleFlash.visible = true;
                            shooter.weaponModel.userData.muzzleFlash.scale.setScalar(0.5 + Math.random() * 1.5);
                            shooter.weaponModel.userData.muzzleFlash._kcFlashUntil = now + 150; // 150ms real
                        }
                    }
                }

                // Apagar flashes cuyo tiempo expiró (basado en timestamp real, no en slow-mo)
                [p1, p2, ...enemies].forEach(e => {
                    if (!e || !e.weaponModel || !e.weaponModel.userData.muzzleFlash) return;
                    const flash = e.weaponModel.userData.muzzleFlash;
                    if (flash.visible) {
                        if (!flash._kcFlashUntil || now >= flash._kcFlashUntil) {
                            flash.visible = false;
                            flash._kcFlashUntil = 0;
                        } else {
                            flash.scale.setScalar(0.5 + Math.random() * 1.5); // parpadeo
                        }
                    }
                });

                // ── CAMERA / PHASE LOGIC ──
                // Mientras la bala no se ha disparado: cámara detrás del asesino
                // En cuanto la bala aparece: cámara sigue la bala hasta el impacto y 1s después
                const bulletVisible = kcBulletAppearElapsed !== null;

                if (!bulletVisible) {
                    // Pre-disparo: cámara detrás del asesino
                    killcamCamera.fov = 70;
                    killcamCamera.updateProjectionMatrix();
                    let killer = kcKillerEntity;
                    if (killer && killer.mesh) {
                        const bodyPos = killer.mesh.position.clone().add(new THREE.Vector3(0, 0.8, 0));
                        const facingY = killer.mesh.rotation.y;
                        const chasePos = bodyPos.clone()
                            .addScaledVector(new THREE.Vector3(Math.sin(facingY), 0, Math.cos(facingY)), -6)
                            .add(new THREE.Vector3(0, 2.5, 0));
                        killcamCamera.position.copy(chasePos);
                        killcamCamera.lookAt(kcVictimPos);
                    } else {
                        if (kcKillerCamPos) killcamCamera.position.copy(kcKillerCamPos);
                        killcamCamera.lookAt(kcVictimPos);
                    }
                } else {
                    // Post-disparo: cámara sigue la bala
                    if (!killcamCamera._phase2started) {
                        killcamCamera._phase2started = true;
                        killcamCamera.fov = 58;
                        killcamCamera.updateProjectionMatrix();
                    }

                    // Cámara: 4 unidades detrás de la bala, 1 arriba
                    // El lerp se escala con KC_SLOWMO para que la cámara también se mueva en cámara lenta
                    const behind = kcBulletDir.clone().negate().multiplyScalar(4);
                    const targetCamPos = kcBulletPos.clone().add(behind).add(new THREE.Vector3(0, 1, 0));
                    const camLerpFactor = kcSlowmoActive ? 0.18 * KC_SLOWMO : 0.18;
                    killcamCamera.position.lerp(targetCamPos, camLerpFactor);
                    killcamCamera.lookAt(kcVictimPos);

                    // FOV se cierra al acercarse al objetivo (también en slowmo)
                    const distToVic = kcBulletPos.distanceTo(kcVictimPos);
                    const fovGoal = Math.max(34, 58 - (1 - Math.min(distToVic / 15, 1)) * 24);
                    const fovLerpFactor = kcSlowmoActive ? 0.08 * KC_SLOWMO : 0.08;
                    killcamCamera.fov += (fovGoal - killcamCamera.fov) * fovLerpFactor;
                    killcamCamera.updateProjectionMatrix();

                    // Shake cerca del impacto
                    if (elapsed >= KC_PHASE2 - 100) {
                        killcamCamera.position.add(new THREE.Vector3(
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1
                        ));
                    }

                    // Flash blanco en el impacto
                    if (distToVic < 2.5) {
                        kcImpact.style.opacity = String(((2.5 - distToVic) / 2.5 * 0.5).toFixed(2));
                    }
                }

                if (t >= 1) endKillcam();
            }

            function endKillcam() {
                kcActive = false;
                kcSlowmoActive = false;  // slowmo se desactiva al terminar la killcam
                kcImpacted = false;
                kcKillerOrigin = null;
                kcReplayFrames = null;
                kcKillerEntity = null;
                kcKillerOwner = 0;
                kcProjSpawnTime = 0;
                kcBulletAppearElapsed = null;
                killcamCamera._phase2started = false;
                if (kcBulletMesh) { scene.remove(kcBulletMesh); kcBulletMesh = null; }
                kcOverlay.style.display = 'none';
                kcBarTop.style.height = '0';
                kcBarBot.style.height = '0';
                kcLabel.style.opacity = '0';
                kcSlowmo.style.opacity = '0';
                kcTimerBar.style.opacity = '0';
                kcColorGrade.style.opacity = '0';
                kcImpact.style.opacity = '0';
                killcamCamera.fov = 70;
                killcamCamera.updateProjectionMatrix();
                // CHANGED: Patch 2D — vaciar buffers de replay al finalizar la killcam
                projectileReplayBuffer.clear();
                if (kcCallback) { kcCallback(); kcCallback = null; }
            }

            function spawnLobbyBots() {
                // No lobby bots — pure city cinematic
                if (p1.mesh.parent) scene.remove(p1.mesh);
                if (p2.mesh.parent) scene.remove(p2.mesh);
                lobbyBots.length = 0;
            }

            function clearLobbyBots() {
                lobbyBots.forEach(bot => {
                    if (bot.mesh.parent) scene.remove(bot.mesh);
                });
                lobbyBots.length = 0;
            }

            // Alias para compatibilidad con código que usa clearMenuBots
            window.clearMenuBots = clearLobbyBots;

            function spawnProjectile(pos, dir, speed, ownerId, damage, color, range = 100, weaponKey = '') {
                const bulletRadius = weaponKey === 'shotgun' ? 0.30 : 0.15;
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(bulletRadius), new THREE.MeshBasicMaterial({
                    color: 0x999999
                }));
                mesh.position.copy(pos);
                scene.add(mesh);

                if (dir.length() > 0.01) dir.normalize();
                else dir.set(0, 0, 1);

                projectiles.push({
                    mesh,
                    vel: dir.multiplyScalar(speed),
                    life: range / speed,
                    owner: ownerId,
                    damage: damage,
                    origin: pos.clone(), // Guardamos el origen del disparo para la cámara
                    spawnTime: performance.now() / 1000  // timestamp real del disparo
                });

                // Record for replay
                if (gameMode === MODE.SOLO || gameMode === MODE.PVP) {
                    projectileReplayBuffer.push({
                        t: performance.now() / 1000,
                        pos: pos.clone(),
                        dir: dir.clone().normalize(),
                        speed: speed,
                        ownerId: ownerId,
                        damage: damage,
                        color: color,
                        range: range,
                        weaponKey: weaponKey
                    });
                }
            }

            // -- INPUT --
            const keys = {}

                ;
            let prevP2Buttons = []; // Track P2 gamepad button states
            let gpOptionsPrev = false; // estado anterior del botón Options
            // Debug Last Key
            let lastKeyDebug = "None";

            window.addEventListener('keydown', e => {
                // Evitar que Space/Enter activen botones enfocados mientras se juega
                if ((e.code === 'Space' || e.code === 'Enter' || e.code === 'NumpadEnter') &&
                    (gameMode === MODE.SOLO || gameMode === MODE.PVP) &&
                    ui.controlsScreen.classList.contains('hidden')) {
                    if (document.activeElement && document.activeElement.tagName === 'BUTTON') {
                        document.activeElement.blur();
                    }
                    if (e.code === 'Space') e.preventDefault();
                }

                // Escape: abrir/cerrar configuración durante el juego
                if (e.code === 'Escape' && (gameMode === MODE.SOLO || gameMode === MODE.PVP || gameMode === MODE.PAUSED)) {
                    document.getElementById('ingame-controls-btn').click();
                    return;
                }
                keys[e.code] = true;
                lastKeyDebug = e.code; // Update debug var
            });
            window.addEventListener('keyup', e => keys[e.code] = false);

            document.body.addEventListener('mousemove', e => {
                if (document.pointerLockElement === document.body) {
                    // NaN Shield
                    const mx = e.movementX || 0;
                    const my = e.movementY || 0;
                    if (Math.abs(mx) > 500 || Math.abs(my) > 500) return; // Ignore jumps

                    // Sensibilidad: normal o ADS según si está apuntando
                    const baseSens = p1.input.aim ? p1SensAds : p1SensBase;
                    p1.cameraAngle.y -= mx * baseSens;
                    p1.cameraAngle.x += my * baseSens;

                    // Safety Clamp
                    if (isNaN(p1.cameraAngle.x)) p1.cameraAngle.x = 0;
                    if (isNaN(p1.cameraAngle.y)) p1.cameraAngle.y = Math.PI;

                    p1.cameraAngle.x = Math.max(-1.4, Math.min(1.4, p1.cameraAngle.x));
                }
            });

            // Estado del ratón para P1 (persiste entre frames)
            const mouseState = { shoot: false, aim: false };

            document.body.addEventListener('mousedown', (e) => {
                // Prevent PointerLock in Menus
                if (gameMode === MODE.MENU || gameMode === MODE.PVP_SELECT || gameMode === MODE.END) return;
                // Prevent PointerLock when settings screen is open or game is paused
                if (!ui.controlsScreen.classList.contains('hidden') || gameMode === MODE.PAUSED) return;

                if (document.pointerLockElement !== document.body) document.body.requestPointerLock();
                else {
                    if (e.button === 0) mouseState.shoot = true;
                    if (e.button === 2) mouseState.aim = true;
                }
            });
            document.body.addEventListener('mouseup', (e) => {
                if (e.button === 0) mouseState.shoot = false;
                if (e.button === 2) mouseState.aim = false;
            });
            // Disable context menu for right click aim
            window.addEventListener('contextmenu', e => e.preventDefault());

            function updateInput() {
                // Prevent Input in Menus
                if (gameMode !== MODE.SOLO && gameMode !== MODE.PVP) return;

                // P1 teclado
                p1.input.y = (keys['KeyW'] ? 1 : 0) - (keys['KeyS'] ? 1 : 0);
                p1.input.x = (keys['KeyD'] ? 1 : 0) - (keys['KeyA'] ? 1 : 0);
                p1.input.jump = keys['Space'];
                p1.input.reload = keys['KeyR'];
                p1.input.sprint = keys['ShiftLeft'];
                // Aplicar estado del ratón (persiste entre frames)
                p1.input.shoot = mouseState.shoot;
                p1.input.aim = mouseState.aim;

                // P2
                // Check all gamepads for P2 input if 1v1
                let gp = null;

                if (navigator.getGamepads) {
                    const gamepads = navigator.getGamepads();

                    for (let i = 0; i < gamepads.length; i++) {
                        if (gamepads[i] && gamepads[i].buttons && gamepads[i].buttons.length > 0) {
                            // Simple logic: Use the first gamepad found as "The Gamepad"
                            gp = gamepads[i];
                            break;
                        }
                    }
                }

                let p2MoveX = 0,
                    p2MoveY = 0,
                    p2Jump = false,
                    p2Shoot = false,
                    p2Reload = false,
                    p2Sprint = false,
                    p2Aim = false;

                // Keyboard Fallback
                p2MoveX = (keys['ArrowRight'] ? 1 : 0) - (keys['ArrowLeft'] ? 1 : 0);
                p2MoveY = (keys['ArrowUp'] ? 1 : 0) - (keys['ArrowDown'] ? 1 : 0);
                p2Jump = keys['ControlRight'] || keys['Numpad0'];
                p2Shoot = keys['Enter'] || keys['NumpadEnter'];
                p2Reload = keys['ShiftRight'];

                // Gamepad
                if (gp) {
                    const deadzone = 0.2;

                // Options (botón 9) abre/cierra configuración en cualquier modo de juego
                    if (gp.buttons && gp.buttons.length > 9 && gp.buttons[9].pressed) {
                        if (!gpOptionsPrev && (gameMode === MODE.SOLO || gameMode === MODE.PVP || gameMode === MODE.PAUSED)) {
                            document.getElementById('ingame-controls-btn').click();
                        }
                        gpOptionsPrev = true;
                    } else if (gp.buttons && gp.buttons.length > 9) {
                        gpOptionsPrev = false;
                    }

                    if (gameMode === MODE.SOLO) {
                        // Leer botones primero para que aim esté actualizado al calcular sens
                        if (gp.buttons && gp.buttons.length > 6) {
                            if (gp.buttons[0] && gp.buttons[0].pressed) p1.input.jump = true;
                            if (gp.buttons[2] && gp.buttons[2].pressed) p1.input.reload = true;
                            if (gp.buttons[6] && gp.buttons[6].value > 0.5) p1.input.aim = true;
                            if (gp.buttons[7] && gp.buttons[7].value > 0.5) p1.input.shoot = true;
                            if (gp.buttons[10] && gp.buttons[10].pressed) p1.input.sprint = true;
                        }
                        // En SOLO el gamepad suma a P1 sin bloquear teclado/ratón
                        if (gp.axes && gp.axes.length > 1) {
                            if (Math.abs(gp.axes[0]) > deadzone) p1.input.x += gp.axes[0];
                            if (Math.abs(gp.axes[1]) > deadzone) p1.input.y += -gp.axes[1];
                        }
                        if (gp.axes && gp.axes.length > 3) {
                            const lookX = Math.abs(gp.axes[2]) > deadzone ? gp.axes[2] : 0;
                            const lookY = Math.abs(gp.axes[3]) > deadzone ? gp.axes[3] : 0;
                            const gpSens = p1.input.aim ? p2SensAds : p2SensBase;
                            p1.cameraAngle.y -= lookX * gpSens;
                            p1.cameraAngle.x += lookY * gpSens;
                            if (isNaN(p1.cameraAngle.x)) p1.cameraAngle.x = 0;
                            if (isNaN(p1.cameraAngle.y)) p1.cameraAngle.y = Math.PI;
                            p1.cameraAngle.x = Math.max(-1.4, Math.min(1.4, p1.cameraAngle.x));
                        }
                    } else {
                        // En PVP el gamepad controla P2
                        if (gp.axes && gp.axes.length > 1) {
                            if (Math.abs(gp.axes[0]) > deadzone) p2MoveX = gp.axes[0];
                            if (Math.abs(gp.axes[1]) > deadzone) p2MoveY = -gp.axes[1];
                        }
                        if (gp.axes && gp.axes.length > 3) {
                            const lookX = Math.abs(gp.axes[2]) > deadzone ? gp.axes[2] : 0;
                            const lookY = Math.abs(gp.axes[3]) > deadzone ? gp.axes[3] : 0;
                            const gpSens = p2.input.aim ? p2SensAds : p2SensBase;
                            p2.cameraAngle.y -= lookX * gpSens;
                            p2.cameraAngle.x += lookY * gpSens;
                            if (isNaN(p2.cameraAngle.x)) p2.cameraAngle.x = 0;
                            if (isNaN(p2.cameraAngle.y)) p2.cameraAngle.y = Math.PI;
                            p2.cameraAngle.x = Math.max(-1.4, Math.min(1.4, p2.cameraAngle.x));
                        }
                        if (gp.buttons && gp.buttons.length > 10) {
                            if (gp.buttons[0].pressed) p2Jump = true;
                            if (gp.buttons[2].pressed) p2Reload = true;
                            if (gp.buttons[6] && gp.buttons[6].value > 0.5) p2Aim = true;
                            if (gp.buttons[7] && gp.buttons[7].value > 0.5) p2Shoot = true;
                            if (gp.buttons[10].pressed) p2Sprint = true;
                        }
                    }
                }

                p2.input.x = p2MoveX;
                p2.input.y = p2MoveY;
                p2.input.jump = p2Jump;
                p2.input.shoot = p2Shoot;
                p2.input.reload = p2Reload;
                p2.input.sprint = p2Sprint;
                p2.input.aim = p2Aim;
            }

            // ... Collisions & Loop ...
            // (Remaining functions logic)

            // Flash de chispa blanca al impactar objeto sólido
            function spawnImpactFlash(pos) {
                const flashGeo = new THREE.SphereGeometry(0.18, 5, 4);
                const flashMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const flash = new THREE.Mesh(flashGeo, flashMat);
                flash.position.copy(pos);
                scene.add(flash);
                let life = 0.07; // segundos
                const tickFlash = (dt) => {
                    life -= dt;
                    if (life <= 0) { scene.remove(flash); return; }
                    flash.scale.setScalar(1 + (0.07 - life) * 8);
                    flash.material.opacity = life / 0.07;
                    requestAnimationFrame(() => tickFlash(0.016));
                };
                requestAnimationFrame(() => tickFlash(0.016));
            }

            // Fast segment vs AABB intersection (slab method) — no matrix dependency
            // Swept segment vs sphere — returns true if the segment p0→p1 passes within 'radius' of 'center'
            function segmentHitsSphere(p0, p1, center, radius) {
                const dx = p1.x - p0.x, dy = p1.y - p0.y, dz = p1.z - p0.z;
                const fx = p0.x - center.x, fy = p0.y - center.y, fz = p0.z - center.z;
                const a = dx*dx + dy*dy + dz*dz;
                if (a < 1e-12) {
                    // Segment has no length — fallback to point test
                    return fx*fx + fy*fy + fz*fz < radius*radius;
                }
                const b = 2 * (fx*dx + fy*dy + fz*dz);
                const c = fx*fx + fy*fy + fz*fz - radius*radius;
                let disc = b*b - 4*a*c;
                if (disc < 0) return false;
                disc = Math.sqrt(disc);
                const t0 = (-b - disc) / (2*a);
                const t1 = (-b + disc) / (2*a);
                return (t0 >= 0 && t0 <= 1) || (t1 >= 0 && t1 <= 1) || (t0 <= 0 && t1 >= 1);
            }

            function segmentHitsAABB(p0, p1, box3, margin = 0.15) {
                // margin expands the AABB slightly to catch thin-wall edge cases at any bullet speed
                const dx = p1.x - p0.x, dy = p1.y - p0.y, dz = p1.z - p0.z;
                const mn = box3.min, mx = box3.max;
                let tmin = 0, tmax = 1;
                for (let axis = 0; axis < 3; axis++) {
                    const o  = axis===0 ? p0.x : axis===1 ? p0.y : p0.z;
                    const d  = axis===0 ? dx   : axis===1 ? dy   : dz;
                    const lo = (axis===0 ? mn.x : axis===1 ? mn.y : mn.z) - margin;
                    const hi = (axis===0 ? mx.x : axis===1 ? mx.y : mx.z) + margin;
                    if (Math.abs(d) < 1e-9) { if (o < lo || o > hi) return false; }
                    else {
                        let t1 = (lo - o) / d, t2 = (hi - o) / d;
                        if (t1 > t2) { const tmp=t1; t1=t2; t2=tmp; }
                        tmin = Math.max(tmin, t1);
                        tmax = Math.min(tmax, t2);
                        if (tmin > tmax) return false;
                    }
                }
                return true;
            }

            // Cache of Box3 per solid object — rebuilt when solidCache is rebuilt
            function getSolidBboxes(key) {
                const solidObjs = window._solidCache && window._solidCache[key];
                if (!solidObjs || solidObjs.length === 0) return null;
                if (!window._bboxCache || window._bboxCache.key !== key || window._bboxCache.objs !== solidObjs) {
                    // Force world matrix update on entire hierarchy before computing bboxes
                    const grp = typeof _mapGroups !== 'undefined' && _mapGroups[key];
                    if (grp) grp.updateMatrixWorld(true);
                    window._bboxCache = { key, objs: solidObjs, boxes: solidObjs.map(o => {
                        return new THREE.Box3().setFromObject(o);
                    })};
                }
                return window._bboxCache.boxes;
            }

            function checkCollisions() {

                // Proj vs Environment/Players
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    // Skip collision for killcam replay bullets — purely visual, no damage/removal
                    if (p.isReplay) continue;
                    // Remove from scene if dead

                    // Vs Terrain/Tree (reused logic)
                    const h = getTerrainHeight(p.mesh.position.x, p.mesh.position.z);

                    if (p.mesh.position.y < h || p.mesh.position.y < -10) {
                        if (p.prevPos) p.mesh.position.copy(p.prevPos);
                        SFX.impact('grass', sfxDistVol(p.mesh.position));
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                        continue;
                    }

                    // Vs Trees
                    let hitTree = false;

                    for (let t of treePos) {
                        const treeBaseY = getTerrainHeight(t.x, t.z);
                        // Check if hit tree cylinder (Approx Radius 1, Height 6)
                        const dx = p.mesh.position.x - t.x;
                        const dz = p.mesh.position.z - t.z;

                        if (dx * dx + dz * dz < 1.5) {

                            // Radius ~1.2
                            if (p.mesh.position.y > treeBaseY && p.mesh.position.y < treeBaseY + 6) {
                                hitTree = true;
                                break;
                            }
                        }
                    }

                    // Vs Stones
                    if (!hitTree) {
                        for (let s of stonePos) {
                            const stoneBaseY = getTerrainHeight(s.x, s.z);
                            const dx = p.mesh.position.x - s.x;
                            const dz = p.mesh.position.z - s.z;
                            const r = 1.3 * s.s; // hitbox ligeramente menor que el visual

                            if (dx * dx + dz * dz < r * r) {
                                if (p.mesh.position.y > stoneBaseY - 1 && p.mesh.position.y < stoneBaseY + 1.6 * s.s) {
                                    hitTree = true;
                                    break;
                                }
                            }
                        }
                    }

                    if (hitTree) {
                        if (p.prevPos) p.mesh.position.copy(p.prevPos);
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                        // Detectar si fue árbol o piedra
                        let hitStone = false;
                        for (let s of stonePos) {
                            const dx = p.mesh.position.x - s.x;
                            const dz = p.mesh.position.z - s.z;
                            if (dx * dx + dz * dz < (1.3 * s.s) * (1.3 * s.s)) { hitStone = true; break; }
                        }
                        SFX.impact(hitStone ? 'rock' : 'tree', sfxDistVol(p.mesh.position));
                        continue;
                    }

                    // ── VS SOLID OBJECTS (walls, buildings, props) ─────────────
                    if (activeMapKey !== 'valley') {
                        const _cacheKey = activeMapKey || 'raid';
                        const boxes = getSolidBboxes(_cacheKey);
                        if (boxes) {
                            let hitSolid = false;
                            const cur = p.mesh.position;
                            const prv = p.prevPos || cur;
                            for (let b = 0; b < boxes.length; b++) {
                                // Swept segment test — catches thin walls at any bullet speed
                                if (segmentHitsAABB(prv, cur, boxes[b])) {
                                    hitSolid = true; break;
                                }
                            }
                            if (hitSolid) {
                                if (p.prevPos) p.mesh.position.copy(p.prevPos);
                                SFX.impact('rock', sfxDistVol(p.mesh.position));
                                spawnImpactFlash(p.mesh.position.clone());
                                scene.remove(p.mesh);
                                projectiles.splice(i, 1);
                                continue;
                            }
                        }
                    }

                    // Collision — swept segment test vs body capsule.
                    // mesh.position es los pies; el centro del cuerpo está ~0.6 unidades más arriba.
                    const HIT_RADIUS = 0.9;
                    const BODY_OFFSET_Y = 0.6;
                    const prv2 = p.prevPos || p.mesh.position;

                    const _bodyCenter = (mesh) => new THREE.Vector3(mesh.position.x, mesh.position.y + BODY_OFFSET_Y, mesh.position.z);

                    let hit = null;
                    if (p.owner !== 1 && segmentHitsSphere(prv2, p.mesh.position, _bodyCenter(p1.mesh), HIT_RADIUS)) {
                        hit = p1.hp > 0 ? p1 : '__dead_p1__';
                    }
                    if (p2 && p2.mesh.parent && (gameMode === MODE.PVP || gameMode === MODE.KILLCAM) && p.owner !== 2 && segmentHitsSphere(prv2, p.mesh.position, _bodyCenter(p2.mesh), HIT_RADIUS)) {
                        hit = p2.hp > 0 ? p2 : '__dead_p2__';
                    }

                    // Remove bullet immediately if it hit a dead player (no extra damage, no pass-through)
                    if (hit === '__dead_p1__' || hit === '__dead_p2__') {
                        if (p.prevPos) p.mesh.position.copy(p.prevPos);
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                        continue;
                    }

                    if ((gameMode === MODE.SOLO || gameMode === MODE.KILLCAM) && p.owner === 1) {

                        // Player shot enemy — check alive AND dead bodies (no pass-through during killcam)
                        for (let e of enemies) {
                            const checkHp = gameMode === MODE.KILLCAM ? true : e.hp > 0;
                            if (checkHp && segmentHitsSphere(prv2, p.mesh.position, _bodyCenter(e.mesh), HIT_RADIUS)) {
                                if (e.hp > 0) {
                                    const prevHp = e.hp;
                                    e.takeDamage(p.damage);
                                    if (prevHp > 0 && e.hp <= 0) {
                                        e.hp = 0;
                                        lastKillInfo = {
                                            killerPos: p.origin ? p.origin.clone() : p1.mesh.position.clone(),
                                            victimPos: e.mesh.position.clone(),
                                            hitPos: p.mesh.position.clone(),
                                            killerCamPos: p1.camera.position.clone(),
                                            killerCamQuat: p1.camera.quaternion.clone(),
                                            killerReplay: snapshotReplay(),
                                            allEnemyReplays: snapshotAllEnemyReplays(),
                                            killerOwner: p.owner,
                                            killerWeapon: p.owner === 1 ? p1.currentWeaponKey
                                                : p.owner === 2 ? p2.currentWeaponKey : 'pistol',
                                            victimEnemyRef: e,   // referencia al enemigo asesinado por el jugador
                                            projColor: p.mesh.material.color.getHex(),
                                            projSpeed: p.vel.length(),
                                            projSpawnTime: p.spawnTime
                                        };
                                    }
                                }
                                // Always remove bullet — dead or alive, no pass-through
                                if (p.prevPos) p.mesh.position.copy(p.prevPos);
                                scene.remove(p.mesh);
                                projectiles.splice(i, 1);
                                hit = e;
                                break;
                            }
                        }

                        if (hit) continue;
                    }

                    if (hit === p1 || hit === p2) {
                        if (hit.hp > 0) {
                            const prevHp = hit.hp;
                            hit.takeDamage(p.damage); // Use Projectile Damage

                            if (prevHp > 0 && hit.hp <= 0) {
                                // P1 o P2 murieron: calculamos killer/víctima según el proyectil
                                const victimPos = hit.mesh.position.clone();
                                const killerPos = p.origin ? p.origin.clone() : p.mesh.position.clone();

                                // Resolve killer entity and camera position for all modes
                                let killerCamPos;
                                if (p.owner === 1) {
                                    killerCamPos = p1.camera.position.clone();
                                } else if (p.owner === 2) {
                                    killerCamPos = p2.camera.position.clone();
                                } else {
                                    // AI enemy (owner=3): find the closest living enemy to the shot origin
                                    let bestEnemy = null, bestDist = Infinity;
                                    for (const en of enemies) {
                                        if (en.hp > 0) {
                                            const d = en.mesh.position.distanceTo(killerPos);
                                            if (d < bestDist) { bestDist = d; bestEnemy = en; }
                                        }
                                    }
                                    if (bestEnemy && bestEnemy.camera) {
                                        killerCamPos = bestEnemy.camera.position.clone();
                                    } else {
                                        // Fallback: reconstruct cam behind killerPos looking at victim
                                        const toV = victimPos.clone().sub(killerPos).normalize();
                                        killerCamPos = killerPos.clone()
                                            .addScaledVector(toV.clone().negate(), 6)
                                            .add(new THREE.Vector3(0, 3, 0));
                                    }
                                }

                                // Find the enemy that fired this projectile (closest to origin)
                                let killerEnemy = null, bestDist2 = Infinity;
                                for (const en of enemies) {
                                    const d = en.mesh.position.distanceTo(killerPos);
                                    if (d < bestDist2) { bestDist2 = d; killerEnemy = en; }
                                }

                                lastKillInfo = {
                                    killerPos,
                                    victimPos,
                                    hitPos: p.mesh.position.clone(),
                                    killerCamPos,
                                    killerCamQuat: p.owner === 1 ? p1.camera.quaternion.clone()
                                        : p.owner === 2 ? p2.camera.quaternion.clone()
                                            : (killerEnemy && killerEnemy.camera ? killerEnemy.camera.quaternion.clone() : null),
                                    killerReplay: snapshotReplay(),
                                    allEnemyReplays: snapshotAllEnemyReplays(),
                                    killerOwner: p.owner,
                                    killerWeapon: p.owner === 1 ? p1.currentWeaponKey
                                        : p.owner === 2 ? p2.currentWeaponKey
                                            : (killerEnemy ? killerEnemy.currentWeaponKey : 'pistol'),
                                    killerEnemyReplay: (killerEnemy && enemyReplayBuffers.has(killerEnemy))
                                        ? enemyReplayBuffers.get(killerEnemy).map(f => ({
                                            t: f.t,
                                            meshPos: f.meshPos.clone(),
                                            meshRotY: f.meshRotY,
                                            armLx: f.armLx, armRx: f.armRx,
                                            legLx: f.legLx, legRx: f.legRx,
                                            camPos: f.camPos.clone(),
                                            camQuat: f.camQuat.clone(),
                                        }))
                                        : null,
                                    killerEnemyRef: killerEnemy,
                                    projColor: p.mesh.material.color.getHex(),
                                    projSpeed: p.vel.length(),
                                    projSpawnTime: p.spawnTime
                                };
                            }
                        }
                        // Always remove bullet on contact — alive or dead, no pass-through
                        if (p.prevPos) p.mesh.position.copy(p.prevPos);
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                    }
                }
            }

            let lastGpInputTime = 0;

            function updatePvPMenuInput() {
                const now = Date.now();
                if (now - lastGpInputTime < 150) return; // Faster debounce for responsiveness

                const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
                let gp = null;

                for (let i = 0; i < gamepads.length; i++) {
                    if (gamepads[i] && gamepads[i].buttons && gamepads[i].buttons.length > 0) {
                        gp = gamepads[i];
                        break; // Use the first active gamepad found
                    }
                }

                if (!gp) return;

                // Analog Stick Threshold
                const axisThreshold = 0.5;
                // Standard mapping: Axes[0] is Left Stick X. Buttons[14] is D-Pad Left, [15] is Right.
                let left = false;
                let right = false;

                if (gp.axes && gp.axes.length > 0) {
                    left = left || gp.axes[0] < -axisThreshold;
                    right = right || gp.axes[0] > axisThreshold;
                }

                if (gp.buttons && gp.buttons.length >= 16) {
                    left = left || gp.buttons[14].pressed;
                    right = right || gp.buttons[15].pressed;
                }

                if (left || right) {
                    const keys = Object.keys(WEAPONS);
                    let idx = keys.indexOf(p2SelectedWeapon);

                    if (left) idx--;
                    if (right) idx++;

                    if (idx < 0) idx = keys.length - 1;
                    if (idx >= keys.length) idx = 0;

                    p2SelectedWeapon = keys[idx];
                    updatePvPWeaponUI();
                    lastGpInputTime = now;
                }

                // Start Button (9) to Start
                if (gp.buttons && gp.buttons.length > 9 && gp.buttons[9].pressed) {
                    if (now - lastGpInputTime > 500) {
                        startPvPMatch();
                        lastGpInputTime = now;
                    }
                }
            }

            function render() {
                try {
                    requestAnimationFrame(render);

                    // PAUSED: solo renderizar la escena congelada, sin actualizar nada
                    if (gameMode === MODE.PAUSED) {
                        updateGpCursor();
                        // Comprobar botón Options del gamepad para cerrar configuración
                        if (navigator.getGamepads) {
                            const gpads = navigator.getGamepads();
                            for (let i = 0; i < gpads.length; i++) {
                                const gpad = gpads[i];
                                if (!gpad || !gpad.buttons || gpad.buttons.length <= 9) continue;
                                if (gpad.buttons[9].pressed) {
                                    if (!gpOptionsPrev) {
                                        document.getElementById('ingame-controls-btn').click();
                                    }
                                    gpOptionsPrev = true;
                                } else {
                                    gpOptionsPrev = false;
                                }
                                break;
                            }
                        }
                        const w = window.innerWidth;
                        const h = window.innerHeight;
                        if (prePauseMode === MODE.PVP) {
                            renderer.setScissorTest(true);
                            p1.camera.aspect = w / (h / 2);
                            p1.camera.updateProjectionMatrix();
                            renderer.setScissor(0, h / 2, w, h / 2);
                            renderer.setViewport(0, h / 2, w, h / 2);
                            renderer.render(scene, p1.camera);
                            p2.camera.aspect = w / (h / 2);
                            p2.camera.updateProjectionMatrix();
                            renderer.setScissor(0, 0, w, h / 2);
                            renderer.setViewport(0, 0, w, h / 2);
                            renderer.render(scene, p2.camera);
                        } else {
                            renderer.setScissorTest(false);
                            p1.camera.aspect = w / h;
                            p1.camera.updateProjectionMatrix();
                            renderer.setViewport(0, 0, w, h);
                            renderer.render(scene, p1.camera);
                        }
                        return;
                    }

                    if (gameMode === MODE.PVP_SELECT) {
                        updatePvPMenuInput();
                    }

                    if (gameMode === MODE.MENU || gameMode === MODE.END || gameMode === MODE.PVP_SELECT || gameMode === MODE.SOLO_SELECT) {
                        const w = window.innerWidth;
                        const h = window.innerHeight;
                        renderer.setScissorTest(false);
                        renderer.setViewport(0, 0, w, h);

                        updateGpCursor();

                        p1.zoomLevel = 0;
                        p1.camera.fov = 75;
                        p1.camera.aspect = w / h;
                        p1.camera.updateProjectionMatrix();
                        if (p2 && p2.camera) {
                            p2.zoomLevel = 0;
                            p2.camera.fov = 75;
                            p2.camera.aspect = w / h;
                            p2.camera.updateProjectionMatrix();
                        }

                        // ── Lobby camera — slow orbital pan ──────────────
                        const time = Date.now() * 0.0001;
                        lobbyCamAngle = time;

                        // Panoramic slow pan — elevated, wide cityscape view
                        p1.camera.position.set(
                            Math.sin(lobbyCamAngle * 0.10) * 35,
                            28 + Math.sin(lobbyCamAngle * 0.06) * 4,
                            55 + Math.cos(lobbyCamAngle * 0.08) * 10
                        );
                        p1.camera.lookAt(Math.sin(lobbyCamAngle * 0.12) * 15, 10, -55);

                        // ── Warzone lobby animation ─────────────────────────
                        if (lobbyGroup.visible) {
                            const t = Date.now() * 0.001;
                            const lu = lobbyGroup.userData;

                            // EMBERS — rise, wrap when above ceiling
                            const ep = lu.ePos, ev = lu.eVel, EC = lu.EMBER_COUNT;
                            const fp = lu._firePos;
                            for (let i = 0; i < EC; i++) {
                                ep[i*3]   += ev[i*3];
                                ep[i*3+1] += ev[i*3+1];
                                ep[i*3+2] += ev[i*3+2];
                                if (ep[i*3+1] > 90) {
                                    const src = fp[Math.floor(Math.random()*fp.length)];
                                    ep[i*3]   = src[0] + (Math.random()-0.5)*3;
                                    ep[i*3+1] = src[1];
                                    ep[i*3+2] = src[2] + (Math.random()-0.5)*3;
                                }
                            }
                            lu.eGeo.attributes.position.needsUpdate = true;

                            // SPARKS — rise faster, wrap lower
                            const sp = lu.spPos, sv = lu.spVel, SC = lu.SPARK_COUNT;
                            for (let i = 0; i < SC; i++) {
                                sp[i*3]   += sv[i*3];
                                sp[i*3+1] += sv[i*3+1];
                                sp[i*3+2] += sv[i*3+2];
                                sv[i*3]   *= 0.995; sv[i*3+2] *= 0.995;
                                if (sp[i*3+1] > 45) {
                                    const src = fp[Math.floor(Math.random()*fp.length)];
                                    sp[i*3]   = src[0] + (Math.random()-0.5)*1.5;
                                    sp[i*3+1] = src[1];
                                    sp[i*3+2] = src[2] + (Math.random()-0.5)*1.5;
                                    sv[i*3]   = (Math.random()-0.5)*0.10;
                                    sv[i*3+1] = 0.06 + Math.random()*0.12;
                                    sv[i*3+2] = (Math.random()-0.5)*0.08;
                                }
                            }
                            lu.spGeo.attributes.position.needsUpdate = true;

                            // ASH — slow wind drift, wrap horizontally
                            const ap = lu.aPos, av = lu.aVel, AC = lu.ASH_COUNT;
                            for (let i = 0; i < AC; i++) {
                                ap[i*3]   += av[i*3];
                                ap[i*3+1] += av[i*3+1];
                                ap[i*3+2] += av[i*3+2];
                                if (ap[i*3]   >  90) ap[i*3]   = -90;
                                if (ap[i*3+1] <  0.2) ap[i*3+1] = 16;
                                if (ap[i*3+2] >  55) ap[i*3+2] = -55;
                                if (ap[i*3+2] < -55) ap[i*3+2] =  55;
                            }
                            lu.aGeo.attributes.position.needsUpdate = true;

                            // FIRES — flicker light intensity only (no glow scale animation)
                            if (lu.fireSources) lu.fireSources.forEach(fs => {
                                const flicker  = 0.7 + 0.35 * Math.sin(t * fs.speed + fs.phase)
                                               + 0.10 * Math.sin(t * fs.speed * 2.3 + fs.phase * 1.7);
                                fs.light.intensity = (5.0 + 3.5 * flicker) * (0.85 + 0.2*Math.random());
                            });

                            // LIT WINDOWS — occasional flicker on/off (fire reflections)
                            if (lu._litWindows && Math.random() < 0.02) {
                                const w = lu._litWindows[Math.floor(Math.random()*lu._litWindows.length)];
                                if (w) w.material.opacity = 0.15 + Math.random()*0.7;
                            }

                            // SEARCHLIGHT — slow sweep back and forth
                            if (lu.searchSpot) {
                                const sweepX = Math.sin(t * 0.18) * 55;
                                const sweepZ = -30 + Math.cos(t * 0.12) * 20;
                                lu.searchSpot.target.position.set(sweepX, 0, sweepZ);
                                lu.searchSpot.target.updateMatrixWorld();
                                lu.searchSpot.intensity = 8 + 2*Math.sin(t*0.35);
                            }

                            // HORIZON GLOW — subtle breathe
                            if (lu.hGlow && lu.hGlow.material) lu.hGlow.material.opacity = 0.5 + 0.15*Math.sin(t*0.22);

                            // FOG PLANES — slow drift across ground
                            if (lu.fogMats) lu.fogMats.forEach(fm => {
                                fm.mesh.position.x = fm.baseX + Math.sin(t*0.07 + fm.phase)*8;
                                fm.mesh.position.z = fm.baseZ + Math.cos(t*0.05 + fm.phase)*5;
                                fm.mat.opacity = 0.04 + 0.025*Math.sin(t*0.15+fm.phase);
                            });

                            // AMBIENT WARM LIGHT — breathe with fire
                            if (lu._ambWarm) lu._ambWarm.intensity = 1.2 + 0.6*Math.sin(t*0.28);
                        }

                        renderer.render(scene, p1.camera);
                        return;
                    }

                    // ── KILLCAM MODE ─────────────────────────────────
                    if (gameMode === MODE.KILLCAM) {
                        const w = window.innerWidth;
                        const h = window.innerHeight;
                        killcamCamera.aspect = w / h;

                        // CHANGED: Patch 1 — Math.max(0,...)||0.016 garantiza dt positivo y no-NaN.
                        // clock.getDelta() puede devolver 0 o NaN en tabs/backgrounds; el fallback 0.016 = 60fps.
                        let delta = clock.getDelta();
                        const dt = Math.max(0, Math.min(delta, 0.1)) || 0.016;

                        // Slow-motion factor: movido a variable global KC_SLOWMO
                        const dtSlowmo = dt * KC_SLOWMO;

                        // Move in-flight projectiles at slow-mo speed so they match the killcam bullet.
                        // Una vez que la bala principal impacta (kcImpacted), las demás se congelan.
                        if (!kcImpacted) {
                            projectiles.forEach(p => {
                                p.life -= dtSlowmo;
                                if (p.life > 0) {
                                    if (!p.prevPos) p.prevPos = p.mesh.position.clone();
                                    else p.prevPos.copy(p.mesh.position);
                                    p.mesh.position.add(p.vel.clone().multiplyScalar(dtSlowmo));
                                }
                            });
                            for (let i = projectiles.length - 1; i >= 0; i--) {
                                if (projectiles[i].life <= 0) {
                                    scene.remove(projectiles[i].mesh);
                                    projectiles.splice(i, 1);
                                }
                            }
                            // Check collisions so other bullets actually hit their targets
                            checkCollisions();
                        }

                        // Do NOT call p1/p2/enemy .update() — players and bots stay frozen in place

                        updateKillcam(performance.now());
                        renderer.setScissorTest(false);
                        renderer.setViewport(0, 0, w, h);
                        renderer.render(scene, killcamCamera);
                        return;
                    }

                    // CHANGED: Patch 1 — Math.max(0,...)||0.016 garantiza dt positivo y no-NaN.
                    // clock.getDelta() puede devolver 0 o NaN en tabs/backgrounds; el fallback 0.016 = 60fps.
                    let delta = clock.getDelta();
                    const dt = Math.max(0, Math.min(delta, 0.1)) || 0.016;
                    recordReplayFrame();
                    updateInput();
                    // Animate dune sand particles when on DUNE-ZERO map
                    p1.update(dt);

                    // Bush rustle sound in SOLO only when entering the bush
                    if (gameMode === MODE.SOLO) {
                        const _inBushNow = isPlayerInBush();
                        if (_inBushNow && !_wasInBush) SFX.triggerBushRustle();
                        _wasInBush = _inBushNow;
                    }

                    if (gameMode === MODE.PVP) {
                        p2.update(dt);
                    }

                    else {
                        // Update Enemies
                        let alive = 0;

                        enemies.forEach(e => {
                            e.update(dt); if (e.hp > 0) alive++;
                        });
                        document.getElementById('solo-enemies').innerText = "ENEMIES: " + alive;
                        const aliveAfterCollisions = enemies.filter(e => e.hp > 0).length;
                        if (enemies.length > 0 && aliveAfterCollisions === 0 && gameMode === MODE.SOLO) endGame(true);
                    }

                    // Projectiles
                    projectiles.forEach(p => {
                        p.life -= dt;

                        if (p.life <= 0) {
                            scene.remove(p.mesh);
                        }
                        else {
                            // Store previous position for swept raycast collision
                            if (!p.prevPos) p.prevPos = p.mesh.position.clone();
                            else p.prevPos.copy(p.mesh.position);
                            p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
                        }
                    });

                    // Cleanup dead projectiles
                    for (let i = projectiles.length - 1; i >= 0; i--) {
                        if (projectiles[i].life <= 0) projectiles.splice(i, 1);
                    }

                    checkCollisions();
                    updateUI();
                    updateMinimap();

                    // Win Condition
                    if (p1.hp <= 0 && gameMode === MODE.SOLO) endGame(false);

                    if (gameMode === MODE.PVP) {
                        if (p1.hp <= 0) endGame(false, "PLAYER 2 WINS");
                        if (p2.hp <= 0) endGame(true, "PLAYER 1 WINS");
                    }

                    // Render
                    if (gameMode === MODE.PVP) {
                        // Split Screen
                        const w = window.innerWidth;
                        const h = window.innerHeight;
                        renderer.setScissorTest(true);

                        // Top (P1) — niebla y FOV independientes de P1
                        scene.fog.far = 150 + p1.zoomLevel * 125;
                        p1.camera.aspect = w / (h / 2);
                        p1.camera.updateProjectionMatrix();
                        renderer.setScissor(0, h / 2, w, h / 2);
                        renderer.setViewport(0, h / 2, w, h / 2);
                        renderer.render(scene, p1.camera);

                        // Bottom (P2) — niebla y FOV independientes de P2
                        scene.fog.far = 150 + p2.zoomLevel * 125;
                        p2.camera.aspect = w / (h / 2);
                        p2.camera.updateProjectionMatrix();
                        renderer.setScissor(0, 0, w, h / 2);
                        renderer.setViewport(0, 0, w, h / 2);
                        renderer.render(scene, p2.camera);

                        // Restaurar niebla al valor base
                        scene.fog.far = 150;
                    }

                    else {
                        // Full Screen (SOLO) — niebla controlada por P1
                        scene.fog.far = 150 + p1.zoomLevel * 125;
                        renderer.setScissorTest(false);
                        p1.camera.aspect = window.innerWidth / window.innerHeight;
                        p1.camera.updateProjectionMatrix();
                        renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
                        renderer.render(scene, p1.camera);
                    }
                }

                catch (err) {
                    console.error(err);

                    // Throttle alerts to avoid loops
                    if (!window.hasAlerted) {
                        alert("Game Loop Error: " + err.message);
                        window.hasAlerted = true;
                    }
                }
            }

            // -- UI & LOGIC --
            const ui = {
                lobby: document.getElementById('lobby'),
                pvpWeaponSelect: document.getElementById('pvp-weapon-select'),
                soloWeaponSelect: document.getElementById('solo-weapon-select'),
                victory: document.getElementById('victory-screen'),
                lastPlayFrame: document.getElementById('last-play-frame'),
                ingameMenuBtn: document.getElementById('ingame-menu-btn'),
                ingameControlsBtn: document.getElementById('ingame-controls-btn'),
                hudSolo: document.getElementById('hud-solo'),
                hudP1: document.getElementById('hud-p1'),
                hudP2: document.getElementById('hud-p2'),
                p1Hp: document.getElementById('p1-hp'),
                p1Ammo: document.getElementById('p1-ammo'),
                p1Stamina: document.getElementById('p1-stamina-bar'),
                p2Hp: document.getElementById('p2-hp'),
                p2Ammo: document.getElementById('p2-ammo'),
                p2Stamina: document.getElementById('p2-stamina-bar'),
                soloHp: document.getElementById('solo-hp'),
                soloAmmo: document.getElementById('solo-ammo'),
                soloStamina: document.getElementById('solo-stamina-bar'),
                winText: document.getElementById('win-text'),
                menuBg: document.getElementById('menu-background-layer'),
                controlsScreen: document.getElementById('controls-screen'),
                difficultySelect: document.getElementById('difficulty-select'),
                matchSetup: document.getElementById('match-setup')
            }

            // Controls Toggle (desde menú)
            let controlsFromGame = false;

            // -- SENSITIVITY SLIDERS --
            function initSensSliders() {
                const p1s   = document.getElementById('p1-sens');
                const p1sv  = document.getElementById('p1-sens-val');
                const p1a   = document.getElementById('p1-ads-sens');
                const p1av  = document.getElementById('p1-ads-sens-val');
                const p2s   = document.getElementById('p2-sens');
                const p2sv  = document.getElementById('p2-sens-val');
                const p2a   = document.getElementById('p2-ads-sens');
                const p2av  = document.getElementById('p2-ads-sens-val');

                p1s.addEventListener('input', () => {
                    p1sv.textContent = p1s.value;
                    p1SensBase = p1s.value / 1000;
                });
                p1a.addEventListener('input', () => {
                    p1av.textContent = p1a.value;
                    p1SensAds = p1a.value / 1000;
                });
                p2s.addEventListener('input', () => {
                    p2sv.textContent = p2s.value;
                    p2SensBase = p2s.value / 1000;
                });
                p2a.addEventListener('input', () => {
                    p2av.textContent = p2a.value;
                    p2SensAds = p2a.value / 1000;
                });
            }
            initSensSliders();
            document.getElementById('controls-btn').addEventListener('click', () => {
                controlsFromGame = false;
                ui.lobby.classList.add('hidden');
                ui.controlsScreen.classList.remove('hidden');
            });
            document.getElementById('ingame-controls-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                controlsFromGame = true;
                if (ui.controlsScreen.classList.contains('hidden')) {
                    // Abrir — pausar el juego
                    ui.controlsScreen.classList.remove('hidden');
                    if (gameMode === MODE.SOLO || gameMode === MODE.PVP) {
                        prePauseMode = gameMode;
                        gameMode = MODE.PAUSED;
                    }
                    if (document.pointerLockElement) document.exitPointerLock();
                } else {
                    // Cerrar — reanudar el juego
                    ui.controlsScreen.classList.add('hidden');
                    if (gameMode === MODE.PAUSED) {
                        gameMode = prePauseMode;
                        document.body.requestPointerLock?.()?.catch(() => {});
                    }
                }
            });
            document.getElementById('back-from-controls').addEventListener('click', () => {
                ui.controlsScreen.classList.add('hidden');
                if (controlsFromGame) {
                    // no hacer nada más — el juego sigue corriendo
                } else {
                    ui.lobby.classList.remove('hidden');
                }
            });

            document.getElementById('weapons-menu-btn').addEventListener('click', () => {
                ui.lobby.classList.add('hidden');
                document.getElementById('weapons-menu-screen').classList.remove('hidden');
            });

            document.getElementById('back-from-weapons').addEventListener('click', () => {
                document.getElementById('weapons-menu-screen').classList.add('hidden');
                ui.lobby.classList.remove('hidden');
            });

            ;

            // ... (lines omitted)

            let soloBotCount = 3;

            // ══════════════════════════════════════════════
            // MATCH SETUP — BRIEFING ROOM LOGIC
            // ══════════════════════════════════════════════

            const WEAPON_DATA = [
                { key: 'ar',      label: 'ASSAULT RIFLE', ammo: '30', color: '#ffff00', dot: '#ffcc00' },
                { key: 'smg',     label: 'SMG',           ammo: '40', color: '#00ffff', dot: '#00dddd' },
                { key: 'pistol',  label: 'PISTOL',        ammo: '20', color: '#ff4444', dot: '#ff2222' },
                { key: 'shotgun', label: 'SHOTGUN',       ammo: '8',  color: '#ff8800', dot: '#ff6600' },
                { key: 'sniper',  label: 'SNIPER',        ammo: '10', color: '#00ff88', dot: '#00dd66' },
            ];

            let msMode = 'solo'; // 'solo' | 'pvp'
            let msP1Weapon = 'ar';
            let msP2Weapon = 'ar';
            let msDifficulty = 3;

            // Tick sound for weapon hover
            function msTick() {
                try {
                    const ctx = ac(); const t = ctx.currentTime;
                    const buf = ctx.createBuffer(1, Math.ceil(ctx.sampleRate * 0.025), ctx.sampleRate);
                    const d = buf.getChannelData(0);
                    for (let i = 0; i < d.length; i++) d[i] = (Math.random()*2-1) * (1 - i/d.length);
                    const src = ctx.createBufferSource(); src.buffer = buf;
                    const bp = ctx.createBiquadFilter();
                    bp.type = 'bandpass'; bp.frequency.value = 3200; bp.Q.value = 3;
                    const g = ctx.createGain();
                    g.gain.setValueAtTime(0.18, t);
                    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.022);
                    src.connect(bp); bp.connect(g); g.connect(_comp);
                    src.start(t); src.stop(t + 0.03);
                } catch(e) {}
            }

            function msBuildWeaponGrid(containerId, player) {
                const container = document.getElementById(containerId);
                if (!container) return;
                container.innerHTML = '';
                const isP1 = player === 1;
                WEAPON_DATA.forEach(w => {
                    const btn = document.createElement('button');
                    btn.className = 'ms-weapon-btn';
                    btn.dataset.weapon = w.key;
                    btn.innerHTML = `
                        <div class="wb-dot" style="background:${w.dot}"></div>
                        <span class="wb-label">${w.label}</span>
                        <span class="wb-ammo">${w.ammo} RDS</span>
                    `;
                    btn.addEventListener('mouseenter', () => { unlockAudio(); msTick(); });
                    btn.addEventListener('click', () => msSelectWeapon(player, w.key));
                    container.appendChild(btn);
                });
            }

            function msSelectWeapon(player, weaponKey) {
                unlockAudio(); lobbySelect();
                const wd = WEAPON_DATA.find(w => w.key === weaponKey);
                if (!wd) return;
                if (player === 1) {
                    msP1Weapon = weaponKey;
                    document.getElementById('ms-p1-weapon-name').textContent = wd.label;
                    document.getElementById('ms-footer-p1').textContent = wd.key.toUpperCase();
                    document.querySelectorAll('#ms-p1-weapon-grid .ms-weapon-btn').forEach(b => {
                        b.classList.toggle('selected', b.dataset.weapon === weaponKey);
                    });
                } else {
                    msP2Weapon = weaponKey;
                    document.getElementById('ms-p2-weapon-name').textContent = wd.label;
                    document.getElementById('ms-footer-p2').textContent = wd.key.toUpperCase();
                    document.querySelectorAll('#ms-p2-weapon-grid .ms-weapon-btn').forEach(b => {
                        b.classList.toggle('selected', b.dataset.weapon === weaponKey);
                    });
                }
                msUpdateDeploy();
            }

            function msSetDifficulty(btnEl, count) {
                unlockAudio(); msTick();
                msDifficulty = count;
                soloBotCount = count;
                document.querySelectorAll('.ms-diff-btn').forEach(b => b.classList.remove('selected'));
                btnEl.classList.add('selected');
                document.getElementById('ms-stat-enemies').textContent = count;
            }
            window.msSetDifficulty = msSetDifficulty;

            function msUpdateDeploy() {
                const btn = document.getElementById('ms-deploy-btn');
                if (!btn) return;
                const ready = msP1Weapon && (msMode === 'pvp' ? msP2Weapon : true);
                btn.disabled = !ready;
                btn.classList.toggle('ready', ready);
            }

            function showMatchSetup(mode) {
                msMode = mode;
                // Keep the 3D lobby background alive — just hide the HTML overlay
                if (!lobbyGroup.visible) enterLobbyScene();
                // Hide lobby + old screens
                ui.lobby.classList.add('hidden');
                ui.difficultySelect && ui.difficultySelect.classList.add('hidden');
                ui.soloWeaponSelect && ui.soloWeaponSelect.classList.add('hidden');
                ui.pvpWeaponSelect && ui.pvpWeaponSelect.classList.add('hidden');

                const el = document.getElementById('match-setup');
                el.classList.remove('hidden');
                el.classList.remove('entering');
                void el.offsetWidth; // reflow for animation
                el.classList.add('entering');

                // Mode labels
                const isSolo = mode === 'solo';
                document.getElementById('ms-mode-label').textContent = isSolo ? '// SOLO' : '// 1v1';
                document.getElementById('ms-mode-badge').textContent = isSolo ? 'SOLO VS AI' : '1v1 SPLIT SCREEN';
                document.getElementById('ms-stat-mode').textContent = isSolo ? 'SOLO' : '1v1 PVP';
                document.getElementById('ms-stat-enemies').textContent = isSolo ? msDifficulty : '1';

                // P2 slot visibility
                const p2Slot = document.getElementById('ms-p2-slot');
                const p2IdLabel = document.getElementById('ms-p2-id-label');
                const p2Status = document.getElementById('ms-p2-status');
                const p2Subtitle = document.getElementById('ms-p2-subtitle');
                const footerP2 = document.getElementById('ms-footer-p2-wrap');
                if (isSolo) {
                    p2Slot.classList.add('ai');
                    p2IdLabel.textContent = 'ENEMY (AI)';
                    p2Status.textContent = 'AI CONTROLLED';
                    p2Status.className = 'ms-player-status ms-status-ai';
                    p2Subtitle.textContent = 'AUTO-ASSIGNED';
                    document.getElementById('ms-p2-weapon-name').textContent = 'MIXED';
                    document.getElementById('ms-difficulty-area').style.display = '';
                    if (footerP2) footerP2.style.opacity = '0.3';
                } else {
                    p2Slot.classList.remove('ai');
                    p2IdLabel.textContent = 'PLAYER 2';
                    p2Status.textContent = 'ACTIVE';
                    p2Status.className = 'ms-player-status ms-status-active';
                    p2Subtitle.textContent = 'SELECTED LOADOUT';
                    document.getElementById('ms-difficulty-area').style.display = 'none';
                    if (footerP2) footerP2.style.opacity = '1';
                }

                // Build weapon grids
                msBuildWeaponGrid('ms-p1-weapon-grid', 1);
                msBuildWeaponGrid('ms-p2-weapon-grid', 2);

                // Set defaults
                msP1Weapon = 'ar'; msP2Weapon = 'ar';
                msSelectWeapon(1, 'ar');
                if (!isSolo) msSelectWeapon(2, 'ar');

                msUpdateDeploy();
            }

            function hideMatchSetup() {
                document.getElementById('match-setup').classList.add('hidden');
                ui.lobby.classList.remove('hidden');
                gameMode = MODE.MENU;
            }

            // DEPLOY action
            document.getElementById('ms-deploy-btn').addEventListener('click', () => {
                if (msMode === 'solo') {
                    soloBotCount = msDifficulty;
                    selectedWeapon = msP1Weapon;
                    p1.setWeapon(msP1Weapon);
                    document.getElementById('match-setup').classList.add('hidden');
                    stopLobbyHum();
                    startMatchTransition(() => startSoloConfirm());
                } else {
                    p1SelectedWeapon = msP1Weapon;
                    p2SelectedWeapon = msP2Weapon;
                    p1.setWeapon(msP1Weapon);
                    p2.setWeapon(msP2Weapon);
                    document.getElementById('match-setup').classList.add('hidden');
                    stopLobbyHum();
                    startMatchTransition(() => startPvP());
                }
            });

            // Back button
            document.getElementById('ms-back-btn').addEventListener('click', () => {
                unlockAudio(); lobbyHover();
                hideMatchSetup();
            });

            function showDifficultySelect() {
                showMatchSetup('solo');
            }

            function selectDifficulty(count) {
                // Legacy — kept for compatibility
                soloBotCount = count;
            }

            function backToLobby() {
                hideMatchSetup();
                ui.difficultySelect && ui.difficultySelect.classList.add('hidden');
                ui.soloWeaponSelect && ui.soloWeaponSelect.classList.add('hidden');
                ui.pvpWeaponSelect && ui.pvpWeaponSelect.classList.add('hidden');
            }

            function backToDifficulty() {
                // No longer needed but kept for safety
            }

            // Expose to window
            window.selectDifficulty = selectDifficulty;
            window.backToLobby = backToLobby;
            window.backToDifficulty = backToDifficulty;
            window.showMatchSetup = showMatchSetup;
            window.unlockAudio = unlockAudio;
            window.lobbyHover = lobbyHover;

            function startSoloConfirm() {
                // Renamed from startSolo to distinguish from the setup phase
                // This is the actual GAME START
                gameMode = MODE.SOLO;
                reset();
                lastKillInfo = null;
                if (ui.lastPlayFrame) {
                    ui.lastPlayFrame.classList.add('hidden');
                    ui.lastPlayFrame.style.backgroundImage = '';
                }
                // Clear Menu Bots
                if (window.clearMenuBots) window.clearMenuBots();
                if (window.menuLight) window.menuLight.visible = false;
                scene.fog.near = 20; // Restore fog

                // ── Load selected map geometry & audio ──
                loadMap(activeMapKey);
                // Override P1 spawn with map-specific position
                p1.respawn(window._mapSpawnP1 || new THREE.Vector3(0, 5, 0));

                // Spawn Enemies
                enemies.forEach(e => {
                    if (e.mesh.parent) scene.remove(e.mesh);
                });
                enemies.length = 0;

                // Spawn de bots en spots predefinidos (evita aparecer dentro de objetos)
                const BOT_SPOTS = activeMapKey === 'raid' ? [
                    // Zonas abiertas seguras del mapa Raid
                    { x:-60,  z: 55 }, { x: 60,  z: 55 },  // frente mansión
                    { x:-60,  z:-55 }, { x: 60,  z:-55 },  // atrás mansión
                    { x:-130, z: 0  }, { x:-130, z: 40 },  // zona basketball
                    { x:-130, z:-40 }, { x:-150, z:-80 },  // zona tenis
                    { x: 150, z:-60 }, { x: 150, z: 60 },  // zona helipad
                    { x:  0,  z:-60 }, { x:  0,  z: 60 },  // pasillo central
                    { x:-60,  z: 0  }, { x: 60,  z: 0  },  // flancos mansión
                    { x:-100, z: 80 }, { x: 100, z: 80 },  // zona sur
                    { x:-100, z:-80 }, { x: 100, z:-80 },  // zona norte
                    { x:  0,  z:-130}, { x:  0,  z: 130},  // calles horizontales
                ] : null;

                for (let i = 0; i < soloBotCount; i++) {
                    let ex, ez;
                    if (BOT_SPOTS) {
                        // Usar spot predefinido (rotando por la lista)
                        const spot = BOT_SPOTS[i % BOT_SPOTS.length];
                        // Pequeño jitter para que no se apilen exactamente
                        ex = spot.x + (Math.random() - 0.5) * 8;
                        ez = spot.z + (Math.random() - 0.5) * 8;
                    } else {
                        // Fallback: posición aleatoria (valley u otros mapas)
                        do {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = 30 + Math.random() * 120;
                            ex = Math.cos(angle) * dist;
                            ez = Math.sin(angle) * dist;
                        } while (Math.abs(ex) > 198 || Math.abs(ez) > 198);
                    }
                    enemies.push(new AIEnemy({ x: ex, z: ez }));
                }

                ui.lobby.classList.add('hidden');
                ui.soloWeaponSelect.classList.add('hidden');
                if (ui.menuBg) ui.menuBg.classList.add('hidden'); // KEEP HIDDEN
                ui.hudSolo.style.display = 'block';
                ui.ingameMenuBtn.classList.remove('hidden'); // SHOW BUTTON
                ui.ingameControlsBtn.classList.remove('hidden');

                if (!p1.mesh.parent) scene.add(p1.mesh); // ADD P1
                if (p2.mesh.parent) scene.remove(p2.mesh); // REMOVE P2

                document.body.requestPointerLock?.()?.catch(() => { });
            }
            function startPvP() {
                try {
                    gameMode = MODE.PVP;
                    reset();
                    lastKillInfo = null;
                    if (ui.lastPlayFrame) {
                        ui.lastPlayFrame.classList.add('hidden');
                        ui.lastPlayFrame.style.backgroundImage = '';
                    }
                    // Place Players
                    // ── Load selected map geometry & audio ──
                    loadMap(activeMapKey);
                    // Use map spawn points or fall back to symmetric random positions
                    let p1pos = window._mapSpawnP1 ? window._mapSpawnP1.clone() : null;
                    let p2pos = window._mapSpawnP2 ? window._mapSpawnP2.clone() : null;
                    if (!p1pos || !p2pos) {
                        let p1posT, p2posT;
                        do {
                            const angle = Math.random() * Math.PI * 2;
                            const half = 100 + Math.random() * 50;
                            p1posT = new THREE.Vector3(
                                Math.max(-190, Math.min(190, Math.cos(angle) * half)),
                                2,
                                Math.max(-190, Math.min(190, Math.sin(angle) * half))
                            );
                            p2posT = new THREE.Vector3(
                                Math.max(-190, Math.min(190, -Math.cos(angle) * half)),
                                2,
                                Math.max(-190, Math.min(190, -Math.sin(angle) * half))
                            );
                        } while (p1posT.distanceTo(p2posT) < 200 || p1posT.distanceTo(p2posT) > 300);
                        p1pos = p1posT; p2pos = p2posT;
                    }
                    p1.respawn(p1pos);
                    p2.respawn(p2pos);
                    p2.mesh.rotation.y = Math.PI;

                    // Remove Enemies
                    enemies.forEach(e => {
                        if (e.mesh.parent) scene.remove(e.mesh);
                    });
                    enemies.length = 0;

                    ui.lobby.classList.add('hidden');
                    if (ui.menuBg) ui.menuBg.classList.add('hidden');
                    clearLobbyBots(); // Clear lobby bots when game starts
                    ui.hudP1.style.display = 'block';
                    ui.hudP2.style.display = 'block';
                    ui.ingameMenuBtn.classList.remove('hidden'); // SHOW BUTTON
                ui.ingameControlsBtn.classList.remove('hidden');

                    if (!p1.mesh.parent) scene.add(p1.mesh);
                    if (!p2.mesh.parent) scene.add(p2.mesh);

                    document.body.requestPointerLock?.()?.catch?.(err => {
                        console.warn("Pointer lock failed:", err.message);
                    });
                }

                catch (err) {
                    alert("Error starting PvP: " + err.message);
                    console.error(err);
                }
            }

            function reset() {
                gameEnding = false;
                p1.respawn(new THREE.Vector3(0, 0, 0));
                // Clear projs
                projectiles.forEach(p => scene.remove(p.mesh));
                projectiles.length = 0;

                // CHANGED: Patch 7 — limpiar buffers de replay con .clear() (no reasignar):
                // evita romper referencias vivas al objeto CircularBuffer en killcam/endGame.
                projectileReplayBuffer.clear();
                replayBuffer.length = 0;
                // Map de CircularBuffer: limpiar cada buffer sin borrar el Map (keys siguen válidas)
                for (const buf of enemyReplayBuffers.values()) { if (buf && buf.clear) buf.clear(); }

                // CHANGED: Patch 7 — detener audio ambiental activo al hacer reset
                if (typeof _stopMapAmbient === 'function') _stopMapAmbient();

                // ── FIX: Full killcam state reset — covers all paths (restart, abort, error, double-death) ──
                if (kcBulletMesh) { scene.remove(kcBulletMesh); kcBulletMesh = null; }
                kcActive          = false;
                kcSlowmoActive    = false;
                kcImpacted        = false;
                kcCallback        = null;
                kcStartTime       = 0;
                kcBulletPos       = null;
                kcBulletDir       = null;
                kcBulletSpeed     = 0;
                kcKillerOrigin    = null;
                kcKillerCamPos    = null;
                kcVictimPos       = null;
                kcProjSpawnTime   = 0;
                kcBulletAppearElapsed = null;
                kcReplayFrames    = null;
                kcMasterReplay    = null;
                kcKillerEntity    = null;
                kcKillerOwner     = 0;
                kcReplayProjectiles = [];
                kcAllEnemyReplays = null;
                if (killcamCamera) killcamCamera._phase2started = false;
                if (kcOverlay)    kcOverlay.style.display = 'none';
                if (kcBarTop)     kcBarTop.style.height   = '0';
                if (kcBarBot)     kcBarBot.style.height   = '0';
                if (kcLabel)      kcLabel.style.opacity   = '0';
                if (kcSlowmo)     kcSlowmo.style.opacity  = '0';
                if (kcTimerBar)   kcTimerBar.style.opacity = '0';
                if (kcColorGrade) kcColorGrade.style.opacity = '0';
                if (kcImpact)     kcImpact.style.opacity  = '0';

                // Limpiar último replay
                lastKillInfo = null;
                ui.victory.classList.add('hidden');
                if (ui.lastPlayFrame) {
                    ui.lastPlayFrame.classList.add('hidden');
                    ui.lastPlayFrame.style.backgroundImage = '';
                }
                ui.hudSolo.style.display = 'none';
                ui.hudP1.style.display = 'none';
                ui.hudP2.style.display = 'none';
                ui.ingameMenuBtn.classList.add('hidden'); // HIDE BUTTON
                ui.ingameControlsBtn.classList.add('hidden');
            }

            function returnToMenu() {
                try {
                    gameMode = MODE.MENU;
                    // Stop map-specific ambient audio
                    if (typeof _stopMapAmbient === 'function') _stopMapAmbient();
                    // CHANGED: Patch 2D — vaciar buffers de replay al volver al menú
                    projectileReplayBuffer.clear();
                    replayBuffer.length = 0;
                    enemyReplayBuffers.clear();
                    enemies.forEach(e => {
                        if (e.mesh && e.mesh.parent) scene.remove(e.mesh);
                    });
                    enemies.length = 0;
                    spawnLobbyBots();
                    if (document.pointerLockElement) document.exitPointerLock();
                    lastKillInfo = null;
                    p1.zoomLevel = 0;
                    p1.camera.fov = 75;
                    p1.camera.updateProjectionMatrix();
                    if (p2 && p2.camera) {
                        p2.zoomLevel = 0;
                        p2.camera.fov = 75;
                        p2.camera.updateProjectionMatrix();
                    }
                    ui.victory.classList.add('hidden');
                    if (ui.lastPlayFrame) {
                        ui.lastPlayFrame.classList.add('hidden');
                        ui.lastPlayFrame.style.backgroundImage = '';
                    }
                    ui.soloWeaponSelect.classList.add('hidden');
                    ui.pvpWeaponSelect.classList.add('hidden');
                    document.getElementById('match-setup').classList.add('hidden');
                    ui.lobby.classList.remove('hidden');
                    if (ui.menuBg) ui.menuBg.classList.remove('hidden');
                    enterLobbyScene();
                    startLobbyHum();
                    reset();
                }

                catch (err) {
                    console.error("Error in returnToMenu:", err);
                    // Force lobby even if reset fails
                    gameMode = MODE.MENU;
                    ui.lobby.classList.remove('hidden');
                    ui.ingameMenuBtn.classList.add('hidden');
                    ui.ingameControlsBtn.classList.add('hidden');
                }
            }

            function endGame(won, msg) {
                // Prevent double-trigger
                if (gameMode === MODE.END || gameMode === MODE.KILLCAM) return;

                // Stop all AI updates immediately (prevents NaN mid-frame)
                gameEnding = true;

                // Exit pointer lock immediately
                if (document.pointerLockElement) document.exitPointerLock();

                // Hide HUDs now
                ui.hudSolo.style.display = 'none';
                ui.hudP1.style.display = 'none';
                ui.hudP2.style.display = 'none';
                ui.ingameMenuBtn.classList.add('hidden');
                    ui.ingameControlsBtn.classList.add('hidden');

                // Play killcam first, THEN show victory screen
                startKillcam(() => actualEndGame(won, msg));
            }

            function actualEndGame(won, msg) {
                // Colocamos la cámara cerca de la ÚLTIMA muerte (asesino/víctima) y capturamos ese frame
                try {
                    if (ui.lastPlayFrame && renderer && renderer.domElement) {
                        const origPos = p1.camera.position.clone();
                        const origQuat = p1.camera.quaternion.clone();

                        if (lastKillInfo && lastKillInfo.killerCamPos) {
                            p1.camera.position.copy(lastKillInfo.killerCamPos);
                            if (lastKillInfo.killerCamQuat) {
                                p1.camera.quaternion.copy(lastKillInfo.killerCamQuat);
                            } else if (lastKillInfo.victimPos) {
                                p1.camera.lookAt(lastKillInfo.victimPos);
                            }
                            // Pull back a bit more from the killer's POV to ensure visibility (Requested by user)
                            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(p1.camera.quaternion);
                            p1.camera.position.addScaledVector(forward, -5);
                        }

                        // ── FORCE ENTITY STATE FOR SCREENSHOT ──
                        // This ensures the killer and victim are visible and correctly placed, 
                        // even if the replay interpolation was slightly off or they were hidden.
                        if (lastKillInfo) {
                            // Position Victim
                            p1.mesh.position.copy(lastKillInfo.victimPos);
                            p1.mesh.visible = true;
                            if (!p1.mesh.parent) scene.add(p1.mesh);

                            // Position Killer
                            let killerEntity = null;
                            if (lastKillInfo.killerOwner === 1) {
                                killerEntity = p1;
                            } else if (lastKillInfo.killerOwner === 2) {
                                killerEntity = p2;
                            } else {
                                // Find killer AI by ref or proximity
                                killerEntity = lastKillInfo.killerEnemyRef;
                                if (!killerEntity) {
                                    let bestDist = Infinity;
                                    for (let en of enemies) {
                                        let d = en.mesh.position.distanceTo(lastKillInfo.killerPos);
                                        if (d < bestDist) { bestDist = d; killerEntity = en; }
                                    }
                                }
                            }

                            if (killerEntity && killerEntity.mesh) {
                                killerEntity.mesh.position.copy(lastKillInfo.killerPos);
                                killerEntity.mesh.visible = true;
                                if (!killerEntity.mesh.parent) scene.add(killerEntity.mesh);
                            }

                            // Ensure all other players/enemies are at least visible for the backdrop
                            if (p2 && p2.mesh) p2.mesh.visible = true;
                            // Solo el enemigo víctima debe ser visible — los anteriormente
                            // eliminados no deben reaparecer en el screenshot final.
                            if (lastKillInfo.victimEnemyRef) {
                                const ve = lastKillInfo.victimEnemyRef;
                                if (!ve.mesh.parent) scene.add(ve.mesh);
                                ve.mesh.visible = true;
                                ve.mesh.traverse(child => { if (child.isMesh) child.visible = true; });
                            }
                        }

                        // Renderizamos una vez con esta cámara a pantalla completa y capturamos
                        const w = window.innerWidth;
                        const h = window.innerHeight;
                        p1.camera.aspect = w / h;
                        p1.camera.updateProjectionMatrix();
                        renderer.setScissorTest(false);
                        renderer.setViewport(0, 0, w, h);
                        renderer.render(scene, p1.camera);

                        const dataURL = renderer.domElement.toDataURL('image/png');
                        ui.lastPlayFrame.style.backgroundImage = `url(${dataURL})`;
                        ui.lastPlayFrame.classList.remove('hidden');

                        // Restauramos la cámara para que el loop siga normal
                        p1.camera.position.copy(origPos);
                        p1.camera.quaternion.copy(origQuat);

                        // Resetear zoom/FOV
                        p1.zoomLevel = 0;
                        p1.camera.fov = 75;
                        p1.camera.updateProjectionMatrix();
                        if (p2 && p2.camera) {
                            p2.zoomLevel = 0;
                            p2.camera.fov = 75;
                            p2.camera.updateProjectionMatrix();
                        }
                    }
                }

                catch (e) {
                    console.warn("No se pudo capturar la última jugada:", e);
                }

                gameMode = MODE.END;
                ui.victory.classList.remove('hidden');
                if (ui.menuBg) ui.menuBg.classList.remove('hidden');

                if (msg) ui.winText.innerText = msg;
                else ui.winText.innerText = won ? "WIN" : "FAILED";

                // ── Scene Cleanup (Requested by user: remove everyone and bullets after screenshot) ──
                projectiles.forEach(p => { if (p.mesh.parent) scene.remove(p.mesh); });
                projectiles.length = 0;

                enemies.forEach(e => { if (e.mesh.parent) scene.remove(e.mesh); });
                enemies.length = 0;

                if (p1.mesh.parent) scene.remove(p1.mesh);
                if (p2 && p2.mesh.parent) scene.remove(p2.mesh);

                // CHANGED: Patch 2D — .clear() en lugar de .length=0 para evitar romper referencias vivas
                projectileReplayBuffer.clear();
            }

            // -- MINIMAP --
            const minimapCanvas = document.getElementById('minimap');
            const minimapCtx = minimapCanvas.getContext('2d');
            const MINIMAP_RADIUS = 80; // px, mitad del canvas
            const MINIMAP_FOG = 100;   // radio del mundo que representa (100m)

            function updateMinimap() {
                if (gameMode !== MODE.SOLO) return;
                const ctx = minimapCtx;
                const size = minimapCanvas.width;
                ctx.clearRect(0, 0, size, size);

                // Clip circular
                ctx.save();
                ctx.beginPath();
                ctx.arc(MINIMAP_RADIUS, MINIMAP_RADIUS, MINIMAP_RADIUS, 0, Math.PI * 2);
                ctx.clip();

                // Fondo
                ctx.fillStyle = 'rgba(30,90,30,0.75)';
                ctx.fillRect(0, 0, size, size);

                // Convertir posición del mundo a px en el mapa
                // El jugador siempre está en el centro; el mapa rota con la cámara
                const playerYaw = p1.cameraAngle.y; // yaw de la cámara

                function worldToMap(wx, wz) {
                    const dx = wx - p1.mesh.position.x;
                    const dz = wz - p1.mesh.position.z;
                    // Rotar según yaw del jugador para que "arriba" sea hacia donde mira
                    const cosY = Math.cos(playerYaw);
                    const sinY = Math.sin(playerYaw);
                    const rx = dx * cosY - dz * sinY;
                    const rz = dx * sinY + dz * cosY;
                    const scale = MINIMAP_RADIUS / MINIMAP_FOG;
                    return {
                        x: MINIMAP_RADIUS + rx * scale,
                        y: MINIMAP_RADIUS + rz * scale
                    };
                }

                // Círculo de rango (borde suave)
                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(MINIMAP_RADIUS, MINIMAP_RADIUS, MINIMAP_RADIUS - 1, 0, Math.PI * 2);
                ctx.stroke();

                // Enemigos vivos
                for (const e of enemies) {
                    if (e.hp <= 0) continue;
                    const dist = p1.mesh.position.distanceTo(e.mesh.position);
                    if (dist > MINIMAP_FOG) continue; // fuera del rango visible
                    const mp = worldToMap(e.mesh.position.x, e.mesh.position.z);
                    ctx.beginPath();
                    ctx.arc(mp.x, mp.y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff3333';
                    ctx.fill();
                }

                // Jugador (punto blanco con triángulo de dirección)
                ctx.beginPath();
                ctx.arc(MINIMAP_RADIUS, MINIMAP_RADIUS, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.fill();

                // Triángulo indicando hacia dónde mira (siempre apunta arriba = frente)
                ctx.beginPath();
                ctx.moveTo(MINIMAP_RADIUS, MINIMAP_RADIUS - 10);
                ctx.lineTo(MINIMAP_RADIUS - 4, MINIMAP_RADIUS - 4);
                ctx.lineTo(MINIMAP_RADIUS + 4, MINIMAP_RADIUS - 4);
                ctx.closePath();
                ctx.fillStyle = '#00ccff';
                ctx.fill();

                ctx.restore();
            }

            function updateUI() {
                if (gameMode === MODE.SOLO) {
                    ui.soloHp.innerText = Math.floor(p1.hp);
                    ui.soloAmmo.innerText = p1.ammo;
                    ui.soloStamina.style.width = Math.floor(p1.stamina) + '%';
                }

                else if (gameMode === MODE.PVP) {
                    ui.p1Hp.innerText = Math.floor(p1.hp);
                    ui.p1Ammo.innerText = p1.ammo;
                    ui.p1Stamina.style.width = Math.floor(p1.stamina) + '%';
                    ui.p2Hp.innerText = Math.floor(p2.hp);
                    ui.p2Ammo.innerText = p2.ammo;
                    ui.p2Stamina.style.width = Math.floor(p2.stamina) + '%';
                }
            }

            const btns = document.querySelectorAll('button');

            btns.forEach(b => {
                b.addEventListener('mousedown', (e) => e.stopPropagation());
            });


            // Expose to window for HTML onclick events
            window.selectPvPWeapon = selectPvPWeapon;
            window.selectSoloWeapon = selectSoloWeapon;

            // SOLO FLOW
            document.getElementById('solo-btn').onclick = (e) => {
                e.stopPropagation();
                showDifficultySelect();
            }

                ;

            document.getElementById('start-solo-match-btn').onclick = (e) => {
                e.stopPropagation();
                // Apply Weapon to P1 — transition fires via lobby wiring below
                p1.setWeapon(selectedWeapon);
                stopLobbyHum();
                startMatchTransition(() => startSoloConfirm());
            }

                ;

            function showSoloWeaponSelect() {
                gameMode = MODE.SOLO_SELECT;
                ui.lobby.classList.add('hidden');
                ui.soloWeaponSelect.classList.remove('hidden');
                // Default selection
                selectSoloWeapon('ar');
            }

            function selectSoloWeapon(key) {
                selectedWeapon = key;
                const opts = document.querySelectorAll('.weapon-btn-solo');

                opts.forEach(btn => {
                    if (btn.getAttribute('data-weapon') === key) {
                        btn.classList.add('selected');
                    }

                    else {
                        btn.classList.remove('selected');
                    }
                });
            }


            document.getElementById('pvp-btn').onclick = (e) => {
                e.stopPropagation();
                showMatchSetup('pvp');
            }

                ;

            document.getElementById('restart-btn').onclick = (e) => {
                e.stopPropagation();
                returnToMenu();
            }

                ;

            document.getElementById('ingame-menu-btn').onclick = (e) => {
                e.stopPropagation();
                returnToMenu();
            }

                ;

            // PvP Weapon Selection Functions
            function showPvPWeaponSelect() {
                gameMode = MODE.PVP_SELECT;

                ui.lobby.classList.add('hidden');
                ui.pvpWeaponSelect.classList.remove('hidden');
                p1SelectedWeapon = 'ar';
                p2SelectedWeapon = 'ar';
                updatePvPWeaponUI();
            }

            function selectPvPWeapon(player, weaponKey) {
                if (player === 1) {
                    p1SelectedWeapon = weaponKey;
                }

                else if (player === 2) {
                    p2SelectedWeapon = weaponKey;
                }

                updatePvPWeaponUI();
            }

            function updatePvPWeaponUI() {
                const p1Opts = document.querySelectorAll('.weapon-btn-solo.p1');

                p1Opts.forEach(opt => {
                    if (opt.getAttribute('data-weapon') === p1SelectedWeapon) {
                        opt.classList.add('selected');
                    }

                    else {
                        opt.classList.remove('selected');
                    }
                });

                const p2Opts = document.querySelectorAll('.weapon-btn-solo.p2');

                p2Opts.forEach(opt => {
                    if (opt.getAttribute('data-weapon') === p2SelectedWeapon) {
                        opt.classList.add('selected');
                    }

                    else {
                        opt.classList.remove('selected');
                    }
                });
            }

            function startPvPMatch() {
                ui.pvpWeaponSelect.classList.add('hidden');
                p1.setWeapon(p1SelectedWeapon);
                p2.setWeapon(p2SelectedWeapon);
                startPvP();
            }

            document.getElementById('start-pvp-match-btn').onclick = (e) => {
                e.stopPropagation();
                stopLobbyHum();
                startMatchTransition(() => startPvPMatch());
            }

                ;

            // Window Resize Handling
            window.addEventListener('resize', () => {
                const w = window.innerWidth;
                const h = window.innerHeight;
                renderer.setSize(w, h);

                if (gameMode === MODE.PVP) {
                    p1.camera.aspect = w / (h / 2);
                    p1.camera.updateProjectionMatrix();
                    p2.camera.aspect = w / (h / 2);
                    p2.camera.updateProjectionMatrix();
                }

                else {
                    p1.camera.aspect = w / h;
                    p1.camera.updateProjectionMatrix();
                }
            });

            spawnLobbyBots();
            if (p1.mesh.parent) scene.remove(p1.mesh);
            if (p2.mesh.parent) scene.remove(p2.mesh);

            // -- CURSOR VIRTUAL GAMEPAD --
            const gpCursor = document.getElementById('gp-cursor');
            let gpCursorX = window.innerWidth / 2;
            let gpCursorY = window.innerHeight / 2;
            let gpTouchPrev = false;
            let gpActive = false; // si el gamepad está moviendo el cursor

            function isMenuMode() {
                return gameMode === MODE.MENU || gameMode === MODE.END ||
                       gameMode === MODE.PVP_SELECT || gameMode === MODE.SOLO_SELECT ||
                       gameMode === MODE.PAUSED;
            }

            let gpTouchPrevX = null;
            let gpTouchPrevY = null;
            let gpSelectedSlider = null;

            function updateGpCursor() {
                if (!navigator.getGamepads) { gpCursor.style.display = 'none'; return; }
                const gamepads = navigator.getGamepads();
                let gpad = null;
                for (let i = 0; i < gamepads.length; i++) {
                    if (gamepads[i] && gamepads[i].buttons && gamepads[i].buttons.length > 0) {
                        gpad = gamepads[i]; break;
                    }
                }

                if (!gpad || !isMenuMode()) {
                    gpCursor.style.display = 'none';
                    document.body.style.cursor = '';
                    return;
                }

                // Stick derecho (axes 2+3) para mover el cursor
                const deadzone = 0.15;
                let dx = 0, dy = 0;
                if (gpad.axes.length >= 2) {
                    if (Math.abs(gpad.axes[0]) > deadzone) dx = gpad.axes[0] * 12;
                    if (Math.abs(gpad.axes[1]) > deadzone) dy = gpad.axes[1] * 12;
                }

                if (dx !== 0 || dy !== 0) {
                    // Si hay un slider seleccionado con X, el eje horizontal lo ajusta
                    if (gpSelectedSlider) {
                        if (dx !== 0) {
                            const step = Number(gpSelectedSlider.step) || 1;
                            gpSelectedSlider.value = Math.max(Number(gpSelectedSlider.min), Math.min(Number(gpSelectedSlider.max), Number(gpSelectedSlider.value) + (dx > 0 ? step : -step)));
                            gpSelectedSlider.dispatchEvent(new Event('input', { bubbles: true }));
                        }
                        // Vertical sale del slider
                        if (Math.abs(dy) > Math.abs(dx) * 1.5) {
                            gpSelectedSlider.classList.remove('gp-hover');
                            gpSelectedSlider = null;
                        }
                    } else {
                        gpCursorX = Math.max(0, Math.min(window.innerWidth  - 2, gpCursorX + dx));
                        gpCursorY = Math.max(0, Math.min(window.innerHeight - 2, gpCursorY + dy));
                    }
                    gpActive = true;
                }

                // Lista compartida de clases interactivas (usada en hover Y en click)
                const interactiveClasses = ['tac-item','map-select-btn','ms-weapon-btn',
                    'ms-diff-btn','weapon-btn-solo','ms-deploy-btn','ms-back-btn','btn-transparent'];

                if (gpActive) {
                    gpCursor.style.display = 'none';
                    const rawEl = document.elementFromPoint(gpCursorX, gpCursorY);
                    gpCursor.style.display = 'block';

                    let hoveredEl = rawEl;
                    if (hoveredEl && hoveredEl.tagName !== 'BUTTON' && hoveredEl.tagName !== 'INPUT') {
                        let el = hoveredEl.parentElement;
                        for (let i = 0; i < 4 && el; i++, el = el.parentElement) {
                            if (el.tagName === 'BUTTON' || el.tagName === 'INPUT' ||
                                interactiveClasses.some(c => el.classList.contains(c))) {
                                hoveredEl = el; break;
                            }
                        }
                    }

                    if (hoveredEl !== gpCursor._lastHovered) {
                        if (gpCursor._lastHovered) gpCursor._lastHovered.classList.remove('gp-hover');
                        if (hoveredEl) hoveredEl.classList.add('gp-hover');
                        // Sonido hover en cualquier elemento interactivo
                        if (hoveredEl && (
                            hoveredEl.tagName === 'BUTTON' ||
                            hoveredEl.tagName === 'INPUT' ||
                            interactiveClasses.some(c => hoveredEl.classList.contains(c))
                        )) {
                            unlockAudio();
                            lobbyHover();
                        }
                        gpCursor._lastHovered = hoveredEl;
                    }
                    gpCursor.style.left = gpCursorX + 'px';
                    gpCursor.style.top  = gpCursorY + 'px';
                    document.body.style.cursor = 'none';
                }

                // X (botón 0) = click o seleccionar/deseleccionar slider
                const touchClick = gpad.buttons.length > 0 && gpad.buttons[0].pressed;
                // CHANGED: Patch 6B — si el gamepad es el primer input, intentar desbloquear audio
                // (los navegadores modernos a veces permiten unlock por gamepad; los que no, lo ignoran).
                if (touchClick && !_audioUnlocked) {
                    unlockAudio();
                    _audioUnlocked = true;
                    const el = document.getElementById('click-to-start');
                    if (el) el.style.display = 'none';
                }
                if (touchClick && !gpTouchPrev && gpActive) {
                    gpCursor.style.display = 'none';
                    let el = document.elementFromPoint(gpCursorX, gpCursorY);
                    gpCursor.style.display = 'block';
                    // Subir al elemento interactivo real si el punto cae en un hijo
                    if (el && el.tagName !== 'BUTTON' && el.tagName !== 'INPUT') {
                        let p = el.parentElement;
                        for (let i = 0; i < 4 && p; i++, p = p.parentElement) {
                            if (p.tagName === 'BUTTON' || p.tagName === 'INPUT' ||
                                interactiveClasses.some(c => p.classList.contains(c))) {
                                el = p; break;
                            }
                        }
                    }
                    if (el && el.tagName === 'INPUT' && el.type === 'range') {
                        // Toggle selección del slider
                        if (gpSelectedSlider === el) {
                            gpSelectedSlider = null;
                            el.classList.remove('gp-hover');
                        } else {
                            if (gpSelectedSlider) gpSelectedSlider.classList.remove('gp-hover');
                            gpSelectedSlider = el;
                            el.classList.add('gp-hover');
                        }
                    } else if (el) {
                        if (gpSelectedSlider) { gpSelectedSlider = null; }
                        unlockAudio();
                        SFX.buttonClick();
                        if (typeof el.click === 'function') {
                            el.click();
                        } else if (el.parentElement && typeof el.parentElement.click === 'function') {
                            el.parentElement.click();
                        }
                    }
                }
                gpTouchPrev = touchClick;
            }

            // Si el mouse real se mueve, ocultar cursor gamepad
            window.addEventListener('mousemove', () => {
                if (gpActive) {
                    gpActive = false;
                    gpCursor.style.display = 'none';
                    document.body.style.cursor = '';
                    if (gpCursor._lastHovered) {
                        gpCursor._lastHovered.classList.remove('gp-hover');
                        gpCursor._lastHovered = null;
                    }
                }
            });

            // ── SOUND SYSTEM ──────────────────────────────────────────────
            document.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('mousedown', () => SFX.buttonClick());
            });

            // ── LOBBY TACTICAL SOUNDS ─────────────────────────────────────
            document.querySelectorAll('.tac-item').forEach(btn => {
                btn.addEventListener('mouseenter', () => { unlockAudio(); lobbyHover(); });
                btn.addEventListener('mousedown',  () => { unlockAudio(); lobbySelect(); });
            });

            // Start lobby hum on first interaction
            document.addEventListener('click', () => startLobbyHum(), { once: true });
            document.addEventListener('keydown', () => startLobbyHum(), { once: true });

            // ── MATCH TRANSITION WIRING ───────────────────────────────────
            // (Transitions are wired directly in button onclick handlers above)

            // Hide overlays initially until enterLobbyScene is called
            document.getElementById('lobby-vignette').style.display = 'block';
            document.getElementById('lobby-scanlines').style.display = 'block';

            // P2 card status update on gamepad connection
            let _p2Joined = false;

            function updateP2Card() {
                const card = document.getElementById('p2-lobby-card');
                if (!card) return;
                const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
                const hasGamepad = Array.from(gamepads).some(g => g && g.connected);
                if (_p2Joined) {
                    const nameEl = card.querySelector('.cod-player-name');
                    const iconEl = card.querySelector('.cod-player-icon');
                    if (nameEl) { nameEl.innerHTML = 'Player 2'; nameEl.className = 'cod-player-name'; }
                    if (iconEl) { iconEl.textContent = '\u25b2'; iconEl.className = 'cod-player-icon'; }
                    card.classList.add('cod-host');
                    card.classList.remove('cod-searching');
                    let natEl = card.querySelector('.cod-player-nat');
                    let sigEl = card.querySelector('.cod-player-signal');
                    if (hasGamepad) {
                        if (!natEl) {
                            natEl = document.createElement('span');
                            natEl.className = 'cod-player-nat';
                            natEl.textContent = '\u25a0';
                            card.appendChild(natEl);
                        }
                        if (sigEl) sigEl.remove();
                    } else {
                        if (natEl) natEl.remove();
                        if (!sigEl) {
                            sigEl = document.createElement('span');
                            sigEl.className = 'cod-player-signal';
                            sigEl.textContent = '';
                            card.appendChild(sigEl);
                        }
                    }
                }
            }

            window.addEventListener('gamepadconnected', () => {
                _p2Joined = true;
                updateP2Card();
            });

            window.addEventListener('gamepaddisconnected', () => {
                updateP2Card();
            });
            render();
        </script>
</body>

</html>