<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Base V7 - 1v1 Split Screen</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            /* Ensure UI is above Canvas */
        }

        /* SCREENS */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 4rem;
            margin-bottom: 20px;
            text-transform: uppercase;
            text-shadow: 0 0 20px currentColor;
        }

        /* Wood Texture & Crosshair Style */
        #lobby h1 {
            font-size: 7rem;
            font-weight: 900;
            margin: 0;
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: -2px;

            -webkit-text-stroke: 4px #4e342e;
            color: transparent;

            background: repeating-linear-gradient(45deg,
                    #deb887,
                    #deb887 10px,
                    #cd853f 10px,
                    #cd853f 20px);
            -webkit-background-clip: text;
            background-clip: text;

            filter: drop-shadow(4px 4px 0px #4e342e) drop-shadow(6px 6px 0px #3e2723);

            font-family: 'Arial Black', 'Impact', sans-serif;
            transform: rotate(-3deg) scaleY(1.1);
            z-index: 10;
        }

        .crosshair-o {
            position: relative;
            display: inline-block;
            color: transparent;
            -webkit-text-stroke: 4px #4e342e;
        }

        .crosshair-o::after,
        .crosshair-o::before {
            content: '';
            position: absolute;
            background: #ff4500;
            z-index: 100;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .crosshair-o::before {
            width: 60%;
            height: 6px;
            top: 50%;
            left: 20%;
            transform: translateY(-50%);
        }

        .crosshair-o::after {
            width: 6px;
            height: 60%;
            left: 50%;
            top: 20%;
            transform: translateX(-50%);
        }

        #victory-screen h1 {
            color: #ffd700;
            text-shadow: 0 0 20px #ffd700;
            font-size: 5rem;
        }

        p {
            font-size: 1.5rem;
            color: #ccc;
            margin-bottom: 40px;
        }

        .btn-container {
            display: flex;
            gap: 20px;
        }

        button {
            padding: 20px 50px;
            font-size: 1.5rem;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            text-transform: uppercase;
        }

        /* Removed specific button colors to use transparent style */
        /*
        #solo-btn {
            background: #00ff00;
            color: #000;
            box-shadow: 0 0 20px #00ff00;
        }

        #pvp-btn {
            background: #ff0055;
            color: #fff;
            box-shadow: 0 0 20px #ff0055;
        }

        #restart-btn {
            background: #ffd700;
            color: #000;
            box-shadow: 0 0 20px #ffd700;
        }
        */

        button:hover {
            transform: scale(1.1);
        }

        /* HUD */
        .hud-panel {
            position: absolute;
            width: 100%;
            height: 50%;
            pointer-events: none;
            display: none;
        }

        #hud-p1 {
            top: 0;
            border-bottom: 2px solid white;
        }

        #hud-p2 {
            bottom: 0;
            border-top: 2px solid white;
        }

        #hud-solo {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 2px solid black;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .stats-group {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: row;
            gap: 20px;
            align-items: center;
        }

        .main-stats {
            display: flex;
            gap: 20px;
        }

        /* Long Bar Override */
        .long-bar {
            width: 50vw;
            max-width: 800px;
            height: 15px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            margin-bottom: 0;
            background: rgba(0, 0, 0, 0.2);
        }

        .stat-box {
            background: transparent;
            padding: 10px 20px;
            border-radius: 10px;
            color: white;
            text-align: right;
        }

        /* Stamina Box specific style (First child) */
        .stats-bar .stat-box:first-child {
            background: transparent;
            padding-left: 0;
            padding-right: 0;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #aaa;
        }

        .bar-container {
            width: 140px;
            height: 10px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.7);
            margin-bottom: 5px;
        }

        .bar-fill {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear;
        }

        .stamina-fill {
            background-color: #ffff00;
            box-shadow: 0 0 8px #ffff00;
        }

        .health-val {
            color: #ff3333;
        }

        .ammo-val {
            color: #ffff33;
        }

        .player-label {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 5px;
        }

        /* Message Overlay */
        #msg-overlay {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            font-size: 2rem;
            color: yellow;
            text-shadow: 2px 2px 0 #000;
            display: none;
        }

        /* WEAPON SELECT */
        #weapon-select {
            margin-top: 20px;
        }

        .weapon-btn {
            background: #333;
            color: #fff;
            border: 2px solid #555;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: inherit;
        }

        .weapon-btn:hover {
            background: #555;
        }

        .weapon-btn.selected {
            background: #00ff00;
            color: #000;
            border-color: #00ff00;
            box-shadow: 0 0 15px #00ff00;
        }

        .weapon-btn-solo {
            background: #333;
            color: #fff;
            border: 2px solid #555;
            padding: 15px 30px;
            font-size: 1.2rem;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
        }

        .weapon-btn-solo:hover {
            background: #555;
        }

        /* GENERIC BUTTONS (Transparent Style) */
        button {
            font-family: inherit;
            border: none;
            outline: none;
            user-select: none;
        }

        .btn-transparent {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: #fff;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-weight: bold;
            text-transform: uppercase;
            border-radius: 12px;
            cursor: pointer;
            backdrop-filter: blur(4px);
            transition: transform 0.1s, background 0.2s, border-color 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn-transparent:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: scale(1.05);
            border-color: #fff;
        }

        .btn-transparent:active {
            transform: scale(0.95);
        }

        /* WEAPON BUTTONS */
        .weapon-btn-solo {
            width: 140px;
            height: 140px;
            background: rgba(255, 255, 255, 0.15);
            /* Matches btn-transparent */
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: #fff;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            border-radius: 15px;
            transition: all 0.2s;
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .weapon-btn-solo:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-5px);
        }

        /* SELECTED STATES (Flat Colors, No Neon) */
        .weapon-btn-solo.selected {
            background: rgba(0, 255, 0, 0.25);
            /* Glassy Green */
            border-color: #00ff00;
            color: #fff;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.4);
            backdrop-filter: blur(6px);
        }

        .weapon-btn-solo.p1:hover {
            background: rgba(0, 204, 255, 0.2);
        }

        .weapon-btn-solo.p1.selected {
            background: rgba(0, 204, 255, 0.25);
            /* Glassy Blue */
            border-color: #00ccff;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.4);
            color: #fff;
            backdrop-filter: blur(6px);
        }

        .weapon-btn-solo.p2:hover {
            background: rgba(255, 0, 255, 0.2);
        }

        .weapon-btn-solo.p2.selected {
            background: rgba(255, 0, 255, 0.25);
            /* Glassy Pink */
            border-color: #ff00ff;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
            color: #fff;
            backdrop-filter: blur(6px);
        }

        /* IN-GAME MENU BTN (Kept as requested, but ensuring z-index) */
        #ingame-menu-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.15);
            /* Transparent */
            color: #fff;
            border: 2px solid rgba(255, 255, 255, 0.5);
            /* Semi-transparent border */
            font-size: 1rem;
            cursor: pointer;
            z-index: 100000;
            pointer-events: auto;
            font-weight: bold;
            user-select: none;
            backdrop-filter: blur(4px);
            border-radius: 8px;
            transition: all 0.2s;
        }

        #ingame-menu-btn:hover {
            background: #fff;
            color: #000;
        }

        /* MENU BACKGROUND LAYER */
        #menu-background-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            /* Behind UI */
            background: linear-gradient(180deg, #FFF5EE 0%, #FFDAB9 40%, #FFD700 80%, #90EE90 100%);
            /* Very Light Sunset */
            overflow: hidden;
            filter: brightness(1.3) saturate(1.3);
            /* Strong Global Boost */
        }

        /* SCREENS (Make transparent) */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            /* No background color, let layer show through */
            z-index: 10;
        }

        /* LOBBY BACKGROUND CSS - OVERRIDDEN */
        /* Background handled by #menu-background-layer */

        .lobby-scene {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        /* NEW RELAXED LANDSCAPE CSS */
        .lobby-sun {
            position: absolute;
            bottom: 30%;
            /* Lower sun */
            left: 50%;
            width: 400px;
            /* Bigger sun */
            height: 400px;
            background: #FFFACD;
            /* LemonChiffon (Softer sun) */
            border-radius: 50%;
            transform: translate(-50%, 50%);
            box-shadow: 0 0 100px rgba(255, 250, 205, 0.8);
            z-index: 1;
        }

        .hill {
            position: absolute;
            border-radius: 50%;
            background: #90EE90;
            /* Lighter Green */
            box-shadow: inset -20px -20px 40px rgba(0, 0, 0, 0.05);
            /* Softer shadow */
        }

        .hill-back-1 {
            width: 150%;
            height: 60%;
            left: -25%;
            bottom: -20%;
            background: #7CCD7C;
            /* Lighter Back Green */
            z-index: 2;
        }

        .hill-back-2 {
            width: 120%;
            height: 50%;
            right: -10%;
            bottom: -15%;
            background: #66CDAA;
            /* Medium Aquamarine */
            z-index: 2;
        }

        .hill-front {
            width: 140%;
            height: 50%;
            left: -20%;
            bottom: -25%;
            background: #98FB98;
            /* PaleGreen (Front) */
            z-index: 3;
        }

        /* PATH */
        .path {
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 200px;
            height: 50%;
            background: #DEB887;
            /* Burlywood */
            transform: translateX(-50%) perspective(500px) rotateX(60deg);
            clip-path: polygon(20% 0, 80% 0, 100% 100%, 0% 100%);
            z-index: 3;
            opacity: 0.8;
            border-radius: 20px 20px 0 0;
        }

        /* ROUND TREES (Replacing Pines) */
        .round-tree {
            position: absolute;
            z-index: 4;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .tree-trunk {
            width: 20px;
            height: 60px;
            background: #8B4513;
            /* SaddleBrown */
            border-radius: 5px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
        }

        .tree-foliage {
            width: 100px;
            height: 100px;
            background: #32CD32;
            /* LimeGreen */
            border-radius: 50%;
            margin-bottom: -20px;
            /* Overlap trunk */
            box-shadow: inset -10px -10px 20px rgba(0, 0, 0, 0.1), 5px 5px 10px rgba(255, 255, 255, 0.2);
            /* Lighter highlights */
            position: relative;
        }

        /* Multiple foliage blobs */
        .tree-foliage::before {
            content: '';
            position: absolute;
            top: -20px;
            left: -20px;
            width: 80px;
            height: 80px;
            background: #4CC417;
            /* Apple Green */
            border-radius: 50%;
            z-index: -1;
        }

        .tree-foliage::after {
            content: '';
            position: absolute;
            top: -10px;
            right: -20px;
            width: 80px;
            height: 80px;
            background: #52D017;
            /* YellowGreen */
            border-radius: 50%;
            z-index: -1;
        }

        /* Tree Positions */
        .t1 {
            left: 10%;
            bottom: 25%;
            transform: scale(1.2);
        }

        .t2 {
            left: 85%;
            bottom: 20%;
            transform: scale(1.3);
        }

        .t3 {
            left: 5%;
            bottom: 15%;
            transform: scale(1.5);
            z-index: 5;
        }

        .t4 {
            left: 75%;
            bottom: 30%;
            transform: scale(0.8);
            z-index: 2;
        }

        .t5 {
            left: 25%;
            bottom: 32%;
            transform: scale(0.7);
            z-index: 2;
        }

        /* CLOUDS */
        .cloud {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.05);
            animation: floatCloud 60s linear infinite;
        }

        .cloud::after,
        .cloud::before {
            content: '';
            position: absolute;
            background: inherit;
            border-radius: 50%;
        }

        .c1 {
            top: 10%;
            left: 10%;
            width: 120px;
            height: 40px;
            animation-duration: 80s;
            opacity: 0.9;
        }

        .c1::after {
            width: 50px;
            height: 50px;
            top: -25px;
            left: 20px;
        }

        .c1::before {
            width: 40px;
            height: 40px;
            top: -15px;
            right: 20px;
        }

        .c2 {
            top: 15%;
            right: 20%;
            width: 100px;
            height: 35px;
            animation-duration: 60s;
            opacity: 0.8;
        }

        .c2::after {
            width: 40px;
            height: 40px;
            top: -20px;
            left: 15px;
        }

        @keyframes floatCloud {
            from {
                transform: translateX(-100px);
            }

            to {
                transform: translateX(100vw);
            }
        }
    </style>
    <script type="importmap"> {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }

        </script>
</head>

<body>
    <div id="game-container"></div>
    <div id="ui-layer">
        <button id="ingame-menu-btn" class="hidden">MENU</button>

        <!-- SHARED BACKGROUND LAYER -->
        <div id="menu-background-layer">
            <div class="lobby-scene">
                <div class="lobby-sun"></div>
                <!-- Hills -->
                <div class="hill hill-back-1"></div>
                <div class="hill hill-back-2"></div>
                <!-- Path -->
                <div class="path"></div>
                <!-- Front Hill -->
                <div class="hill hill-front"></div>

                <!-- Clouds -->
                <div class="cloud c1"></div>
                <div class="cloud c2"></div>

                <!-- Round Trees -->
                <div class="round-tree t1">
                    <div class="tree-foliage"></div>
                    <div class="tree-trunk"></div>
                </div>
                <div class="round-tree t2">
                    <div class="tree-foliage"></div>
                    <div class="tree-trunk"></div>
                </div>
                <div class="round-tree t3">
                    <div class="tree-foliage"></div>
                    <div class="tree-trunk"></div>
                </div>
                <div class="round-tree t4">
                    <div class="tree-foliage"></div>
                    <div class="tree-trunk"></div>
                </div>
                <div class="round-tree t5">
                    <div class="tree-foliage"></div>
                    <div class="tree-trunk"></div>
                </div>
            </div>
        </div>

        <!-- LOBBY -->
        <div id="lobby" class="screen">
            <!-- Background elements moved to shared layer -->
            <h1>BLANKSH<span class="crosshair-o">O</span>T</h1>
            <p>Select Game Mode</p>
            <div class="btn-container">
                <button id="solo-btn" class="btn-transparent">SOLO (vs AI)</button>
                <button id="pvp-btn" class="btn-transparent">1v1 SPLIT SCREEN</button>
            </div>
        </div>
        <!-- SOLO WEAPON SELECT -->
        <div id="solo-weapon-select" class="screen hidden">
            <h1 style="color:#00ff00; text-shadow: 0 0 20px #00ff00;">SELECT WEAPON</h1>
            <div id="solo-weapon-options" style="display:flex; gap:20px; margin-bottom: 40px;"><button
                    class="weapon-btn-solo" data-weapon="sniper"
                    onclick="selectSoloWeapon('sniper')">Sniper</button><button class="weapon-btn-solo selected"
                    data-weapon="ar" onclick="selectSoloWeapon('ar')">Assault Rifle</button><button
                    class="weapon-btn-solo" data-weapon="smg" onclick="selectSoloWeapon('smg')">SMG</button><button
                    class="weapon-btn-solo" data-weapon="pistol" onclick="selectSoloWeapon('pistol')">Pistol</button>
            </div><button id="start-solo-match-btn" class="btn-transparent" style="padding: 15px 50px;">START
                MISSION</button>
        </div>
        <!-- PVP WEAPON SELECT -->
        <div id="pvp-weapon-select" class="screen hidden" style="position:relative;">
            <!-- P1 PANEL (TOP) -->
            <div class="split-panel top"
                style="position:absolute; top:30px; left:0; width:100%; display:flex; flex-direction:column; align-items:center;">
                <h2
                    style="color:#00ccff; text-shadow: 0 0 20px #00ccff; margin-bottom: 20px; font-size: 3rem; margin-top: 0;">
                    PLAYER 1</h2>
                <div style="display:flex; gap:20px;">
                    <button class="weapon-btn-solo p1" data-player="1" data-weapon="sniper"
                        onclick="selectPvPWeapon(1, 'sniper')">Sniper</button>
                    <button class="weapon-btn-solo p1 selected" data-player="1" data-weapon="ar"
                        onclick="selectPvPWeapon(1, 'ar')">Assault Rifle</button>
                    <button class="weapon-btn-solo p1" data-player="1" data-weapon="smg"
                        onclick="selectPvPWeapon(1, 'smg')">SMG</button>
                    <button class="weapon-btn-solo p1" data-player="1" data-weapon="pistol"
                        onclick="selectPvPWeapon(1, 'pistol')">Pistol</button>
                </div>
            </div>
            <!-- P2 PANEL (BOTTOM) -->
            <div class="split-panel bottom"
                style="position:absolute; bottom:30px; left:0; width:100%; display:flex; flex-direction:column; align-items:center;">
                <h2 style="color:#ff00ff; text-shadow: 0 0 20px #ff00ff; margin-bottom: 20px; font-size: 3rem;">
                    PLAYER 2 </h2>
                <div style="display:flex; gap:20px;">
                    <button class="weapon-btn-solo p2" data-player="2" data-weapon="sniper"
                        onclick="selectPvPWeapon(2, 'sniper')">Sniper</button>
                    <button class="weapon-btn-solo p2 selected" data-player="2" data-weapon="ar"
                        onclick="selectPvPWeapon(2, 'ar')">Assault Rifle</button>
                    <button class="weapon-btn-solo p2" data-player="2" data-weapon="smg"
                        onclick="selectPvPWeapon(2, 'smg')">SMG</button>
                    <button class="weapon-btn-solo p2" data-player="2" data-weapon="pistol"
                        onclick="selectPvPWeapon(2, 'pistol')">Pistol</button>
                </div>
            </div>
            <button id="start-pvp-match-btn" class="btn-transparent"
                style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index: 200;">START
                MATCH</button>
        </div>

        <!-- VICTORY SCREEN -->
        <div id="victory-screen" class="screen hidden">
            <h1 id="win-text">VICTORY</h1><button id="restart-btn" class="btn-transparent">MAIN MENU</button>
        </div>

        <!-- HUD: SOLO -->
        <div id="hud-solo">
            <div class="crosshair"></div>
            <div class="player-label" style="display:none">SOLO</div>
            <!-- Hidden -->
            <div class="stats-group">
                <div class="stamina-row">
                    <div class="bar-container long-bar">
                        <div class="bar-fill stamina-fill" id="solo-stamina-bar" style="width: 100%;"></div>
                    </div>
                </div>
                <div class="main-stats">
                    <div class="stat-box">
                        <div class="stat-value health-val" id="solo-hp">100</div>
                        <div class="stat-label">HEALTH</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value ammo-val" id="solo-ammo">30</div>
                        <div class="stat-label">AMMO</div>
                    </div>
                </div>
            </div>
            <div style="position:absolute; top:20px; left:50%; transform:translateX(-50%); color:red; font-size:2rem; font-weight:bold"
                id="solo-enemies">ENEMIES: 10</div>
        </div>

        <!-- HUD: P1 (Top) -->
        <div id="hud-p1" class="hud-panel">
            <div class="crosshair"></div>
            <div class="player-label" style="color:#00ccff;">P1</div>
            <div class="stats-group">
                <div class="stamina-row">
                    <div class="bar-container long-bar">
                        <div class="bar-fill stamina-fill" id="p1-stamina-bar" style="width: 100%;">
                        </div>
                    </div>
                </div>
                <div class="main-stats">
                    <div class="stat-box">
                        <div class="stat-value health-val" id="p1-hp">100</div>
                        <div class="stat-label">HEALTH</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value ammo-val" id="p1-ammo">30</div>
                        <div class="stat-label">AMMO</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- HUD: P2 (Bottom) -->
        <div id="hud-p2" class="hud-panel">
            <div class="crosshair"></div>
            <div class="player-label" style="color:#ff00ff;">P2</div>
            <div class="stats-group">
                <div class="stamina-row">
                    <div class="bar-container long-bar">
                        <div class="bar-fill stamina-fill" id="p2-stamina-bar" style="width: 100%;"></div>
                    </div>
                </div>
                <div class="main-stats">
                    <div class="stat-box">
                        <div class="stat-value health-val" id="p2-hp">100</div>
                        <div class="stat-label">HEALTH</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value ammo-val" id="p2-ammo">30</div>
                        <div class="stat-label">AMMO</div>
                    </div>
                </div>
            </div>
        </div>
        <script type="module">import * as THREE from 'three';

            // -- CONFIG --
            const MAP_SIZE = 200;
            const GRAVITY = -30;

            const MODE = {
                MENU: 0, SOLO: 1, PVP: 2, END: 3, PVP_SELECT: 4, SOLO_SELECT: 5
            }

                ;

            const WEAPONS = {
                sniper: {
                    name: "Sniper", dmg: 20, speed: 100, reload: 2000, cd: 800, color: 0x00ff00
                }

                ,
                ar: {
                    name: "Assault Rifle", dmg: 10, speed: 60, reload: 2000, cd: 200, color: 0xffff00
                }

                ,
                smg: {
                    name: "SMG", dmg: 5, speed: 40, reload: 2000, cd: 100, color: 0x00ffff
                }

                ,
                pistol: {
                    name: "Pistol", dmg: 15, speed: 70, reload: 1000, cd: 400, color: 0xff0000
                }
            }

                ;
            let selectedWeapon = 'ar';
            let p1SelectedWeapon = 'ar';
            let p2SelectedWeapon = 'ar';

            // Globals
            let gameMode = MODE.MENU;
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 150);

            const renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            const clock = new THREE.Clock();

            // -- LIGHTS & ENV --
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // -- TERRAIN --
            function getTerrainHeight(x, z) {
                const scale1 = 0.05;
                const scale2 = 0.15;
                const h1 = Math.sin(x * scale1) * Math.cos(z * scale1) * 8;
                const h2 = Math.sin(x * scale2 + 2.5) * Math.sin(z * scale2 + 2.5) * 2;
                return Math.max(0, h1 + h2);
            }

            const geo = new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE, 64, 64);
            const posAttr = geo.attributes.position;

            for (let i = 0; i < posAttr.count; i++) {
                const x = posAttr.getX(i);
                const y = posAttr.getY(i);
                posAttr.setZ(i, getTerrainHeight(x, -y));
            }

            geo.computeVertexNormals();

            const ground = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({
                color: 0x3b8c3b, flatShading: true
            }));
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Trees
            const treePos = [{
                x: 20, z: 20
            }

                ,
            {
                x: -30, z: 40
            }

                ,
            {
                x: 50, z: -50
            }

                ,
            {
                x: -10, z: -10
            }

                ,
            {
                x: 60, z: 10
            }

                ,
            {
                x: -70, z: -20
            }

                ,
            {
                x: 0, z: 80
            }

                ,
            {
                x: -40, z: 60
            }

                ,
            {
                x: 35, z: -35
            }

                ,
            {
                x: -25, z: -70
            }

                ,
            {
                x: 80, z: 0
            }

                ,
            {
                x: -60, z: 30
            }

                ,
            {
                x: 10, z: -10
            }

                ,
            {
                x: -5, z: 5
            }

                ,
            {
                x: 70, z: 70
            }

                ,
            {
                x: -70, z: -70
            }

                ,
            {
                x: 15, z: 55
            }

                ,
            {
                x: -15, z: -55
            }

                ,
            {
                x: 85, z: -20
            }

                ,
            {
                x: -85, z: 20
            }

                ,
            {
                x: 40, z: 80
            }

                ,
            {
                x: -40, z: -80
            }

                ,
            {
                x: 5, z: 30
            }

                ,
            {
                x: -5, z: -30
            }

            ];

            function createTree(x, z) {
                const h = getTerrainHeight(x, z);
                const g = new THREE.Group();
                g.position.set(x, h, z);

                const t = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, 3, 6), new THREE.MeshStandardMaterial({
                    color: 0x4d2926
                }));
                t.position.y = 1.5;
                t.castShadow = true;

                const l = new THREE.Mesh(new THREE.ConeGeometry(3, 6, 8), new THREE.MeshStandardMaterial({
                    color: 0x1e591e
                }));
                l.position.y = 4.5;
                l.castShadow = true;
                g.add(t);
                g.add(l);
                scene.add(g);
            }

            treePos.forEach(p => createTree(p.x, p.z));

            // -- PLAYER CLASS --
            class Player {
                constructor(id, color, startPos, weaponKey = 'pistol') {
                    this.id = id;
                    this.color = color;
                    // Build Android-style Mesh
                    this.mesh = new THREE.Group();

                    const mat = new THREE.MeshStandardMaterial({
                        color: color
                    });

                    // Body (Cylinder)
                    const bodyGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.8, 16);
                    const body = new THREE.Mesh(bodyGeo, mat);
                    body.position.y = 0;
                    body.castShadow = true;
                    this.mesh.add(body);
                    this.body = body; // Reference for animation

                    // Head (Half Sphere)
                    const headGeo = new THREE.SphereGeometry(0.5, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.5);
                    const head = new THREE.Mesh(headGeo, mat);
                    head.position.y = 0.4;
                    head.castShadow = true;
                    this.mesh.add(head);
                    this.head = head; // Reference for animation

                    // Legs
                    const legGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.5, 8);
                    const legL = new THREE.Mesh(legGeo, mat);
                    legL.position.set(-0.2, -0.65, 0);
                    legL.castShadow = true;
                    this.mesh.add(legL);
                    this.legL = legL; // Reference for animation

                    const legR = new THREE.Mesh(legGeo, mat);
                    legR.position.set(0.2, -0.65, 0);
                    legR.castShadow = true;
                    this.mesh.add(legR);
                    this.legR = legR; // Reference for animation

                    // Arms
                    const armGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.6, 8);
                    const armL = new THREE.Mesh(armGeo, mat);
                    armL.position.set(-0.62, 0.1, 0);
                    armL.castShadow = true;
                    this.mesh.add(armL);
                    this.armL = armL; // Reference for animation

                    const armR = new THREE.Mesh(armGeo, mat);
                    armR.position.set(0.62, 0.1, 0);
                    armR.castShadow = true;
                    this.mesh.add(armR);
                    this.armR = armR; // Reference for animation

                    // Eyes (White)
                    const eyeGeo = new THREE.SphereGeometry(0.08, 8, 8);

                    const eyeMat = new THREE.MeshBasicMaterial({
                        color: 0xffffff
                    });
                    const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
                    eyeL.position.set(-0.2, 0.65, 0.35);
                    this.mesh.add(eyeL);
                    const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
                    eyeR.position.set(0.2, 0.65, 0.35);
                    this.mesh.add(eyeR);

                    this.mesh.position.copy(startPos);
                    scene.add(this.mesh);

                    this.camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);

                    this.cameraAngle = {
                        x: 0, y: Math.PI
                    }

                        ; // x=Pitch, y=Yaw
                    this.velocity = new THREE.Vector3(0, 0, 0);
                    this.onGround = false;
                    this.hp = 100;
                    this.ammo = 30;
                    this.reloading = false;

                    // Stamina
                    this.stamina = 100;
                    this.maxStamina = 100;

                    // Stats
                    this.moveSpeed = 12;

                    // Load Weapon Stats
                    this.setWeapon(weaponKey);

                    this.flashTimer = 0;
                    this.lastTrigger = 0;

                    // Input State
                    this.input = {
                        x: 0, y: 0, jump: false, shoot: false, reload: false, sprint: false
                    }

                        ;

                    this.prevInput = {
                        ...this.input
                    }

                        ;
                }

                setWeapon(key) {
                    const w = WEAPONS[key] || WEAPONS.ar;
                    this.damage = w.dmg;
                    this.projSpeed = w.speed;
                    this.reloadTime = w.reload;
                    this.fireRate = w.cd;
                    this.projColor = w.color;
                }

                respawn(pos) {
                    this.mesh.position.copy(pos);
                    this.velocity.set(0, 0, 0);
                    this.hp = 100;
                    this.ammo = 30;
                    this.stamina = this.maxStamina; // Reset Stamina
                    this.reloading = false;

                    this.cameraAngle = {
                        x: 0, y: Math.PI
                    }

                        ;

                    // Animation properties
                    this.walkCycle = 0;
                    this.bobPhase = 0;

                    this.mesh.children.forEach(c => {
                        if (c.material && c.material.type === 'MeshStandardMaterial') {
                            c.material.color.setHex(this.color);
                        }
                    });
                }

                takeDamage(amount) {
                    this.hp -= amount;

                    this.mesh.children.forEach(c => {
                        if (c.material && c.material.type === 'MeshStandardMaterial') {
                            c.material.color.setHex(0xffffff);
                        }
                    });

                    clearTimeout(this.flashTimer);

                    this.flashTimer = setTimeout(() => {
                        this.mesh.children.forEach(c => {
                            if (c.material && c.material.type === 'MeshStandardMaterial') {
                                c.material.color.setHex(this.color);
                            }
                        });
                    }

                        , 100);
                }

                update(dt) {
                    if (this.hp <= 0) return;

                    // SAFETY CHECK: NaN Position (Fixes "Sky Glitch")
                    if (isNaN(this.mesh.position.x) || isNaN(this.mesh.position.y) || isNaN(this.mesh.position.z)) {
                        console.warn("NaN Position Detected! Resetting Player.");
                        this.respawn(new THREE.Vector3(0, 20, 0));
                        return;
                    }

                    // -- MOVEMENT --
                    // Yaw applies to movement frame
                    const sinY = Math.sin(this.cameraAngle.y);
                    const cosY = Math.cos(this.cameraAngle.y);
                    const forward = new THREE.Vector3(-sinY, 0, -cosY);
                    const right = new THREE.Vector3(cosY, 0, -sinY);

                    const moveDir = new THREE.Vector3();
                    moveDir.add(forward.clone().multiplyScalar(this.input.y));
                    moveDir.add(right.clone().multiplyScalar(this.input.x));

                    if (moveDir.length() > 1) moveDir.normalize();

                    // Stamina Logic
                    let currentSpeed = this.moveSpeed;
                    const isMoving = moveDir.length() > 0;

                    if (this.input.sprint && isMoving && this.stamina > 0) {
                        currentSpeed *= 1.6;
                        this.stamina -= 30 * dt;
                        if (this.stamina < 0) this.stamina = 0;
                    }

                    else {
                        this.stamina += 15 * dt;
                        if (this.stamina > this.maxStamina) this.stamina = this.maxStamina;
                    }

                    if (isMoving) {
                        const step = moveDir.multiplyScalar(currentSpeed * dt);
                        const nextPos = this.mesh.position.clone().add(step);
                        // Tree collision
                        let hit = false;

                        for (let t of treePos) {
                            if ((nextPos.x - t.x) ** 2 + (nextPos.z - t.z) ** 2 < 1.0) hit = true;
                        }

                        if (!hit) this.mesh.position.add(step);

                        // Face Camera Yaw
                        this.mesh.rotation.y = this.cameraAngle.y + Math.PI;

                        // WALKING ANIMATION - Independent limb movement
                        const walkSpeed = this.input.sprint ? 12 : 8;
                        this.walkCycle += dt * walkSpeed;
                        this.bobPhase = Math.sin(this.walkCycle) * 0.15;
                        
                        // Animate arms and legs independently (alternating)
                        const swingAmount = 0.4; // Amount of swing
                        
                        // Only animate if references exist (safety check)
                        if (this.armR && this.armL && this.legR && this.legL && this.body) {
                            // Right arm swings forward with left leg (natural walking)
                            this.armR.rotation.x = Math.sin(this.walkCycle) * swingAmount;
                            this.legL.rotation.x = Math.sin(this.walkCycle) * swingAmount;
                            
                            // Left arm swings forward with right leg
                            this.armL.rotation.x = -Math.sin(this.walkCycle) * swingAmount;
                            this.legR.rotation.x = -Math.sin(this.walkCycle) * swingAmount;
                            
                            // Subtle body lean
                            this.body.rotation.z = Math.cos(this.walkCycle * 0.5) * 0.02;
                        }
                    }

                    else {
                        this.mesh.rotation.y = this.cameraAngle.y + Math.PI;
                        
                        // Reset animation smoothly
                        this.bobPhase *= 0.9;
                        
                        // Reset limb rotations (with safety check)
                        if (this.armR && this.armL && this.legR && this.legL && this.body) {
                            this.armR.rotation.x *= 0.9;
                            this.armL.rotation.x *= 0.9;
                            this.legR.rotation.x *= 0.9;
                            this.legL.rotation.x *= 0.9;
                            this.body.rotation.z *= 0.9;
                        }
                    }

                    // Jump
                    if (this.input.jump && this.onGround) {
                        this.velocity.y = 15;
                        this.onGround = false;
                    }

                    // Physics
                    this.velocity.y += GRAVITY * dt;
                    this.mesh.position.y += this.velocity.y * dt;

                    // Terrain
                    this.mesh.position.x = Math.max(-98, Math.min(98, this.mesh.position.x));
                    this.mesh.position.z = Math.max(-98, Math.min(98, this.mesh.position.z));
                    const h = getTerrainHeight(this.mesh.position.x, this.mesh.position.z);

                    if (this.mesh.position.y < h + 1) {
                        this.mesh.position.y = h + 1 + this.bobPhase;
                        this.velocity.y = 0;
                        this.onGround = true;
                    }

                    else {
                        this.onGround = false;
                    }

                    // FALL RESET: If player falls through world or flies too high
                    if (this.mesh.position.y < -50 || this.mesh.position.y > 500) {
                        this.hp = 0; // Die if void
                    }

                    // -- ORBITAL CAMERA --
                    // Pos = Player + SphericalOffset
                    const camDist = 6;
                    // Limit pitch to prevent flipping (e.g. -80 to +80 deg)
                    // Clamp Pitch HERE to strictly prevent accumulation
                    this.cameraAngle.x = Math.max(-1.4, Math.min(1.4, this.cameraAngle.x));

                    const pitch = this.cameraAngle.x;
                    // "Behind" means opposite to angle.
                    // We want camera to orbit. 
                    // Y offset (Height) depends on sin(pitch).
                    // Horiz offset depends on cos(pitch).

                    const cHeight = Math.sin(pitch) * camDist;
                    const cHoriz = Math.cos(pitch) * camDist;

                    // X/Z offset depends on Yaw
                    const offX = Math.sin(this.cameraAngle.y) * cHoriz;
                    const offZ = Math.cos(this.cameraAngle.y) * cHoriz;

                    // Target is Player Center/Head
                    const target = this.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0));

                    // Camera Position
                    this.camera.position.set(target.x + offX,
                        target.y + cHeight,
                        target.z + offZ);

                    this.camera.lookAt(target);

                    // Action: Shoot
                    if (this.input.shoot) {
                        // Removed !prevInput check for auto-fire support if wanted, but cooldown handles it
                        this.shoot();
                    }

                    // Action: Reload
                    if (this.input.reload && !this.prevInput.reload) {
                        this.startReload();
                    }

                    this.prevInput = {
                        ...this.input
                    }

                        ;
                }

                shoot() {
                    if (this.reloading || this.ammo <= 0) return;

                    // Rate Limit from Weapon
                    if (Date.now() - this.lastTrigger < this.fireRate) return;
                    this.lastTrigger = Date.now();

                    this.ammo--;

                    const start = this.mesh.position.clone();
                    start.y += 1;

                    const dir = new THREE.Vector3();
                    this.camera.getWorldDirection(dir);

                    spawnProjectile(start, dir, this.projSpeed, this.id, this.damage, this.projColor);

                    if (this.ammo === 0) this.startReload();
                }

                startReload() {
                    if (this.reloading || this.ammo === 30) return;
                    this.reloading = true;

                    setTimeout(() => {
                        this.ammo = 30;
                        this.reloading = false;
                    }

                        , this.reloadTime); // Weapon Reload Time
                }
            }

            const p1 = new Player(1, 0x00ccff, new THREE.Vector3(0, 20, 0), 'ar');
            const p2 = new Player(2, 0xff00ff, new THREE.Vector3(0, 20, 0), 'ar');

            // -- ENEMIES --
            const enemies = [];

            const enemySpawnPoints = [{
                x: 40, z: 40
            }

                ,
            {
                x: -40, z: -40
            }

                ,
            {
                x: 40, z: -40
            }

                ,
            {
                x: -40, z: 40
            }

                ,
            {
                x: 60, z: 0
            }

                ,
            {
                x: 0, z: 60
            }

                ,
            {
                x: -60, z: 0
            }

                ,
            {
                x: 50, z: 50
            }

                ,
            {
                x: -50, z: -50
            }

                ,
            {
                x: 30, z: -60
            }

            ];

            class AIEnemy extends Player {
                constructor(pos) {
                    // Random Weapon for AI
                    const keys = Object.keys(WEAPONS);
                    const rndKey = keys[Math.floor(Math.random() * keys.length)];

                    // Get terrain height at spawn position for proper ground placement
                    const terrainHeight = getTerrainHeight(pos.x, pos.z);
                    super(3, 0xff0000, new THREE.Vector3(pos.x, terrainHeight + 2, pos.z), rndKey);

                    this.aggro = false;
                    this.nextMove = 0;
                    this.strafe = 1;
                    this.lastShot = 0;

                    // CUSTOM STATS
                    this.moveSpeed = 8;
                    // projSpeed/Damage etc inherited from setWeapon call in super

                    // Behavior Config
                    this.preferredDist = 40 + Math.random() * 20; // 40-60m Range (Doubled)
                    this.shootInterval = 1000 + Math.random() * 1000; // Faster frequency check

                    // Desync Start
                    this.lastShot = Date.now() - Math.random() * 500;
                }

                // Override to add AGGRO
                takeDamage(amount) {
                    super.takeDamage(amount);
                    this.aggro = true; // Alerts AI if shot from far away
                }

                update(dt) {
                    if (this.hp <= 0) {
                        if (this.mesh.parent) scene.remove(this.mesh);
                        return;
                    }

                    try {
                        const dist = this.mesh.position.distanceTo(p1.mesh.position);

                        this.input.y = 0;
                        this.input.x = 0;

                        if (dist < 100 || this.aggro) {
                            // Increased Range to 100
                            const toP = p1.mesh.position.clone().sub(this.mesh.position).normalize();

                            // Update Yaw to FACE player (add PI because model Z-forward vs atan2)
                            this.cameraAngle.y = Math.atan2(toP.x, toP.z) + Math.PI;

                            // Move Logic: Strict 20m Retreat
                            // Approach if > preferred, Retreat if < 20
                            if (dist > this.preferredDist + 2) this.input.y = 1;
                            else if (dist < 20) this.input.y = -1; // RETREAT FROM 20m!

                            if (Date.now() > this.nextMove) {
                                this.strafe *= -1;
                                this.nextMove = Date.now() + 1000 + Math.random() * 2000;
                                if (Math.random() > 0.7) this.input.jump = true;
                            }

                            else {
                                this.input.jump = false;
                            }

                            this.input.x = this.strafe;

                            if (Date.now() - this.lastShot > this.shootInterval) {
                                this.lastShot = Date.now();
                                // Recalc Interval for variety
                                this.shootInterval = 1500 + Math.random() * 1000;

                                // CORRECTED AIM: Source(Head) -> Target(Lower Chest)
                                const source = this.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0));
                                // Aim lower (0.75) to hit chest/stomach
                                const target = p1.mesh.position.clone().add(new THREE.Vector3(0, 0.75, 0));
                                const aimDir = target.sub(source).normalize();

                                spawnProjectile(source, aimDir, this.projSpeed, 3, this.damage, this.projColor);
                            }
                        }

                        super.update(dt);
                    }

                    catch (e) {
                        console.error("AI Error", e);
                    }
                }
            }

            // -- PROJECTILES --
            const projectiles = [];

            function spawnProjectile(pos, dir, speed, ownerId, damage, color) {
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({
                    color: color || 0xffff00
                }));
                mesh.position.copy(pos);
                scene.add(mesh);

                projectiles.push({
                    mesh, vel: dir.normalize().multiplyScalar(speed), life: 2.0, owner: ownerId, damage: damage
                });
            }

            // -- INPUT --
            const keys = {}

                ;
            let prevP2Buttons = []; // Track P2 gamepad button states
            // Debug Last Key
            let lastKeyDebug = "None";

            window.addEventListener('keydown', e => {
                keys[e.code] = true;
                lastKeyDebug = e.code; // Update debug var
            });
            window.addEventListener('keyup', e => keys[e.code] = false);

            document.body.addEventListener('mousemove', e => {
                if (document.pointerLockElement === document.body) {
                    // NaN Shield
                    const mx = e.movementX || 0;
                    const my = e.movementY || 0;
                    if (Math.abs(mx) > 500 || Math.abs(my) > 500) return; // Ignore jumps

                    p1.cameraAngle.y -= mx * 0.002;
                    p1.cameraAngle.x += my * 0.002;

                    // Safety Clamp
                    if (isNaN(p1.cameraAngle.x)) p1.cameraAngle.x = 0;
                    if (isNaN(p1.cameraAngle.y)) p1.cameraAngle.y = Math.PI;

                    p1.cameraAngle.x = Math.max(-1.4, Math.min(1.4, p1.cameraAngle.x));
                }
            });

            document.body.addEventListener('mousedown', (e) => {
                // Prevent PointerLock in Menus
                if (gameMode === MODE.MENU || gameMode === MODE.PVP_SELECT || gameMode === MODE.END) return;

                if (document.pointerLockElement !== document.body) document.body.requestPointerLock();
                else p1.input.shoot = true;
            });
            document.body.addEventListener('mouseup', () => p1.input.shoot = false);

            function updateInput() {
                // Prevent Input in Menus
                if (gameMode !== MODE.SOLO && gameMode !== MODE.PVP) return;

                // P1
                p1.input.y = (keys['KeyW'] ? 1 : 0) - (keys['KeyS'] ? 1 : 0);
                p1.input.x = (keys['KeyD'] ? 1 : 0) - (keys['KeyA'] ? 1 : 0);
                p1.input.jump = keys['Space'];
                p1.input.reload = keys['KeyR'];
                p1.input.sprint = keys['ShiftLeft']; // Sprint

                // P2
                // Check all gamepads for P2 input if 1v1
                let gp = null;

                if (navigator.getGamepads) {
                    const gamepads = navigator.getGamepads();

                    for (let i = 0; i < gamepads.length; i++) {
                        if (gamepads[i] && gamepads[i].buttons && gamepads[i].buttons.length > 0) {
                            // Simple logic: Use the first gamepad found as "The Gamepad"
                            gp = gamepads[i];
                            break;
                        }
                    }
                }

                let p2MoveX = 0,
                    p2MoveY = 0,
                    p2Jump = false,
                    p2Shoot = false,
                    p2Reload = false,
                    p2Sprint = false;

                // Keyboard Fallback
                p2MoveX = (keys['ArrowRight'] ? 1 : 0) - (keys['ArrowLeft'] ? 1 : 0);
                p2MoveY = (keys['ArrowUp'] ? 1 : 0) - (keys['ArrowDown'] ? 1 : 0);
                p2Jump = keys['ControlRight'] || keys['Numpad0'];
                p2Shoot = keys['Enter'] || keys['NumpadEnter'];
                p2Reload = keys['ShiftRight'];

                // Gamepad
                if (gp) {
                    // PvP Weap Select handled in keydown/gamepad detection, not here for P2 movement

                    const deadzone = 0.2;

                    if (gp.axes && gp.axes.length > 1) {
                        if (Math.abs(gp.axes[0]) > deadzone) p2MoveX = gp.axes[0];
                        if (Math.abs(gp.axes[1]) > deadzone) p2MoveY = -gp.axes[1];
                    }

                    if (gp.axes && gp.axes.length > 3) {
                        const lookX = Math.abs(gp.axes[2]) > deadzone ? gp.axes[2] : 0;
                        const lookY = Math.abs(gp.axes[3]) > deadzone ? gp.axes[3] : 0;
                        p2.cameraAngle.y -= lookX * 0.05;
                        p2.cameraAngle.x += lookY * 0.05;
                    }

                    // Clamp P2 IMMEDIATELY
                    p2.cameraAngle.x = Math.max(-1.4, Math.min(1.4, p2.cameraAngle.x));

                    // Standard Mappings (Xbox/DualSense)
                    // 0: A/Cross, 1: B/Circle, 2: X/Square, 3: Y/Triangle
                    // 6: L2, 7: R2, 10: L3
                    if (gp.buttons && gp.buttons.length > 10) {
                        if (gp.buttons[0].pressed) p2Jump = true;
                        if (gp.buttons[2].pressed) p2Reload = true;
                        if (gp.buttons[7] && gp.buttons[7].value > 0.5) p2Shoot = true;
                        if (gp.buttons[10].pressed) p2Sprint = true; // L3 Sprint
                    }
                }

                p2.input.x = p2MoveX;
                p2.input.y = p2MoveY;
                p2.input.jump = p2Jump;
                p2.input.shoot = p2Shoot;
                p2.input.reload = p2Reload;
                p2.input.sprint = p2Sprint;
            }

            // ... Collisions & Loop ...
            // (Remaining functions logic)

            function checkCollisions() {

                // Proj vs Environment/Players
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    // Remove from scene if dead

                    // Vs Terrain/Tree (reused logic)
                    const h = getTerrainHeight(p.mesh.position.x, p.mesh.position.z);

                    if (p.mesh.position.y < h || p.mesh.position.y < -10) {
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                        continue;
                    }

                    // Vs Trees
                    let hitTree = false;

                    for (let t of treePos) {
                        const treeBaseY = getTerrainHeight(t.x, t.z);
                        // Check if hit tree cylinder (Approx Radius 1, Height 6)
                        const dx = p.mesh.position.x - t.x;
                        const dz = p.mesh.position.z - t.z;

                        if (dx * dx + dz * dz < 1.5) {

                            // Radius ~1.2
                            if (p.mesh.position.y > treeBaseY && p.mesh.position.y < treeBaseY + 6) {
                                hitTree = true;
                                break;
                            }
                        }
                    }

                    if (hitTree) {
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                        continue;
                    }

                    // Collision
                    let hit = null;
                    // Check Players
                    if (p.owner !== 1 && p.mesh.position.distanceTo(p1.mesh.position) < 1) hit = p1;
                    if (gameMode === MODE.PVP && p.owner !== 2 && p.mesh.position.distanceTo(p2.mesh.position) < 1) hit = p2;

                    if (gameMode === MODE.SOLO && p.owner === 1) {

                        // Player shot enemy
                        for (let e of enemies) {
                            if (e.hp > 0 && p.mesh.position.distanceTo(e.mesh.position) < 1) {
                                e.takeDamage(p.damage); // Use Projectile Damage
                                if (e.hp <= 0) e.hp = 0;
                                hit = e;
                                scene.remove(p.mesh);
                                projectiles.splice(i, 1);
                                break;
                            }
                        }

                        if (hit) continue;
                    }

                    if (hit === p1 || hit === p2) {
                        hit.takeDamage(p.damage); // Use Projectile Damage
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                    }
                }
            }

            let lastGpInputTime = 0;

            function updatePvPMenuInput() {
                const now = Date.now();
                if (now - lastGpInputTime < 150) return; // Faster debounce for responsiveness

                const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
                let gp = null;

                for (let i = 0; i < gamepads.length; i++) {
                    if (gamepads[i] && gamepads[i].buttons && gamepads[i].buttons.length > 0) {
                        gp = gamepads[i];
                        break; // Use the first active gamepad found
                    }
                }

                if (!gp) return;

                // Analog Stick Threshold
                const axisThreshold = 0.5;
                // Standard mapping: Axes[0] is Left Stick X. Buttons[14] is D-Pad Left, [15] is Right.
                let left = false;
                let right = false;

                if (gp.axes && gp.axes.length > 0) {
                    left = left || gp.axes[0] < -axisThreshold;
                    right = right || gp.axes[0] > axisThreshold;
                }

                if (gp.buttons && gp.buttons.length >= 16) {
                    left = left || gp.buttons[14].pressed;
                    right = right || gp.buttons[15].pressed;
                }

                if (left || right) {
                    const keys = Object.keys(WEAPONS);
                    let idx = keys.indexOf(p2SelectedWeapon);

                    if (left) idx--;
                    if (right) idx++;

                    if (idx < 0) idx = keys.length - 1;
                    if (idx >= keys.length) idx = 0;

                    p2SelectedWeapon = keys[idx];
                    updatePvPWeaponUI();
                    lastGpInputTime = now;
                }

                // Start Button (9) or A/X (0) to Start
                if (gp.buttons && gp.buttons.length > 9 && (gp.buttons[9].pressed || gp.buttons[0].pressed)) {
                    if (now - lastGpInputTime > 500) {
                        startPvPMatch();
                        lastGpInputTime = now;
                    }
                }
            }

            function render() {
                try {
                    requestAnimationFrame(render);

                    if (gameMode === MODE.PVP_SELECT) {
                        updatePvPMenuInput();
                    }

                    if (gameMode === MODE.MENU || gameMode === MODE.END || gameMode === MODE.PVP_SELECT || gameMode === MODE.SOLO_SELECT) {
                        renderer.setScissorTest(false);
                        renderer.render(scene, p1.camera); // Just render scene bg
                        return;
                    }

                    const dt = Math.min(clock.getDelta(), 0.1);
                    updateInput();
                    p1.update(dt);

                    if (gameMode === MODE.PVP) {
                        p2.update(dt);
                    }

                    else {
                        // Update Enemies
                        let alive = 0;

                        enemies.forEach(e => {
                            e.update(dt); if (e.hp > 0) alive++;
                        });
                        document.getElementById('solo-enemies').innerText = "ENEMIES: " + alive;
                        if (alive === 0) endGame(true);
                    }

                    // Projectiles
                    projectiles.forEach(p => {
                        p.life -= dt;

                        if (p.life <= 0) {
                            scene.remove(p.mesh);
                        }

                        else p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
                    });

                    // Cleanup dead projectiles
                    for (let i = projectiles.length - 1; i >= 0; i--) {
                        if (projectiles[i].life <= 0) projectiles.splice(i, 1);
                    }

                    checkCollisions();
                    updateUI();

                    // Win Condition
                    if (p1.hp <= 0 && gameMode === MODE.SOLO) endGame(false);

                    if (gameMode === MODE.PVP) {
                        if (p1.hp <= 0) endGame(false, "PLAYER 2 WINS");
                        if (p2.hp <= 0) endGame(true, "PLAYER 1 WINS");
                    }

                    // Render
                    if (gameMode === MODE.PVP) {
                        // Split Screen
                        const w = window.innerWidth;
                        const h = window.innerHeight;
                        renderer.setScissorTest(true);

                        // Top (P1)
                        p1.camera.aspect = w / (h / 2);
                        p1.camera.updateProjectionMatrix();
                        renderer.setScissor(0, h / 2, w, h / 2);
                        renderer.setViewport(0, h / 2, w, h / 2);
                        renderer.render(scene, p1.camera);

                        // Bottom (P2)
                        p2.camera.aspect = w / (h / 2);
                        p2.camera.updateProjectionMatrix();
                        renderer.setScissor(0, 0, w, h / 2);
                        renderer.setViewport(0, 0, w, h / 2);
                        renderer.render(scene, p2.camera);
                    }

                    else {
                        // Full Screen
                        renderer.setScissorTest(false);
                        p1.camera.aspect = window.innerWidth / window.innerHeight;
                        p1.camera.updateProjectionMatrix();
                        renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
                        renderer.render(scene, p1.camera);
                    }
                }

                catch (err) {
                    console.error(err);

                    // Throttle alerts to avoid loops
                    if (!window.hasAlerted) {
                        alert("Game Loop Error: " + err.message);
                        window.hasAlerted = true;
                    }
                }
            }

            // -- UI & LOGIC --
            const ui = {
                lobby: document.getElementById('lobby'),
                pvpWeaponSelect: document.getElementById('pvp-weapon-select'),
                soloWeaponSelect: document.getElementById('solo-weapon-select'),
                victory: document.getElementById('victory-screen'),
                ingameMenuBtn: document.getElementById('ingame-menu-btn'),
                hudSolo: document.getElementById('hud-solo'),
                hudP1: document.getElementById('hud-p1'),
                hudP2: document.getElementById('hud-p2'),
                p1Hp: document.getElementById('p1-hp'),
                p1Ammo: document.getElementById('p1-ammo'),
                p1Stamina: document.getElementById('p1-stamina-bar'),
                p2Hp: document.getElementById('p2-hp'),
                p2Ammo: document.getElementById('p2-ammo'),
                p2Stamina: document.getElementById('p2-stamina-bar'),
                soloHp: document.getElementById('solo-hp'),
                soloAmmo: document.getElementById('solo-ammo'),
                soloStamina: document.getElementById('solo-stamina-bar'),
                winText: document.getElementById('win-text'),
                menuBg: document.getElementById('menu-background-layer')
            }

                ;

            // ... (lines omitted)

            function startSoloConfirm() {
                // Renamed from startSolo to distinguish from the setup phase
                // This is the actual GAME START
                gameMode = MODE.SOLO;
                reset();

                // Spawn Enemies
                enemies.forEach(e => {
                    if (e.mesh.parent) scene.remove(e.mesh);
                });
                enemies.length = 0;

                enemySpawnPoints.forEach(p => {
                    enemies.push(new AIEnemy(p));
                });

                ui.lobby.classList.add('hidden');
                ui.soloWeaponSelect.classList.add('hidden');
                if (ui.menuBg) ui.menuBg.classList.add('hidden');
                ui.hudSolo.style.display = 'block';
                ui.ingameMenuBtn.classList.remove('hidden'); // SHOW BUTTON
                scene.remove(p2.mesh);

                document.body.requestPointerLock();
            }

            function startPvP() {
                try {
                    gameMode = MODE.PVP;
                    reset();
                    // Place Players
                    p1.respawn(new THREE.Vector3(0, 20, -80));
                    p2.respawn(new THREE.Vector3(15, 20, 80)); // Spawn OFFSET to avoid tree (was 0, 20, 80)
                    p2.mesh.rotation.y = Math.PI;

                    // Remove Enemies
                    enemies.forEach(e => {
                        if (e.mesh.parent) scene.remove(e.mesh);
                    });
                    enemies.length = 0;

                    ui.lobby.classList.add('hidden');
                    if (ui.menuBg) ui.menuBg.classList.add('hidden');
                    ui.hudP1.style.display = 'block';
                    ui.hudP2.style.display = 'block';
                    ui.ingameMenuBtn.classList.remove('hidden'); // SHOW BUTTON

                    if (!p2.mesh.parent) scene.add(p2.mesh);

                    document.body.requestPointerLock();
                }

                catch (err) {
                    alert("Error starting PvP: " + err.message);
                    console.error(err);
                }
            }

            function reset() {
                p1.respawn(new THREE.Vector3(0, 20, 0));
                // Clear projs
                projectiles.forEach(p => scene.remove(p.mesh));
                projectiles.length = 0;

                ui.victory.classList.add('hidden');
                ui.hudSolo.style.display = 'none';
                ui.hudP1.style.display = 'none';
                ui.hudP2.style.display = 'none';
                ui.ingameMenuBtn.classList.add('hidden'); // HIDE BUTTON
            }

            function returnToMenu() {
                try {
                    gameMode = MODE.MENU;
                    document.exitPointerLock();
                    ui.victory.classList.add('hidden');
                    ui.soloWeaponSelect.classList.add('hidden');
                    ui.pvpWeaponSelect.classList.add('hidden');
                    ui.lobby.classList.remove('hidden');
                    if (ui.menuBg) ui.menuBg.classList.remove('hidden');
                    reset(); // Will hide HUDs and Menu Btn
                }

                catch (err) {
                    console.error("Error in returnToMenu:", err);
                    // Force lobby even if reset fails
                    gameMode = MODE.MENU;
                    ui.lobby.classList.remove('hidden');
                    ui.ingameMenuBtn.classList.add('hidden');
                }
            }

            function endGame(won, msg) {
                gameMode = MODE.END;
                document.exitPointerLock();
                ui.victory.classList.remove('hidden');
                ui.hudSolo.style.display = 'none';
                ui.hudP1.style.display = 'none';
                ui.hudP2.style.display = 'none';
                ui.ingameMenuBtn.classList.add('hidden');

                if (msg) ui.winText.innerText = msg;
                else ui.winText.innerText = won ? "VICTORY ROYALE" : "FAILED";
            }

            function updateUI() {
                if (gameMode === MODE.SOLO) {
                    ui.soloHp.innerText = Math.floor(p1.hp);
                    ui.soloAmmo.innerText = p1.ammo;
                    ui.soloStamina.style.width = Math.floor(p1.stamina) + '%';
                }

                else if (gameMode === MODE.PVP) {
                    ui.p1Hp.innerText = Math.floor(p1.hp);
                    ui.p1Ammo.innerText = p1.ammo;
                    ui.p1Stamina.style.width = Math.floor(p1.stamina) + '%';
                    ui.p2Hp.innerText = Math.floor(p2.hp);
                    ui.p2Ammo.innerText = p2.ammo;
                    ui.p2Stamina.style.width = Math.floor(p2.stamina) + '%';
                }
            }

            const btns = document.querySelectorAll('button');

            btns.forEach(b => {
                b.addEventListener('mousedown', (e) => e.stopPropagation());
            });


            // Expose to window for HTML onclick events
            window.selectPvPWeapon = selectPvPWeapon;
            window.selectSoloWeapon = selectSoloWeapon;

            // SOLO FLOW
            document.getElementById('solo-btn').onclick = (e) => {
                e.stopPropagation();
                showSoloWeaponSelect();
            }

                ;

            document.getElementById('start-solo-match-btn').onclick = (e) => {
                e.stopPropagation();
                // Apply Weapon to P1
                p1.setWeapon(selectedWeapon);
                startSoloConfirm();
            }

                ;

            function showSoloWeaponSelect() {
                gameMode = MODE.SOLO_SELECT;
                ui.lobby.classList.add('hidden');
                ui.soloWeaponSelect.classList.remove('hidden');
                // Default selection
                selectSoloWeapon('ar');
            }

            function selectSoloWeapon(key) {
                selectedWeapon = key;
                const opts = document.querySelectorAll('.weapon-btn-solo');

                opts.forEach(btn => {
                    if (btn.getAttribute('data-weapon') === key) {
                        btn.classList.add('selected');
                    }

                    else {
                        btn.classList.remove('selected');
                    }
                });
            }


            document.getElementById('pvp-btn').onclick = (e) => {
                e.stopPropagation();
                showPvPWeaponSelect();
            }

                ;

            document.getElementById('restart-btn').onclick = (e) => {
                e.stopPropagation();
                gameMode = MODE.MENU;
                ui.victory.classList.add('hidden');
                ui.lobby.classList.remove('hidden');
                ui.soloWeaponSelect.classList.add('hidden'); // Ensure closed
            }

                ;

            document.getElementById('ingame-menu-btn').onclick = (e) => {
                e.stopPropagation();
                returnToMenu();
            }

                ;

            // PvP Weapon Selection Functions
            function showPvPWeaponSelect() {
                gameMode = MODE.PVP_SELECT;

                ui.lobby.classList.add('hidden');
                ui.pvpWeaponSelect.classList.remove('hidden');
                p1SelectedWeapon = 'ar';
                p2SelectedWeapon = 'ar';
                updatePvPWeaponUI();
            }

            function selectPvPWeapon(player, weaponKey) {
                if (player === 1) {
                    p1SelectedWeapon = weaponKey;
                }

                else if (player === 2) {
                    p2SelectedWeapon = weaponKey;
                }

                updatePvPWeaponUI();
            }

            function updatePvPWeaponUI() {
                const p1Opts = document.querySelectorAll('.weapon-btn-solo.p1');

                p1Opts.forEach(opt => {
                    if (opt.getAttribute('data-weapon') === p1SelectedWeapon) {
                        opt.classList.add('selected');
                    }

                    else {
                        opt.classList.remove('selected');
                    }
                });

                const p2Opts = document.querySelectorAll('.weapon-btn-solo.p2');

                p2Opts.forEach(opt => {
                    if (opt.getAttribute('data-weapon') === p2SelectedWeapon) {
                        opt.classList.add('selected');
                    }

                    else {
                        opt.classList.remove('selected');
                    }
                });
            }

            function startPvPMatch() {
                ui.pvpWeaponSelect.classList.add('hidden');
                p1.setWeapon(p1SelectedWeapon);
                p2.setWeapon(p2SelectedWeapon);
                startPvP();
            }

            document.getElementById('start-pvp-match-btn').onclick = (e) => {
                e.stopPropagation();
                startPvPMatch();
            }

                ;

            // Window Resize Handling
            window.addEventListener('resize', () => {
                const w = window.innerWidth;
                const h = window.innerHeight;
                renderer.setSize(w, h);

                if (gameMode === MODE.PVP) {
                    p1.camera.aspect = w / (h / 2);
                    p1.camera.updateProjectionMatrix();
                    p2.camera.aspect = w / (h / 2);
                    p2.camera.updateProjectionMatrix();
                }

                else {
                    p1.camera.aspect = w / h;
                    p1.camera.updateProjectionMatrix();
                }
            });

            render();
        </script>
</body>

</html>